#![doc = "Peripheral access API for LKS32MC03X microcontrollers (generated using svd2rust v0.36.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.36.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Generic peripheral accessor"]
    pub struct Periph<RB, const A: usize> {
        _marker: marker::PhantomData<RB>,
    }
    unsafe impl<RB, const A: usize> Send for Periph<RB, A> {}
    impl<RB, const A: usize> Periph<RB, A> {
        #[doc = "Pointer to the register block"]
        pub const PTR: *const RB = A as *const _;
        #[doc = "Return the pointer to the register block"]
        #[inline(always)]
        pub const fn ptr() -> *const RB {
            Self::PTR
        }
        #[doc = " Steal an instance of this peripheral"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Ensure that the new instance of the peripheral cannot be used in a way"]
        #[doc = " that may race with any existing instances, for example by only"]
        #[doc = " accessing read-only or write-only registers, or by consuming the"]
        #[doc = " original peripheral and using critical sections to coordinate"]
        #[doc = " access between multiple new instances."]
        #[doc = ""]
        #[doc = " Additionally, other software such as HALs may rely on only one"]
        #[doc = " peripheral instance existing to ensure memory safety; ensure"]
        #[doc = " no stolen instances are passed to such software."]
        pub unsafe fn steal() -> Self {
            Self {
                _marker: marker::PhantomData,
            }
        }
    }
    impl<RB, const A: usize> core::ops::Deref for Periph<RB, A> {
        type Target = RB;
        #[inline(always)]
        fn deref(&self) -> &Self::Target {
            unsafe { &*Self::PTR }
        }
    }
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " `0`"]
        const ZERO: Self;
        #[doc = " `1`"]
        const ONE: Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                const ZERO: Self = 0;
                const ONE: Self = 1;
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + core::fmt::Debug + PartialEq + From<Self>;
    }
    #[doc = " Marker for fields with fixed values"]
    pub trait IsEnum: FieldSpec {}
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Is it safe to write any bits to register"]
        type Safety;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = Self::Ux::ZERO;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = Self::Ux::ZERO;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux = Self::Ux::ZERO;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc(hidden)]
    pub mod raw {
        use super::{marker, BitM, FieldSpec, RegisterSpec, Unsafe, Writable};
        pub struct R<REG: RegisterSpec> {
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct W<REG: RegisterSpec> {
            #[doc = "Writable bits"]
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct FieldReader<FI = u8>
        where
            FI: FieldSpec,
        {
            pub(crate) bits: FI::Ux,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI: FieldSpec> FieldReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: FI::Ux) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct BitReader<FI = bool> {
            pub(crate) bits: bool,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI> BitReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: bool) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        #[must_use = "after creating `FieldWriter` you need to call field value setting method"]
        pub struct FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, Safety)>,
        }
        impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
        #[must_use = "after creating `BitWriter` you need to call bit setting method"]
        pub struct BitWriter<'a, REG, FI = bool, M = BitM>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, M)>,
        }
        impl<'a, REG, FI, M> BitWriter<'a, REG, FI, M>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub type R<REG> = raw::R<REG>;
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub const fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub type W<REG> = raw::W<REG>;
    impl<REG: Writable> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    impl<REG> W<REG>
    where
        REG: Writable<Safety = Safe>,
    {
        #[doc = " Writes raw bits to the register."]
        #[inline(always)]
        pub fn set(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = raw::FieldReader<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = raw::BitReader<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub const fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI: FieldSpec> core::fmt::Debug for FieldReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub const fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub const fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub const fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    impl<FI> core::fmt::Debug for BitReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    #[doc = " Marker for register/field writers which can take any value of specified width"]
    pub struct Safe;
    #[doc = " You should check that value is allowed to pass to register/field writer marked with this"]
    pub struct Unsafe;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct Range<const MIN: u64, const MAX: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeFrom<const MIN: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeTo<const MAX: u64>;
    #[doc = " Write field Proxy"]
    pub type FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe> =
        raw::FieldWriter<'a, REG, WI, FI, Safety>;
    impl<REG, const WI: u8, FI, Safety> FieldWriter<'_, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Field width"]
        #[inline(always)]
        pub const fn width(&self) -> u8 {
            WI
        }
        #[doc = " Field offset"]
        #[inline(always)]
        pub const fn offset(&self) -> u8 {
            self.o
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << self.o);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << self.o;
            self.w
        }
    }
    impl<'a, REG, const WI: u8, FI> FieldWriter<'a, REG, WI, FI, Safe>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64, const MAX: u64>
        FieldWriter<'a, REG, WI, FI, Range<MIN, MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN && value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64> FieldWriter<'a, REG, WI, FI, RangeFrom<MIN>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MAX: u64> FieldWriter<'a, REG, WI, FI, RangeTo<MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: IsEnum,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, FI = bool> = raw::BitWriter<'a, REG, FI, $mwv>;
            impl<'a, REG, FI> $writer<'a, REG, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
                #[doc = " Field width"]
                #[inline(always)]
                pub const fn width(&self) -> u8 {
                    Self::WIDTH
                }
                #[doc = " Field offset"]
                #[inline(always)]
                pub const fn offset(&self) -> u8 {
                    self.o
                }
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W<REG> {
                    self.w.bits &= !(REG::Ux::ONE << self.o);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::ONE) << self.o;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut W<REG> {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, FI> BitWriter<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<REG> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F) -> REG::Ux
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            let value = f(&mut W {
                bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                    | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            })
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Writes bits to a `Writable` register and produce a value."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| unsafe { w.bits(rawbits); });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits)"]
        #[doc = "         .field2().set_bit()"]
        #[doc = "         .field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[doc = ""]
        #[doc = " Values can be returned from the closure:"]
        #[doc = " ```ignore"]
        #[doc = " let state = periph.reg.write_and(|w| State::set(w.field1()));"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn from_write<F, T>(&self, f: F) -> T
        where
            F: FnOnce(&mut W<REG>) -> T,
        {
            let mut writer = W {
                bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                    | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            };
            let result = f(&mut writer);
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F) -> REG::Ux
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            let value = f(&mut W {
                bits: REG::Ux::ZERO,
                _reg: marker::PhantomData,
            })
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Writes 0 to a `Writable` register and produces a value."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn from_write_with_zero<F, T>(&self, f: F) -> T
        where
            F: FnOnce(&mut W<REG>) -> T,
        {
            let mut writer = W {
                bits: REG::Ux::ZERO,
                _reg: marker::PhantomData,
            };
            let result = f(&mut writer);
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F) -> REG::Ux
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            let value = f(
                &R {
                    bits,
                    _reg: marker::PhantomData,
                },
                &mut W {
                    bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                },
            )
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Modifies the contents of the register by reading and then writing it"]
        #[doc = " and produces a value."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.modify(|r, w| {"]
        #[doc = "     let new_bits = r.bits() | 3;"]
        #[doc = "     unsafe {"]
        #[doc = "         w.bits(new_bits);"]
        #[doc = "     }"]
        #[doc = ""]
        #[doc = "     new_bits"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits)"]
        #[doc = "         .field2().set_bit()"]
        #[doc = "         .field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn from_modify<F, T>(&self, f: F) -> T
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> T,
        {
            let bits = self.register.get();
            let mut writer = W {
                bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            };
            let result = f(
                &R {
                    bits,
                    _reg: marker::PhantomData,
                },
                &mut writer,
            );
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Readable> core::fmt::Debug for crate::generic::Reg<REG>
    where
        R<REG>: core::fmt::Debug,
    {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.read(), f)
        }
    }
}
#[cfg(feature = "rt")]
extern "C" {
    fn TIMER0();
    fn TIMER1();
    fn MCPWM0();
    fn MCPWM1();
    fn I2C();
    fn SPI();
    fn HALL();
    fn UART();
    fn CMP();
    fn ADC();
    fn DMA();
    fn WAKE();
    fn SW();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 14] = [
    Vector { _handler: TIMER0 },
    Vector { _handler: TIMER1 },
    Vector { _handler: MCPWM0 },
    Vector { _handler: MCPWM1 },
    Vector { _handler: I2C },
    Vector { _handler: SPI },
    Vector { _reserved: 0 },
    Vector { _handler: HALL },
    Vector { _handler: UART },
    Vector { _handler: CMP },
    Vector { _handler: ADC },
    Vector { _handler: DMA },
    Vector { _handler: WAKE },
    Vector { _handler: SW },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - TIMER0"]
    TIMER0 = 0,
    #[doc = "1 - TIMER1"]
    TIMER1 = 1,
    #[doc = "2 - MCPWM0"]
    MCPWM0 = 2,
    #[doc = "3 - MCPWM1"]
    MCPWM1 = 3,
    #[doc = "4 - I2C"]
    I2C = 4,
    #[doc = "5 - SPI"]
    SPI = 5,
    #[doc = "7 - HALL"]
    HALL = 7,
    #[doc = "8 - UART"]
    UART = 8,
    #[doc = "9 - CMP"]
    CMP = 9,
    #[doc = "10 - ADC"]
    ADC = 10,
    #[doc = "11 - DMA"]
    DMA = 11,
    #[doc = "12 - WAKE"]
    WAKE = 12,
    #[doc = "13 - SW"]
    SW = 13,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "SYS registers"]
pub type Sys = crate::Periph<sys::RegisterBlock, 0x4000_0000>;
impl core::fmt::Debug for Sys {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sys").finish()
    }
}
#[doc = "SYS registers"]
pub mod sys {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        afe_adc: AfeAdc,
        afe_info: AfeInfo,
        _reserved2: [u8; 0x04],
        opa_sel: OpaSel,
        afe_reg0: AfeReg0,
        afe_reg1: AfeReg1,
        afe_reg2: AfeReg2,
        afe_reg3: AfeReg3,
        afe_reg4: AfeReg4,
        afe_reg5: AfeReg5,
        afe_reg6: AfeReg6,
        afe_dac: AfeDac,
        _reserved11: [u8; 0x50],
        clk_cfg: ClkCfg,
        io_cfg: IoCfg,
        dbg_cfg: DbgCfg,
        _reserved14: [u8; 0x04],
        clk_div0: ClkDiv0,
        _reserved15: [u8; 0x04],
        clk_div2: ClkDiv2,
        clk_fen: ClkFen,
        _reserved17: [u8; 0x04],
        sfr_rst: SfrRst,
        protect: Protect,
        _reserved19: [u8; 0x24],
        flse: Flse,
        flsp: Flsp,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Raw data from AD Core"]
        #[inline(always)]
        pub const fn afe_adc(&self) -> &AfeAdc {
            &self.afe_adc
        }
        #[doc = "0x04 - Chip Version"]
        #[inline(always)]
        pub const fn afe_info(&self) -> &AfeInfo {
            &self.afe_info
        }
        #[doc = "0x0c - OPA mux enable"]
        #[inline(always)]
        pub const fn opa_sel(&self) -> &OpaSel {
            &self.opa_sel
        }
        #[doc = "0x10 - Analog reg0"]
        #[inline(always)]
        pub const fn afe_reg0(&self) -> &AfeReg0 {
            &self.afe_reg0
        }
        #[doc = "0x14 - Analog reg1"]
        #[inline(always)]
        pub const fn afe_reg1(&self) -> &AfeReg1 {
            &self.afe_reg1
        }
        #[doc = "0x18 - Analog reg2"]
        #[inline(always)]
        pub const fn afe_reg2(&self) -> &AfeReg2 {
            &self.afe_reg2
        }
        #[doc = "0x1c - Analog reg3"]
        #[inline(always)]
        pub const fn afe_reg3(&self) -> &AfeReg3 {
            &self.afe_reg3
        }
        #[doc = "0x20 - Analog reg4"]
        #[inline(always)]
        pub const fn afe_reg4(&self) -> &AfeReg4 {
            &self.afe_reg4
        }
        #[doc = "0x24 - Analog reg5"]
        #[inline(always)]
        pub const fn afe_reg5(&self) -> &AfeReg5 {
            &self.afe_reg5
        }
        #[doc = "0x28 - Analog reg6"]
        #[inline(always)]
        pub const fn afe_reg6(&self) -> &AfeReg6 {
            &self.afe_reg6
        }
        #[doc = "0x2c - DAC digital input"]
        #[inline(always)]
        pub const fn afe_dac(&self) -> &AfeDac {
            &self.afe_dac
        }
        #[doc = "0x80 - Clock configuration"]
        #[inline(always)]
        pub const fn clk_cfg(&self) -> &ClkCfg {
            &self.clk_cfg
        }
        #[doc = "0x84 - IO configuration"]
        #[inline(always)]
        pub const fn io_cfg(&self) -> &IoCfg {
            &self.io_cfg
        }
        #[doc = "0x88 - IO configuration"]
        #[inline(always)]
        pub const fn dbg_cfg(&self) -> &DbgCfg {
            &self.dbg_cfg
        }
        #[doc = "0x90 - I2C Clock division ratio"]
        #[inline(always)]
        pub const fn clk_div0(&self) -> &ClkDiv0 {
            &self.clk_div0
        }
        #[doc = "0x98 - UART 0/1 Clock division ratio"]
        #[inline(always)]
        pub const fn clk_div2(&self) -> &ClkDiv2 {
            &self.clk_div2
        }
        #[doc = "0x9c - Peripheral clock enable"]
        #[inline(always)]
        pub const fn clk_fen(&self) -> &ClkFen {
            &self.clk_fen
        }
        #[doc = "0xa4 - Peripheral soft reset"]
        #[inline(always)]
        pub const fn sfr_rst(&self) -> &SfrRst {
            &self.sfr_rst
        }
        #[doc = "0xa8 - System reg protect"]
        #[inline(always)]
        pub const fn protect(&self) -> &Protect {
            &self.protect
        }
        #[doc = "0xd0 - Flash erase protection"]
        #[inline(always)]
        pub const fn flse(&self) -> &Flse {
            &self.flse
        }
        #[doc = "0xd4 - Flash program protection"]
        #[inline(always)]
        pub const fn flsp(&self) -> &Flsp {
            &self.flsp
        }
    }
    #[doc = "AFE_ADC (r) register accessor: Raw data from AD Core\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_adc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afe_adc`] module"]
    #[doc(alias = "AFE_ADC")]
    pub type AfeAdc = crate::Reg<afe_adc::AfeAdcSpec>;
    #[doc = "Raw data from AD Core"]
    pub mod afe_adc {
        #[doc = "Register `AFE_ADC` reader"]
        pub type R = crate::R<AfeAdcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        #[doc = "Raw data from AD Core\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_adc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AfeAdcSpec;
        impl crate::RegisterSpec for AfeAdcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`afe_adc::R`](R) reader structure"]
        impl crate::Readable for AfeAdcSpec {}
        #[doc = "`reset()` method sets AFE_ADC to value 0"]
        impl crate::Resettable for AfeAdcSpec {}
    }
    #[doc = "AFE_INFO (r) register accessor: Chip Version\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_info::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afe_info`] module"]
    #[doc(alias = "AFE_INFO")]
    pub type AfeInfo = crate::Reg<afe_info::AfeInfoSpec>;
    #[doc = "Chip Version"]
    pub mod afe_info {
        #[doc = "Register `AFE_INFO` reader"]
        pub type R = crate::R<AfeInfoSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        #[doc = "Chip Version\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_info::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AfeInfoSpec;
        impl crate::RegisterSpec for AfeInfoSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`afe_info::R`](R) reader structure"]
        impl crate::Readable for AfeInfoSpec {}
        #[doc = "`reset()` method sets AFE_INFO to value 0"]
        impl crate::Resettable for AfeInfoSpec {}
    }
    #[doc = "OPA_SEL (rw) register accessor: OPA mux enable\n\nYou can [`read`](crate::Reg::read) this register and get [`opa_sel::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`opa_sel::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@opa_sel`] module"]
    #[doc(alias = "OPA_SEL")]
    pub type OpaSel = crate::Reg<opa_sel::OpaSelSpec>;
    #[doc = "OPA mux enable"]
    pub mod opa_sel {
        #[doc = "Register `OPA_SEL` reader"]
        pub type R = crate::R<OpaSelSpec>;
        #[doc = "Register `OPA_SEL` writer"]
        pub type W = crate::W<OpaSelSpec>;
        #[doc = "OPA mux selection enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OpaSelEn {
            #[doc = "0: Sample ADC_CH8 when ADC_CH8 is selected"]
            Disabled = 0,
            #[doc = "1: Sample OPA1_OUT instead of ADC_CH8"]
            Enabled = 1,
        }
        impl From<OpaSelEn> for bool {
            #[inline(always)]
            fn from(variant: OpaSelEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OPA_SEL_EN` reader - OPA mux selection enable"]
        pub type OpaSelEnR = crate::BitReader<OpaSelEn>;
        impl OpaSelEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OpaSelEn {
                match self.bits {
                    false => OpaSelEn::Disabled,
                    true => OpaSelEn::Enabled,
                }
            }
            #[doc = "Sample ADC_CH8 when ADC_CH8 is selected"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OpaSelEn::Disabled
            }
            #[doc = "Sample OPA1_OUT instead of ADC_CH8"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OpaSelEn::Enabled
            }
        }
        #[doc = "Field `OPA_SEL_EN` writer - OPA mux selection enable"]
        pub type OpaSelEnW<'a, REG> = crate::BitWriter<'a, REG, OpaSelEn>;
        impl<'a, REG> OpaSelEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Sample ADC_CH8 when ADC_CH8 is selected"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(OpaSelEn::Disabled)
            }
            #[doc = "Sample OPA1_OUT instead of ADC_CH8"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(OpaSelEn::Enabled)
            }
        }
        impl R {
            #[doc = "Bit 0 - OPA mux selection enable"]
            #[inline(always)]
            pub fn opa_sel_en(&self) -> OpaSelEnR {
                OpaSelEnR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - OPA mux selection enable"]
            #[inline(always)]
            pub fn opa_sel_en(&mut self) -> OpaSelEnW<OpaSelSpec> {
                OpaSelEnW::new(self, 0)
            }
        }
        #[doc = "OPA mux enable\n\nYou can [`read`](crate::Reg::read) this register and get [`opa_sel::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`opa_sel::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct OpaSelSpec;
        impl crate::RegisterSpec for OpaSelSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`opa_sel::R`](R) reader structure"]
        impl crate::Readable for OpaSelSpec {}
        #[doc = "`write(|w| ..)` method takes [`opa_sel::W`](W) writer structure"]
        impl crate::Writable for OpaSelSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets OPA_SEL to value 0"]
        impl crate::Resettable for OpaSelSpec {}
    }
    #[doc = "AFE_REG0 (rw) register accessor: Analog reg0\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afe_reg0`] module"]
    #[doc(alias = "AFE_REG0")]
    pub type AfeReg0 = crate::Reg<afe_reg0::AfeReg0Spec>;
    #[doc = "Analog reg0"]
    pub mod afe_reg0 {
        #[doc = "Register `AFE_REG0` reader"]
        pub type R = crate::R<AfeReg0Spec>;
        #[doc = "Register `AFE_REG0` writer"]
        pub type W = crate::W<AfeReg0Spec>;
        #[doc = "OPA0 feedback resistor\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ResOpa0 {
            #[doc = "0: 200k:10k"]
            _200k10k = 0,
            #[doc = "1: 190k:20k"]
            _190k20k = 1,
            #[doc = "2: 180k:30k"]
            _180k30k = 2,
            #[doc = "3: 170k:40k"]
            _170k40k = 3,
        }
        impl From<ResOpa0> for u8 {
            #[inline(always)]
            fn from(variant: ResOpa0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ResOpa0 {
            type Ux = u8;
        }
        impl crate::IsEnum for ResOpa0 {}
        #[doc = "Field `RES_OPA0` reader - OPA0 feedback resistor"]
        pub type ResOpa0R = crate::FieldReader<ResOpa0>;
        impl ResOpa0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ResOpa0 {
                match self.bits {
                    0 => ResOpa0::_200k10k,
                    1 => ResOpa0::_190k20k,
                    2 => ResOpa0::_180k30k,
                    3 => ResOpa0::_170k40k,
                    _ => unreachable!(),
                }
            }
            #[doc = "200k:10k"]
            #[inline(always)]
            pub fn is_200k_10k(&self) -> bool {
                *self == ResOpa0::_200k10k
            }
            #[doc = "190k:20k"]
            #[inline(always)]
            pub fn is_190k_20k(&self) -> bool {
                *self == ResOpa0::_190k20k
            }
            #[doc = "180k:30k"]
            #[inline(always)]
            pub fn is_180k_30k(&self) -> bool {
                *self == ResOpa0::_180k30k
            }
            #[doc = "170k:40k"]
            #[inline(always)]
            pub fn is_170k_40k(&self) -> bool {
                *self == ResOpa0::_170k40k
            }
        }
        #[doc = "Field `RES_OPA0` writer - OPA0 feedback resistor"]
        pub type ResOpa0W<'a, REG> = crate::FieldWriter<'a, REG, 2, ResOpa0, crate::Safe>;
        impl<'a, REG> ResOpa0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "200k:10k"]
            #[inline(always)]
            pub fn _200k_10k(self) -> &'a mut crate::W<REG> {
                self.variant(ResOpa0::_200k10k)
            }
            #[doc = "190k:20k"]
            #[inline(always)]
            pub fn _190k_20k(self) -> &'a mut crate::W<REG> {
                self.variant(ResOpa0::_190k20k)
            }
            #[doc = "180k:30k"]
            #[inline(always)]
            pub fn _180k_30k(self) -> &'a mut crate::W<REG> {
                self.variant(ResOpa0::_180k30k)
            }
            #[doc = "170k:40k"]
            #[inline(always)]
            pub fn _170k_40k(self) -> &'a mut crate::W<REG> {
                self.variant(ResOpa0::_170k40k)
            }
        }
        #[doc = "OPA output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OpaoutEn {
            #[doc = "0: No output"]
            Disabled = 0,
            #[doc = "1: OPA output to P0\\[7\\]"]
            Enabled = 1,
        }
        impl From<OpaoutEn> for bool {
            #[inline(always)]
            fn from(variant: OpaoutEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OPAOUT_EN` reader - OPA output enable"]
        pub type OpaoutEnR = crate::BitReader<OpaoutEn>;
        impl OpaoutEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OpaoutEn {
                match self.bits {
                    false => OpaoutEn::Disabled,
                    true => OpaoutEn::Enabled,
                }
            }
            #[doc = "No output"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OpaoutEn::Disabled
            }
            #[doc = "OPA output to P0\\[7\\]"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OpaoutEn::Enabled
            }
        }
        #[doc = "Field `OPAOUT_EN` writer - OPA output enable"]
        pub type OpaoutEnW<'a, REG> = crate::BitWriter<'a, REG, OpaoutEn>;
        impl<'a, REG> OpaoutEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No output"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(OpaoutEn::Disabled)
            }
            #[doc = "OPA output to P0\\[7\\]"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(OpaoutEn::Enabled)
            }
        }
        #[doc = "OPA0 input B enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Opa0BEn {
            #[doc = "0: Use OPA0_IP/OPA0_IN"]
            Opa0 = 0,
            #[doc = "1: Use OPA0_IP_B/OPA0_IN_B"]
            Opa0B = 1,
        }
        impl From<Opa0BEn> for bool {
            #[inline(always)]
            fn from(variant: Opa0BEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OPA0_B_EN` reader - OPA0 input B enable"]
        pub type Opa0BEnR = crate::BitReader<Opa0BEn>;
        impl Opa0BEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Opa0BEn {
                match self.bits {
                    false => Opa0BEn::Opa0,
                    true => Opa0BEn::Opa0B,
                }
            }
            #[doc = "Use OPA0_IP/OPA0_IN"]
            #[inline(always)]
            pub fn is_opa0(&self) -> bool {
                *self == Opa0BEn::Opa0
            }
            #[doc = "Use OPA0_IP_B/OPA0_IN_B"]
            #[inline(always)]
            pub fn is_opa0_b(&self) -> bool {
                *self == Opa0BEn::Opa0B
            }
        }
        #[doc = "Field `OPA0_B_EN` writer - OPA0 input B enable"]
        pub type Opa0BEnW<'a, REG> = crate::BitWriter<'a, REG, Opa0BEn>;
        impl<'a, REG> Opa0BEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Use OPA0_IP/OPA0_IN"]
            #[inline(always)]
            pub fn opa0(self) -> &'a mut crate::W<REG> {
                self.variant(Opa0BEn::Opa0)
            }
            #[doc = "Use OPA0_IP_B/OPA0_IN_B"]
            #[inline(always)]
            pub fn opa0_b(self) -> &'a mut crate::W<REG> {
                self.variant(Opa0BEn::Opa0B)
            }
        }
        #[doc = "ADC gain select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum GainAdc {
            #[doc = "0: 0.66 times"]
            _0p66 = 0,
            #[doc = "1: 1 times"]
            _1 = 1,
        }
        impl From<GainAdc> for bool {
            #[inline(always)]
            fn from(variant: GainAdc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `GAIN_ADC` reader - ADC gain select"]
        pub type GainAdcR = crate::BitReader<GainAdc>;
        impl GainAdcR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> GainAdc {
                match self.bits {
                    false => GainAdc::_0p66,
                    true => GainAdc::_1,
                }
            }
            #[doc = "0.66 times"]
            #[inline(always)]
            pub fn is_0p66(&self) -> bool {
                *self == GainAdc::_0p66
            }
            #[doc = "1 times"]
            #[inline(always)]
            pub fn is_1(&self) -> bool {
                *self == GainAdc::_1
            }
        }
        #[doc = "Field `GAIN_ADC` writer - ADC gain select"]
        pub type GainAdcW<'a, REG> = crate::BitWriter<'a, REG, GainAdc>;
        impl<'a, REG> GainAdcW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "0.66 times"]
            #[inline(always)]
            pub fn _0p66(self) -> &'a mut crate::W<REG> {
                self.variant(GainAdc::_0p66)
            }
            #[doc = "1 times"]
            #[inline(always)]
            pub fn _1(self) -> &'a mut crate::W<REG> {
                self.variant(GainAdc::_1)
            }
        }
        #[doc = "ADC reference select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ref2vdd {
            #[doc = "0: Use internal 2.4V as ADC reference"]
            _2p4 = 0,
            #[doc = "1: Use AVDD as ADC reference"]
            Avdd = 1,
        }
        impl From<Ref2vdd> for bool {
            #[inline(always)]
            fn from(variant: Ref2vdd) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `REF2VDD` reader - ADC reference select"]
        pub type Ref2vddR = crate::BitReader<Ref2vdd>;
        impl Ref2vddR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ref2vdd {
                match self.bits {
                    false => Ref2vdd::_2p4,
                    true => Ref2vdd::Avdd,
                }
            }
            #[doc = "Use internal 2.4V as ADC reference"]
            #[inline(always)]
            pub fn is_2p4(&self) -> bool {
                *self == Ref2vdd::_2p4
            }
            #[doc = "Use AVDD as ADC reference"]
            #[inline(always)]
            pub fn is_avdd(&self) -> bool {
                *self == Ref2vdd::Avdd
            }
        }
        #[doc = "Field `REF2VDD` writer - ADC reference select"]
        pub type Ref2vddW<'a, REG> = crate::BitWriter<'a, REG, Ref2vdd>;
        impl<'a, REG> Ref2vddW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Use internal 2.4V as ADC reference"]
            #[inline(always)]
            pub fn _2p4(self) -> &'a mut crate::W<REG> {
                self.variant(Ref2vdd::_2p4)
            }
            #[doc = "Use AVDD as ADC reference"]
            #[inline(always)]
            pub fn avdd(self) -> &'a mut crate::W<REG> {
                self.variant(Ref2vdd::Avdd)
            }
        }
        #[doc = "ADC on-off\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Adcpdn {
            #[doc = "0: OFF(Default)"]
            Off = 0,
            #[doc = "1: ON"]
            On = 1,
        }
        impl From<Adcpdn> for bool {
            #[inline(always)]
            fn from(variant: Adcpdn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ADCPDN` reader - ADC on-off"]
        pub type AdcpdnR = crate::BitReader<Adcpdn>;
        impl AdcpdnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Adcpdn {
                match self.bits {
                    false => Adcpdn::Off,
                    true => Adcpdn::On,
                }
            }
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Adcpdn::Off
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Adcpdn::On
            }
        }
        #[doc = "Field `ADCPDN` writer - ADC on-off"]
        pub type AdcpdnW<'a, REG> = crate::BitWriter<'a, REG, Adcpdn>;
        impl<'a, REG> AdcpdnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Adcpdn::Off)
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Adcpdn::On)
            }
        }
        #[doc = "OPA on-off\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Opapdn {
            #[doc = "0: OFF(Default)"]
            Off = 0,
            #[doc = "1: ON"]
            On = 1,
        }
        impl From<Opapdn> for bool {
            #[inline(always)]
            fn from(variant: Opapdn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OPAPDN` reader - OPA on-off"]
        pub type OpapdnR = crate::BitReader<Opapdn>;
        impl OpapdnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Opapdn {
                match self.bits {
                    false => Opapdn::Off,
                    true => Opapdn::On,
                }
            }
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Opapdn::Off
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Opapdn::On
            }
        }
        #[doc = "Field `OPAPDN` writer - OPA on-off"]
        pub type OpapdnW<'a, REG> = crate::BitWriter<'a, REG, Opapdn>;
        impl<'a, REG> OpapdnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Opapdn::Off)
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Opapdn::On)
            }
        }
        #[doc = "Bandgap on-off\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Bgppd {
            #[doc = "0: ON(Default)"]
            On = 0,
            #[doc = "1: OFF"]
            Off = 1,
        }
        impl From<Bgppd> for bool {
            #[inline(always)]
            fn from(variant: Bgppd) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BGPPD` reader - Bandgap on-off"]
        pub type BgppdR = crate::BitReader<Bgppd>;
        impl BgppdR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Bgppd {
                match self.bits {
                    false => Bgppd::On,
                    true => Bgppd::Off,
                }
            }
            #[doc = "ON(Default)"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Bgppd::On
            }
            #[doc = "OFF"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Bgppd::Off
            }
        }
        #[doc = "Field `BGPPD` writer - Bandgap on-off"]
        pub type BgppdW<'a, REG> = crate::BitWriter<'a, REG, Bgppd>;
        impl<'a, REG> BgppdW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "ON(Default)"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Bgppd::On)
            }
            #[doc = "OFF"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Bgppd::Off)
            }
        }
        #[doc = "DAC on-off\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Dacpdn {
            #[doc = "0: OFF(Default)"]
            Off = 0,
            #[doc = "1: ON"]
            On = 1,
        }
        impl From<Dacpdn> for bool {
            #[inline(always)]
            fn from(variant: Dacpdn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DACPDN` reader - DAC on-off"]
        pub type DacpdnR = crate::BitReader<Dacpdn>;
        impl DacpdnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Dacpdn {
                match self.bits {
                    false => Dacpdn::Off,
                    true => Dacpdn::On,
                }
            }
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Dacpdn::Off
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Dacpdn::On
            }
        }
        #[doc = "Field `DACPDN` writer - DAC on-off"]
        pub type DacpdnW<'a, REG> = crate::BitWriter<'a, REG, Dacpdn>;
        impl<'a, REG> DacpdnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Dacpdn::Off)
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Dacpdn::On)
            }
        }
        #[doc = "Temp sensor on-off\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tmppdn {
            #[doc = "0: OFF(Default)"]
            Off = 0,
            #[doc = "1: ON"]
            On = 1,
        }
        impl From<Tmppdn> for bool {
            #[inline(always)]
            fn from(variant: Tmppdn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TMPPDN` reader - Temp sensor on-off"]
        pub type TmppdnR = crate::BitReader<Tmppdn>;
        impl TmppdnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tmppdn {
                match self.bits {
                    false => Tmppdn::Off,
                    true => Tmppdn::On,
                }
            }
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Tmppdn::Off
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Tmppdn::On
            }
        }
        #[doc = "Field `TMPPDN` writer - Temp sensor on-off"]
        pub type TmppdnW<'a, REG> = crate::BitWriter<'a, REG, Tmppdn>;
        impl<'a, REG> TmppdnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Tmppdn::Off)
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Tmppdn::On)
            }
        }
        #[doc = "Comparator 0 on-off\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cmp0pdn {
            #[doc = "0: OFF(Default)"]
            Off = 0,
            #[doc = "1: ON"]
            On = 1,
        }
        impl From<Cmp0pdn> for bool {
            #[inline(always)]
            fn from(variant: Cmp0pdn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP0PDN` reader - Comparator 0 on-off"]
        pub type Cmp0pdnR = crate::BitReader<Cmp0pdn>;
        impl Cmp0pdnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp0pdn {
                match self.bits {
                    false => Cmp0pdn::Off,
                    true => Cmp0pdn::On,
                }
            }
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cmp0pdn::Off
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cmp0pdn::On
            }
        }
        #[doc = "Field `CMP0PDN` writer - Comparator 0 on-off"]
        pub type Cmp0pdnW<'a, REG> = crate::BitWriter<'a, REG, Cmp0pdn>;
        impl<'a, REG> Cmp0pdnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0pdn::Off)
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0pdn::On)
            }
        }
        #[doc = "Comparator 1 on-off\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cmp1pdn {
            #[doc = "0: OFF(Default)"]
            Off = 0,
            #[doc = "1: ON"]
            On = 1,
        }
        impl From<Cmp1pdn> for bool {
            #[inline(always)]
            fn from(variant: Cmp1pdn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP1PDN` reader - Comparator 1 on-off"]
        pub type Cmp1pdnR = crate::BitReader<Cmp1pdn>;
        impl Cmp1pdnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp1pdn {
                match self.bits {
                    false => Cmp1pdn::Off,
                    true => Cmp1pdn::On,
                }
            }
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cmp1pdn::Off
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cmp1pdn::On
            }
        }
        #[doc = "Field `CMP1PDN` writer - Comparator 1 on-off"]
        pub type Cmp1pdnW<'a, REG> = crate::BitWriter<'a, REG, Cmp1pdn>;
        impl<'a, REG> Cmp1pdnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1pdn::Off)
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1pdn::On)
            }
        }
        #[doc = "PLL on-off\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Pllpdn {
            #[doc = "0: OFF(Default)"]
            Off = 0,
            #[doc = "1: ON"]
            On = 1,
        }
        impl From<Pllpdn> for bool {
            #[inline(always)]
            fn from(variant: Pllpdn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PLLPDN` reader - PLL on-off"]
        pub type PllpdnR = crate::BitReader<Pllpdn>;
        impl PllpdnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Pllpdn {
                match self.bits {
                    false => Pllpdn::Off,
                    true => Pllpdn::On,
                }
            }
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Pllpdn::Off
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Pllpdn::On
            }
        }
        #[doc = "Field `PLLPDN` writer - PLL on-off"]
        pub type PllpdnW<'a, REG> = crate::BitWriter<'a, REG, Pllpdn>;
        impl<'a, REG> PllpdnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "OFF(Default)"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Pllpdn::Off)
            }
            #[doc = "ON"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Pllpdn::On)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - OPA0 feedback resistor"]
            #[inline(always)]
            pub fn res_opa0(&self) -> ResOpa0R {
                ResOpa0R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - OPA output enable"]
            #[inline(always)]
            pub fn opaout_en(&self) -> OpaoutEnR {
                OpaoutEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 5 - OPA0 input B enable"]
            #[inline(always)]
            pub fn opa0_b_en(&self) -> Opa0BEnR {
                Opa0BEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - ADC gain select"]
            #[inline(always)]
            pub fn gain_adc(&self) -> GainAdcR {
                GainAdcR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - ADC reference select"]
            #[inline(always)]
            pub fn ref2vdd(&self) -> Ref2vddR {
                Ref2vddR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - ADC on-off"]
            #[inline(always)]
            pub fn adcpdn(&self) -> AdcpdnR {
                AdcpdnR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - OPA on-off"]
            #[inline(always)]
            pub fn opapdn(&self) -> OpapdnR {
                OpapdnR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Bandgap on-off"]
            #[inline(always)]
            pub fn bgppd(&self) -> BgppdR {
                BgppdR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - DAC on-off"]
            #[inline(always)]
            pub fn dacpdn(&self) -> DacpdnR {
                DacpdnR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Temp sensor on-off"]
            #[inline(always)]
            pub fn tmppdn(&self) -> TmppdnR {
                TmppdnR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Comparator 0 on-off"]
            #[inline(always)]
            pub fn cmp0pdn(&self) -> Cmp0pdnR {
                Cmp0pdnR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Comparator 1 on-off"]
            #[inline(always)]
            pub fn cmp1pdn(&self) -> Cmp1pdnR {
                Cmp1pdnR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - PLL on-off"]
            #[inline(always)]
            pub fn pllpdn(&self) -> PllpdnR {
                PllpdnR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - OPA0 feedback resistor"]
            #[inline(always)]
            pub fn res_opa0(&mut self) -> ResOpa0W<AfeReg0Spec> {
                ResOpa0W::new(self, 0)
            }
            #[doc = "Bit 2 - OPA output enable"]
            #[inline(always)]
            pub fn opaout_en(&mut self) -> OpaoutEnW<AfeReg0Spec> {
                OpaoutEnW::new(self, 2)
            }
            #[doc = "Bit 5 - OPA0 input B enable"]
            #[inline(always)]
            pub fn opa0_b_en(&mut self) -> Opa0BEnW<AfeReg0Spec> {
                Opa0BEnW::new(self, 5)
            }
            #[doc = "Bit 6 - ADC gain select"]
            #[inline(always)]
            pub fn gain_adc(&mut self) -> GainAdcW<AfeReg0Spec> {
                GainAdcW::new(self, 6)
            }
            #[doc = "Bit 7 - ADC reference select"]
            #[inline(always)]
            pub fn ref2vdd(&mut self) -> Ref2vddW<AfeReg0Spec> {
                Ref2vddW::new(self, 7)
            }
            #[doc = "Bit 8 - ADC on-off"]
            #[inline(always)]
            pub fn adcpdn(&mut self) -> AdcpdnW<AfeReg0Spec> {
                AdcpdnW::new(self, 8)
            }
            #[doc = "Bit 9 - OPA on-off"]
            #[inline(always)]
            pub fn opapdn(&mut self) -> OpapdnW<AfeReg0Spec> {
                OpapdnW::new(self, 9)
            }
            #[doc = "Bit 10 - Bandgap on-off"]
            #[inline(always)]
            pub fn bgppd(&mut self) -> BgppdW<AfeReg0Spec> {
                BgppdW::new(self, 10)
            }
            #[doc = "Bit 11 - DAC on-off"]
            #[inline(always)]
            pub fn dacpdn(&mut self) -> DacpdnW<AfeReg0Spec> {
                DacpdnW::new(self, 11)
            }
            #[doc = "Bit 12 - Temp sensor on-off"]
            #[inline(always)]
            pub fn tmppdn(&mut self) -> TmppdnW<AfeReg0Spec> {
                TmppdnW::new(self, 12)
            }
            #[doc = "Bit 13 - Comparator 0 on-off"]
            #[inline(always)]
            pub fn cmp0pdn(&mut self) -> Cmp0pdnW<AfeReg0Spec> {
                Cmp0pdnW::new(self, 13)
            }
            #[doc = "Bit 14 - Comparator 1 on-off"]
            #[inline(always)]
            pub fn cmp1pdn(&mut self) -> Cmp1pdnW<AfeReg0Spec> {
                Cmp1pdnW::new(self, 14)
            }
            #[doc = "Bit 15 - PLL on-off"]
            #[inline(always)]
            pub fn pllpdn(&mut self) -> PllpdnW<AfeReg0Spec> {
                PllpdnW::new(self, 15)
            }
        }
        #[doc = "Analog reg0\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AfeReg0Spec;
        impl crate::RegisterSpec for AfeReg0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`afe_reg0::R`](R) reader structure"]
        impl crate::Readable for AfeReg0Spec {}
        #[doc = "`write(|w| ..)` method takes [`afe_reg0::W`](W) writer structure"]
        impl crate::Writable for AfeReg0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AFE_REG0 to value 0"]
        impl crate::Resettable for AfeReg0Spec {}
    }
    #[doc = "AFE_REG1 (rw) register accessor: Analog reg1\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afe_reg1`] module"]
    #[doc(alias = "AFE_REG1")]
    pub type AfeReg1 = crate::Reg<afe_reg1::AfeReg1Spec>;
    #[doc = "Analog reg1"]
    pub mod afe_reg1 {
        #[doc = "Register `AFE_REG1` reader"]
        pub type R = crate::R<AfeReg1Spec>;
        #[doc = "Register `AFE_REG1` writer"]
        pub type W = crate::W<AfeReg1Spec>;
        #[doc = "LDO output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LdooutEn {
            #[doc = "0: LDO output disabled"]
            Disabled = 0,
            #[doc = "1: LDO output to P0\\[0\\]"]
            Enabled = 1,
        }
        impl From<LdooutEn> for bool {
            #[inline(always)]
            fn from(variant: LdooutEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `LDOOUT_EN` reader - LDO output enable"]
        pub type LdooutEnR = crate::BitReader<LdooutEn>;
        impl LdooutEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> LdooutEn {
                match self.bits {
                    false => LdooutEn::Disabled,
                    true => LdooutEn::Enabled,
                }
            }
            #[doc = "LDO output disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LdooutEn::Disabled
            }
            #[doc = "LDO output to P0\\[0\\]"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LdooutEn::Enabled
            }
        }
        #[doc = "Field `LDOOUT_EN` writer - LDO output enable"]
        pub type LdooutEnW<'a, REG> = crate::BitWriter<'a, REG, LdooutEn>;
        impl<'a, REG> LdooutEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "LDO output disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(LdooutEn::Disabled)
            }
            #[doc = "LDO output to P0\\[0\\]"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(LdooutEn::Enabled)
            }
        }
        #[doc = "DAC output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DacoutEn {
            #[doc = "0: DAC output disabled"]
            Disabled = 0,
            #[doc = "1: DAC output to P0\\[0\\]"]
            Enabled = 1,
        }
        impl From<DacoutEn> for bool {
            #[inline(always)]
            fn from(variant: DacoutEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DACOUT_EN` reader - DAC output enable"]
        pub type DacoutEnR = crate::BitReader<DacoutEn>;
        impl DacoutEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DacoutEn {
                match self.bits {
                    false => DacoutEn::Disabled,
                    true => DacoutEn::Enabled,
                }
            }
            #[doc = "DAC output disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DacoutEn::Disabled
            }
            #[doc = "DAC output to P0\\[0\\]"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DacoutEn::Enabled
            }
        }
        #[doc = "Field `DACOUT_EN` writer - DAC output enable"]
        pub type DacoutEnW<'a, REG> = crate::BitWriter<'a, REG, DacoutEn>;
        impl<'a, REG> DacoutEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DAC output disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(DacoutEn::Disabled)
            }
            #[doc = "DAC output to P0\\[0\\]"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(DacoutEn::Enabled)
            }
        }
        #[doc = "Comparator 0 negative input select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Cmp0Seln {
            #[doc = "0: CMP0_IN"]
            Cmp0In = 0,
            #[doc = "1: REF"]
            Ref = 1,
            #[doc = "2: DACOUT"]
            Dacout = 2,
            #[doc = "3: BEMFx_MID"]
            BemfxMid = 3,
        }
        impl From<Cmp0Seln> for u8 {
            #[inline(always)]
            fn from(variant: Cmp0Seln) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Cmp0Seln {
            type Ux = u8;
        }
        impl crate::IsEnum for Cmp0Seln {}
        #[doc = "Field `CMP0_SELN` reader - Comparator 0 negative input select"]
        pub type Cmp0SelnR = crate::FieldReader<Cmp0Seln>;
        impl Cmp0SelnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp0Seln {
                match self.bits {
                    0 => Cmp0Seln::Cmp0In,
                    1 => Cmp0Seln::Ref,
                    2 => Cmp0Seln::Dacout,
                    3 => Cmp0Seln::BemfxMid,
                    _ => unreachable!(),
                }
            }
            #[doc = "CMP0_IN"]
            #[inline(always)]
            pub fn is_cmp0_in(&self) -> bool {
                *self == Cmp0Seln::Cmp0In
            }
            #[doc = "REF"]
            #[inline(always)]
            pub fn is_ref(&self) -> bool {
                *self == Cmp0Seln::Ref
            }
            #[doc = "DACOUT"]
            #[inline(always)]
            pub fn is_dacout(&self) -> bool {
                *self == Cmp0Seln::Dacout
            }
            #[doc = "BEMFx_MID"]
            #[inline(always)]
            pub fn is_bemfx_mid(&self) -> bool {
                *self == Cmp0Seln::BemfxMid
            }
        }
        #[doc = "Field `CMP0_SELN` writer - Comparator 0 negative input select"]
        pub type Cmp0SelnW<'a, REG> = crate::FieldWriter<'a, REG, 2, Cmp0Seln, crate::Safe>;
        impl<'a, REG> Cmp0SelnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "CMP0_IN"]
            #[inline(always)]
            pub fn cmp0_in(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Seln::Cmp0In)
            }
            #[doc = "REF"]
            #[inline(always)]
            pub fn ref_(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Seln::Ref)
            }
            #[doc = "DACOUT"]
            #[inline(always)]
            pub fn dacout(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Seln::Dacout)
            }
            #[doc = "BEMFx_MID"]
            #[inline(always)]
            pub fn bemfx_mid(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Seln::BemfxMid)
            }
        }
        #[doc = "Comparator 1 negative input select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Cmp1Seln {
            #[doc = "0: CMP1_IN"]
            Cmp1In = 0,
            #[doc = "1: REF"]
            Ref = 1,
            #[doc = "2: DACOUT"]
            Dacout = 2,
            #[doc = "3: BEMFx_MID"]
            BemfxMid = 3,
        }
        impl From<Cmp1Seln> for u8 {
            #[inline(always)]
            fn from(variant: Cmp1Seln) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Cmp1Seln {
            type Ux = u8;
        }
        impl crate::IsEnum for Cmp1Seln {}
        #[doc = "Field `CMP1_SELN` reader - Comparator 1 negative input select"]
        pub type Cmp1SelnR = crate::FieldReader<Cmp1Seln>;
        impl Cmp1SelnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp1Seln {
                match self.bits {
                    0 => Cmp1Seln::Cmp1In,
                    1 => Cmp1Seln::Ref,
                    2 => Cmp1Seln::Dacout,
                    3 => Cmp1Seln::BemfxMid,
                    _ => unreachable!(),
                }
            }
            #[doc = "CMP1_IN"]
            #[inline(always)]
            pub fn is_cmp1_in(&self) -> bool {
                *self == Cmp1Seln::Cmp1In
            }
            #[doc = "REF"]
            #[inline(always)]
            pub fn is_ref(&self) -> bool {
                *self == Cmp1Seln::Ref
            }
            #[doc = "DACOUT"]
            #[inline(always)]
            pub fn is_dacout(&self) -> bool {
                *self == Cmp1Seln::Dacout
            }
            #[doc = "BEMFx_MID"]
            #[inline(always)]
            pub fn is_bemfx_mid(&self) -> bool {
                *self == Cmp1Seln::BemfxMid
            }
        }
        #[doc = "Field `CMP1_SELN` writer - Comparator 1 negative input select"]
        pub type Cmp1SelnW<'a, REG> = crate::FieldWriter<'a, REG, 2, Cmp1Seln, crate::Safe>;
        impl<'a, REG> Cmp1SelnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "CMP1_IN"]
            #[inline(always)]
            pub fn cmp1_in(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Seln::Cmp1In)
            }
            #[doc = "REF"]
            #[inline(always)]
            pub fn ref_(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Seln::Ref)
            }
            #[doc = "DACOUT"]
            #[inline(always)]
            pub fn dacout(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Seln::Dacout)
            }
            #[doc = "BEMFx_MID"]
            #[inline(always)]
            pub fn bemfx_mid(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Seln::BemfxMid)
            }
        }
        #[doc = "ADC REF output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RefAdEn {
            #[doc = "0: ADC REF output disabled"]
            Disabled = 0,
            #[doc = "1: ADC REF output to P0\\[0\\]"]
            Enabled = 1,
        }
        impl From<RefAdEn> for bool {
            #[inline(always)]
            fn from(variant: RefAdEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `REF_AD_EN` reader - ADC REF output enable"]
        pub type RefAdEnR = crate::BitReader<RefAdEn>;
        impl RefAdEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RefAdEn {
                match self.bits {
                    false => RefAdEn::Disabled,
                    true => RefAdEn::Enabled,
                }
            }
            #[doc = "ADC REF output disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RefAdEn::Disabled
            }
            #[doc = "ADC REF output to P0\\[0\\]"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RefAdEn::Enabled
            }
        }
        #[doc = "Field `REF_AD_EN` writer - ADC REF output enable"]
        pub type RefAdEnW<'a, REG> = crate::BitWriter<'a, REG, RefAdEn>;
        impl<'a, REG> RefAdEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "ADC REF output disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(RefAdEn::Disabled)
            }
            #[doc = "ADC REF output to P0\\[0\\]"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(RefAdEn::Enabled)
            }
        }
        #[doc = "Comparator hystersis select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CmpHys {
            #[doc = "0: 20mV"]
            _20mV = 0,
            #[doc = "1: 0mV"]
            _0mV = 1,
        }
        impl From<CmpHys> for bool {
            #[inline(always)]
            fn from(variant: CmpHys) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP_HYS` reader - Comparator hystersis select"]
        pub type CmpHysR = crate::BitReader<CmpHys>;
        impl CmpHysR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CmpHys {
                match self.bits {
                    false => CmpHys::_20mV,
                    true => CmpHys::_0mV,
                }
            }
            #[doc = "20mV"]
            #[inline(always)]
            pub fn is_20m_v(&self) -> bool {
                *self == CmpHys::_20mV
            }
            #[doc = "0mV"]
            #[inline(always)]
            pub fn is_0m_v(&self) -> bool {
                *self == CmpHys::_0mV
            }
        }
        #[doc = "Field `CMP_HYS` writer - Comparator hystersis select"]
        pub type CmpHysW<'a, REG> = crate::BitWriter<'a, REG, CmpHys>;
        impl<'a, REG> CmpHysW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "20mV"]
            #[inline(always)]
            pub fn _20m_v(self) -> &'a mut crate::W<REG> {
                self.variant(CmpHys::_20mV)
            }
            #[doc = "0mV"]
            #[inline(always)]
            pub fn _0m_v(self) -> &'a mut crate::W<REG> {
                self.variant(CmpHys::_0mV)
            }
        }
        #[doc = "Comparator 0 positive input select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Cmp0Selp {
            #[doc = "0: CMP0_IP0"]
            Cmp0Ip0 = 0,
            #[doc = "1: OPA0_IP"]
            Opa0Ip = 1,
            #[doc = "2: OPA0_OUT"]
            Opa0Out = 2,
            #[doc = "3: CMP0_IP1"]
            Cmp0Ip1 = 3,
            #[doc = "4: CMP0_IP2"]
            Cmp0Ip2 = 4,
            #[doc = "5: CMP0_IP3"]
            Cmp0Ip3 = 5,
        }
        impl From<Cmp0Selp> for u8 {
            #[inline(always)]
            fn from(variant: Cmp0Selp) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Cmp0Selp {
            type Ux = u8;
        }
        impl crate::IsEnum for Cmp0Selp {}
        #[doc = "Field `CMP0_SELP` reader - Comparator 0 positive input select"]
        pub type Cmp0SelpR = crate::FieldReader<Cmp0Selp>;
        impl Cmp0SelpR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Cmp0Selp> {
                match self.bits {
                    0 => Some(Cmp0Selp::Cmp0Ip0),
                    1 => Some(Cmp0Selp::Opa0Ip),
                    2 => Some(Cmp0Selp::Opa0Out),
                    3 => Some(Cmp0Selp::Cmp0Ip1),
                    4 => Some(Cmp0Selp::Cmp0Ip2),
                    5 => Some(Cmp0Selp::Cmp0Ip3),
                    _ => None,
                }
            }
            #[doc = "CMP0_IP0"]
            #[inline(always)]
            pub fn is_cmp0_ip0(&self) -> bool {
                *self == Cmp0Selp::Cmp0Ip0
            }
            #[doc = "OPA0_IP"]
            #[inline(always)]
            pub fn is_opa0_ip(&self) -> bool {
                *self == Cmp0Selp::Opa0Ip
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Cmp0Selp::Opa0Out
            }
            #[doc = "CMP0_IP1"]
            #[inline(always)]
            pub fn is_cmp0_ip1(&self) -> bool {
                *self == Cmp0Selp::Cmp0Ip1
            }
            #[doc = "CMP0_IP2"]
            #[inline(always)]
            pub fn is_cmp0_ip2(&self) -> bool {
                *self == Cmp0Selp::Cmp0Ip2
            }
            #[doc = "CMP0_IP3"]
            #[inline(always)]
            pub fn is_cmp0_ip3(&self) -> bool {
                *self == Cmp0Selp::Cmp0Ip3
            }
        }
        #[doc = "Field `CMP0_SELP` writer - Comparator 0 positive input select"]
        pub type Cmp0SelpW<'a, REG> = crate::FieldWriter<'a, REG, 3, Cmp0Selp>;
        impl<'a, REG> Cmp0SelpW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "CMP0_IP0"]
            #[inline(always)]
            pub fn cmp0_ip0(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Selp::Cmp0Ip0)
            }
            #[doc = "OPA0_IP"]
            #[inline(always)]
            pub fn opa0_ip(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Selp::Opa0Ip)
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Selp::Opa0Out)
            }
            #[doc = "CMP0_IP1"]
            #[inline(always)]
            pub fn cmp0_ip1(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Selp::Cmp0Ip1)
            }
            #[doc = "CMP0_IP2"]
            #[inline(always)]
            pub fn cmp0_ip2(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Selp::Cmp0Ip2)
            }
            #[doc = "CMP0_IP3"]
            #[inline(always)]
            pub fn cmp0_ip3(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Selp::Cmp0Ip3)
            }
        }
        #[doc = "Comparator fast mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CmpFt {
            #[doc = "0: 200ns"]
            Normal = 0,
            #[doc = "1: less than 30ns"]
            Fast = 1,
        }
        impl From<CmpFt> for bool {
            #[inline(always)]
            fn from(variant: CmpFt) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP_FT` reader - Comparator fast mode"]
        pub type CmpFtR = crate::BitReader<CmpFt>;
        impl CmpFtR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CmpFt {
                match self.bits {
                    false => CmpFt::Normal,
                    true => CmpFt::Fast,
                }
            }
            #[doc = "200ns"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == CmpFt::Normal
            }
            #[doc = "less than 30ns"]
            #[inline(always)]
            pub fn is_fast(&self) -> bool {
                *self == CmpFt::Fast
            }
        }
        #[doc = "Field `CMP_FT` writer - Comparator fast mode"]
        pub type CmpFtW<'a, REG> = crate::BitWriter<'a, REG, CmpFt>;
        impl<'a, REG> CmpFtW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "200ns"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut crate::W<REG> {
                self.variant(CmpFt::Normal)
            }
            #[doc = "less than 30ns"]
            #[inline(always)]
            pub fn fast(self) -> &'a mut crate::W<REG> {
                self.variant(CmpFt::Fast)
            }
        }
        #[doc = "Comparator 1 positive input select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Cmp1Selp {
            #[doc = "0: CMP1_IP0"]
            Cmp1Ip0 = 0,
            #[doc = "1: OPA0_IP"]
            Opa0Ip = 1,
            #[doc = "2: OPA0_OUT"]
            Opa0Out = 2,
            #[doc = "3: CMP1_IP1"]
            Cmp1Ip1 = 3,
            #[doc = "4: CMP1_IP2"]
            Cmp1Ip2 = 4,
            #[doc = "5: CMP1_IP3"]
            Cmp1Ip3 = 5,
        }
        impl From<Cmp1Selp> for u8 {
            #[inline(always)]
            fn from(variant: Cmp1Selp) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Cmp1Selp {
            type Ux = u8;
        }
        impl crate::IsEnum for Cmp1Selp {}
        #[doc = "Field `CMP1_SELP` reader - Comparator 1 positive input select"]
        pub type Cmp1SelpR = crate::FieldReader<Cmp1Selp>;
        impl Cmp1SelpR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Cmp1Selp> {
                match self.bits {
                    0 => Some(Cmp1Selp::Cmp1Ip0),
                    1 => Some(Cmp1Selp::Opa0Ip),
                    2 => Some(Cmp1Selp::Opa0Out),
                    3 => Some(Cmp1Selp::Cmp1Ip1),
                    4 => Some(Cmp1Selp::Cmp1Ip2),
                    5 => Some(Cmp1Selp::Cmp1Ip3),
                    _ => None,
                }
            }
            #[doc = "CMP1_IP0"]
            #[inline(always)]
            pub fn is_cmp1_ip0(&self) -> bool {
                *self == Cmp1Selp::Cmp1Ip0
            }
            #[doc = "OPA0_IP"]
            #[inline(always)]
            pub fn is_opa0_ip(&self) -> bool {
                *self == Cmp1Selp::Opa0Ip
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Cmp1Selp::Opa0Out
            }
            #[doc = "CMP1_IP1"]
            #[inline(always)]
            pub fn is_cmp1_ip1(&self) -> bool {
                *self == Cmp1Selp::Cmp1Ip1
            }
            #[doc = "CMP1_IP2"]
            #[inline(always)]
            pub fn is_cmp1_ip2(&self) -> bool {
                *self == Cmp1Selp::Cmp1Ip2
            }
            #[doc = "CMP1_IP3"]
            #[inline(always)]
            pub fn is_cmp1_ip3(&self) -> bool {
                *self == Cmp1Selp::Cmp1Ip3
            }
        }
        #[doc = "Field `CMP1_SELP` writer - Comparator 1 positive input select"]
        pub type Cmp1SelpW<'a, REG> = crate::FieldWriter<'a, REG, 3, Cmp1Selp>;
        impl<'a, REG> Cmp1SelpW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "CMP1_IP0"]
            #[inline(always)]
            pub fn cmp1_ip0(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Selp::Cmp1Ip0)
            }
            #[doc = "OPA0_IP"]
            #[inline(always)]
            pub fn opa0_ip(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Selp::Opa0Ip)
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Selp::Opa0Out)
            }
            #[doc = "CMP1_IP1"]
            #[inline(always)]
            pub fn cmp1_ip1(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Selp::Cmp1Ip1)
            }
            #[doc = "CMP1_IP2"]
            #[inline(always)]
            pub fn cmp1_ip2(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Selp::Cmp1Ip2)
            }
            #[doc = "CMP1_IP3"]
            #[inline(always)]
            pub fn cmp1_ip3(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Selp::Cmp1Ip3)
            }
        }
        #[doc = "ADC Clock edge select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AclkPhase {
            #[doc = "0: Posedge"]
            P = 0,
            #[doc = "1: Negedge"]
            N = 1,
        }
        impl From<AclkPhase> for bool {
            #[inline(always)]
            fn from(variant: AclkPhase) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ACLK_PHASE` reader - ADC Clock edge select"]
        pub type AclkPhaseR = crate::BitReader<AclkPhase>;
        impl AclkPhaseR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> AclkPhase {
                match self.bits {
                    false => AclkPhase::P,
                    true => AclkPhase::N,
                }
            }
            #[doc = "Posedge"]
            #[inline(always)]
            pub fn is_p(&self) -> bool {
                *self == AclkPhase::P
            }
            #[doc = "Negedge"]
            #[inline(always)]
            pub fn is_n(&self) -> bool {
                *self == AclkPhase::N
            }
        }
        #[doc = "Field `ACLK_PHASE` writer - ADC Clock edge select"]
        pub type AclkPhaseW<'a, REG> = crate::BitWriter<'a, REG, AclkPhase>;
        impl<'a, REG> AclkPhaseW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Posedge"]
            #[inline(always)]
            pub fn p(self) -> &'a mut crate::W<REG> {
                self.variant(AclkPhase::P)
            }
            #[doc = "Negedge"]
            #[inline(always)]
            pub fn n(self) -> &'a mut crate::W<REG> {
                self.variant(AclkPhase::N)
            }
        }
        impl R {
            #[doc = "Bit 0 - LDO output enable"]
            #[inline(always)]
            pub fn ldoout_en(&self) -> LdooutEnR {
                LdooutEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - DAC output enable"]
            #[inline(always)]
            pub fn dacout_en(&self) -> DacoutEnR {
                DacoutEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:3 - Comparator 0 negative input select"]
            #[inline(always)]
            pub fn cmp0_seln(&self) -> Cmp0SelnR {
                Cmp0SelnR::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Comparator 1 negative input select"]
            #[inline(always)]
            pub fn cmp1_seln(&self) -> Cmp1SelnR {
                Cmp1SelnR::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bit 6 - ADC REF output enable"]
            #[inline(always)]
            pub fn ref_ad_en(&self) -> RefAdEnR {
                RefAdEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Comparator hystersis select"]
            #[inline(always)]
            pub fn cmp_hys(&self) -> CmpHysR {
                CmpHysR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bits 8:10 - Comparator 0 positive input select"]
            #[inline(always)]
            pub fn cmp0_selp(&self) -> Cmp0SelpR {
                Cmp0SelpR::new(((self.bits >> 8) & 7) as u8)
            }
            #[doc = "Bit 11 - Comparator fast mode"]
            #[inline(always)]
            pub fn cmp_ft(&self) -> CmpFtR {
                CmpFtR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bits 12:14 - Comparator 1 positive input select"]
            #[inline(always)]
            pub fn cmp1_selp(&self) -> Cmp1SelpR {
                Cmp1SelpR::new(((self.bits >> 12) & 7) as u8)
            }
            #[doc = "Bit 15 - ADC Clock edge select"]
            #[inline(always)]
            pub fn aclk_phase(&self) -> AclkPhaseR {
                AclkPhaseR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - LDO output enable"]
            #[inline(always)]
            pub fn ldoout_en(&mut self) -> LdooutEnW<AfeReg1Spec> {
                LdooutEnW::new(self, 0)
            }
            #[doc = "Bit 1 - DAC output enable"]
            #[inline(always)]
            pub fn dacout_en(&mut self) -> DacoutEnW<AfeReg1Spec> {
                DacoutEnW::new(self, 1)
            }
            #[doc = "Bits 2:3 - Comparator 0 negative input select"]
            #[inline(always)]
            pub fn cmp0_seln(&mut self) -> Cmp0SelnW<AfeReg1Spec> {
                Cmp0SelnW::new(self, 2)
            }
            #[doc = "Bits 4:5 - Comparator 1 negative input select"]
            #[inline(always)]
            pub fn cmp1_seln(&mut self) -> Cmp1SelnW<AfeReg1Spec> {
                Cmp1SelnW::new(self, 4)
            }
            #[doc = "Bit 6 - ADC REF output enable"]
            #[inline(always)]
            pub fn ref_ad_en(&mut self) -> RefAdEnW<AfeReg1Spec> {
                RefAdEnW::new(self, 6)
            }
            #[doc = "Bit 7 - Comparator hystersis select"]
            #[inline(always)]
            pub fn cmp_hys(&mut self) -> CmpHysW<AfeReg1Spec> {
                CmpHysW::new(self, 7)
            }
            #[doc = "Bits 8:10 - Comparator 0 positive input select"]
            #[inline(always)]
            pub fn cmp0_selp(&mut self) -> Cmp0SelpW<AfeReg1Spec> {
                Cmp0SelpW::new(self, 8)
            }
            #[doc = "Bit 11 - Comparator fast mode"]
            #[inline(always)]
            pub fn cmp_ft(&mut self) -> CmpFtW<AfeReg1Spec> {
                CmpFtW::new(self, 11)
            }
            #[doc = "Bits 12:14 - Comparator 1 positive input select"]
            #[inline(always)]
            pub fn cmp1_selp(&mut self) -> Cmp1SelpW<AfeReg1Spec> {
                Cmp1SelpW::new(self, 12)
            }
            #[doc = "Bit 15 - ADC Clock edge select"]
            #[inline(always)]
            pub fn aclk_phase(&mut self) -> AclkPhaseW<AfeReg1Spec> {
                AclkPhaseW::new(self, 15)
            }
        }
        #[doc = "Analog reg1\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AfeReg1Spec;
        impl crate::RegisterSpec for AfeReg1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`afe_reg1::R`](R) reader structure"]
        impl crate::Readable for AfeReg1Spec {}
        #[doc = "`write(|w| ..)` method takes [`afe_reg1::W`](W) writer structure"]
        impl crate::Writable for AfeReg1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AFE_REG1 to value 0"]
        impl crate::Resettable for AfeReg1Spec {}
    }
    #[doc = "AFE_REG2 (rw) register accessor: Analog reg2\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afe_reg2`] module"]
    #[doc(alias = "AFE_REG2")]
    pub type AfeReg2 = crate::Reg<afe_reg2::AfeReg2Spec>;
    #[doc = "Analog reg2"]
    pub mod afe_reg2 {
        #[doc = "Register `AFE_REG2` reader"]
        pub type R = crate::R<AfeReg2Spec>;
        #[doc = "Register `AFE_REG2` writer"]
        pub type W = crate::W<AfeReg2Spec>;
        #[doc = "ADC sample time\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SampTime {
            #[doc = "0: 4 ADC clocks"]
            _4aclk = 0,
            #[doc = "1: 5 ADC clocks"]
            _5aclk = 1,
            #[doc = "2: 6 ADC clocks"]
            _6aclk = 2,
            #[doc = "3: 7 ADC clocks"]
            _7aclk = 3,
            #[doc = "4: 8 ADC clocks"]
            _8aclk = 4,
            #[doc = "5: 9 ADC clocks"]
            _9aclk = 5,
            #[doc = "6: 10 ADC clocks"]
            _10aclk = 6,
            #[doc = "7: 11 ADC clocks"]
            _11aclk = 7,
            #[doc = "8: 12 ADC clocks"]
            _12aclk = 8,
            #[doc = "9: 13 ADC clocks"]
            _13aclk = 9,
            #[doc = "10: 14 ADC clocks"]
            _14aclk = 10,
            #[doc = "11: 15 ADC clocks"]
            _15aclk = 11,
            #[doc = "12: 16 ADC clocks"]
            _16aclk = 12,
            #[doc = "13: 17 ADC clocks"]
            _17aclk = 13,
            #[doc = "14: 18 ADC clocks"]
            _18aclk = 14,
            #[doc = "15: 19 ADC clocks"]
            _19aclk = 15,
            #[doc = "16: 20 ADC clocks"]
            _20aclk = 16,
            #[doc = "17: 21 ADC clocks"]
            _21aclk = 17,
            #[doc = "18: 22 ADC clocks"]
            _22aclk = 18,
            #[doc = "19: 23 ADC clocks"]
            _23aclk = 19,
            #[doc = "20: 24 ADC clocks"]
            _24aclk = 20,
            #[doc = "21: 25 ADC clocks"]
            _25aclk = 21,
            #[doc = "22: 26 ADC clocks"]
            _26aclk = 22,
            #[doc = "23: 27 ADC clocks"]
            _27aclk = 23,
            #[doc = "24: 28 ADC clocks"]
            _28aclk = 24,
            #[doc = "25: 29 ADC clocks"]
            _29aclk = 25,
            #[doc = "26: 30 ADC clocks"]
            _30aclk = 26,
            #[doc = "27: 31 ADC clocks"]
            _31aclk = 27,
            #[doc = "28: 32 ADC clocks"]
            _32aclk = 28,
            #[doc = "29: 33 ADC clocks"]
            _33aclk = 29,
            #[doc = "30: 34 ADC clocks"]
            _34aclk = 30,
            #[doc = "31: 35 ADC clocks"]
            _35aclk = 31,
        }
        impl From<SampTime> for u8 {
            #[inline(always)]
            fn from(variant: SampTime) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for SampTime {
            type Ux = u8;
        }
        impl crate::IsEnum for SampTime {}
        #[doc = "Field `SAMP_TIME` reader - ADC sample time"]
        pub type SampTimeR = crate::FieldReader<SampTime>;
        impl SampTimeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SampTime {
                match self.bits {
                    0 => SampTime::_4aclk,
                    1 => SampTime::_5aclk,
                    2 => SampTime::_6aclk,
                    3 => SampTime::_7aclk,
                    4 => SampTime::_8aclk,
                    5 => SampTime::_9aclk,
                    6 => SampTime::_10aclk,
                    7 => SampTime::_11aclk,
                    8 => SampTime::_12aclk,
                    9 => SampTime::_13aclk,
                    10 => SampTime::_14aclk,
                    11 => SampTime::_15aclk,
                    12 => SampTime::_16aclk,
                    13 => SampTime::_17aclk,
                    14 => SampTime::_18aclk,
                    15 => SampTime::_19aclk,
                    16 => SampTime::_20aclk,
                    17 => SampTime::_21aclk,
                    18 => SampTime::_22aclk,
                    19 => SampTime::_23aclk,
                    20 => SampTime::_24aclk,
                    21 => SampTime::_25aclk,
                    22 => SampTime::_26aclk,
                    23 => SampTime::_27aclk,
                    24 => SampTime::_28aclk,
                    25 => SampTime::_29aclk,
                    26 => SampTime::_30aclk,
                    27 => SampTime::_31aclk,
                    28 => SampTime::_32aclk,
                    29 => SampTime::_33aclk,
                    30 => SampTime::_34aclk,
                    31 => SampTime::_35aclk,
                    _ => unreachable!(),
                }
            }
            #[doc = "4 ADC clocks"]
            #[inline(always)]
            pub fn is_4aclk(&self) -> bool {
                *self == SampTime::_4aclk
            }
            #[doc = "5 ADC clocks"]
            #[inline(always)]
            pub fn is_5aclk(&self) -> bool {
                *self == SampTime::_5aclk
            }
            #[doc = "6 ADC clocks"]
            #[inline(always)]
            pub fn is_6aclk(&self) -> bool {
                *self == SampTime::_6aclk
            }
            #[doc = "7 ADC clocks"]
            #[inline(always)]
            pub fn is_7aclk(&self) -> bool {
                *self == SampTime::_7aclk
            }
            #[doc = "8 ADC clocks"]
            #[inline(always)]
            pub fn is_8aclk(&self) -> bool {
                *self == SampTime::_8aclk
            }
            #[doc = "9 ADC clocks"]
            #[inline(always)]
            pub fn is_9aclk(&self) -> bool {
                *self == SampTime::_9aclk
            }
            #[doc = "10 ADC clocks"]
            #[inline(always)]
            pub fn is_10aclk(&self) -> bool {
                *self == SampTime::_10aclk
            }
            #[doc = "11 ADC clocks"]
            #[inline(always)]
            pub fn is_11aclk(&self) -> bool {
                *self == SampTime::_11aclk
            }
            #[doc = "12 ADC clocks"]
            #[inline(always)]
            pub fn is_12aclk(&self) -> bool {
                *self == SampTime::_12aclk
            }
            #[doc = "13 ADC clocks"]
            #[inline(always)]
            pub fn is_13aclk(&self) -> bool {
                *self == SampTime::_13aclk
            }
            #[doc = "14 ADC clocks"]
            #[inline(always)]
            pub fn is_14aclk(&self) -> bool {
                *self == SampTime::_14aclk
            }
            #[doc = "15 ADC clocks"]
            #[inline(always)]
            pub fn is_15aclk(&self) -> bool {
                *self == SampTime::_15aclk
            }
            #[doc = "16 ADC clocks"]
            #[inline(always)]
            pub fn is_16aclk(&self) -> bool {
                *self == SampTime::_16aclk
            }
            #[doc = "17 ADC clocks"]
            #[inline(always)]
            pub fn is_17aclk(&self) -> bool {
                *self == SampTime::_17aclk
            }
            #[doc = "18 ADC clocks"]
            #[inline(always)]
            pub fn is_18aclk(&self) -> bool {
                *self == SampTime::_18aclk
            }
            #[doc = "19 ADC clocks"]
            #[inline(always)]
            pub fn is_19aclk(&self) -> bool {
                *self == SampTime::_19aclk
            }
            #[doc = "20 ADC clocks"]
            #[inline(always)]
            pub fn is_20aclk(&self) -> bool {
                *self == SampTime::_20aclk
            }
            #[doc = "21 ADC clocks"]
            #[inline(always)]
            pub fn is_21aclk(&self) -> bool {
                *self == SampTime::_21aclk
            }
            #[doc = "22 ADC clocks"]
            #[inline(always)]
            pub fn is_22aclk(&self) -> bool {
                *self == SampTime::_22aclk
            }
            #[doc = "23 ADC clocks"]
            #[inline(always)]
            pub fn is_23aclk(&self) -> bool {
                *self == SampTime::_23aclk
            }
            #[doc = "24 ADC clocks"]
            #[inline(always)]
            pub fn is_24aclk(&self) -> bool {
                *self == SampTime::_24aclk
            }
            #[doc = "25 ADC clocks"]
            #[inline(always)]
            pub fn is_25aclk(&self) -> bool {
                *self == SampTime::_25aclk
            }
            #[doc = "26 ADC clocks"]
            #[inline(always)]
            pub fn is_26aclk(&self) -> bool {
                *self == SampTime::_26aclk
            }
            #[doc = "27 ADC clocks"]
            #[inline(always)]
            pub fn is_27aclk(&self) -> bool {
                *self == SampTime::_27aclk
            }
            #[doc = "28 ADC clocks"]
            #[inline(always)]
            pub fn is_28aclk(&self) -> bool {
                *self == SampTime::_28aclk
            }
            #[doc = "29 ADC clocks"]
            #[inline(always)]
            pub fn is_29aclk(&self) -> bool {
                *self == SampTime::_29aclk
            }
            #[doc = "30 ADC clocks"]
            #[inline(always)]
            pub fn is_30aclk(&self) -> bool {
                *self == SampTime::_30aclk
            }
            #[doc = "31 ADC clocks"]
            #[inline(always)]
            pub fn is_31aclk(&self) -> bool {
                *self == SampTime::_31aclk
            }
            #[doc = "32 ADC clocks"]
            #[inline(always)]
            pub fn is_32aclk(&self) -> bool {
                *self == SampTime::_32aclk
            }
            #[doc = "33 ADC clocks"]
            #[inline(always)]
            pub fn is_33aclk(&self) -> bool {
                *self == SampTime::_33aclk
            }
            #[doc = "34 ADC clocks"]
            #[inline(always)]
            pub fn is_34aclk(&self) -> bool {
                *self == SampTime::_34aclk
            }
            #[doc = "35 ADC clocks"]
            #[inline(always)]
            pub fn is_35aclk(&self) -> bool {
                *self == SampTime::_35aclk
            }
        }
        #[doc = "Field `SAMP_TIME` writer - ADC sample time"]
        pub type SampTimeW<'a, REG> = crate::FieldWriter<'a, REG, 5, SampTime, crate::Safe>;
        impl<'a, REG> SampTimeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "4 ADC clocks"]
            #[inline(always)]
            pub fn _4aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_4aclk)
            }
            #[doc = "5 ADC clocks"]
            #[inline(always)]
            pub fn _5aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_5aclk)
            }
            #[doc = "6 ADC clocks"]
            #[inline(always)]
            pub fn _6aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_6aclk)
            }
            #[doc = "7 ADC clocks"]
            #[inline(always)]
            pub fn _7aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_7aclk)
            }
            #[doc = "8 ADC clocks"]
            #[inline(always)]
            pub fn _8aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_8aclk)
            }
            #[doc = "9 ADC clocks"]
            #[inline(always)]
            pub fn _9aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_9aclk)
            }
            #[doc = "10 ADC clocks"]
            #[inline(always)]
            pub fn _10aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_10aclk)
            }
            #[doc = "11 ADC clocks"]
            #[inline(always)]
            pub fn _11aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_11aclk)
            }
            #[doc = "12 ADC clocks"]
            #[inline(always)]
            pub fn _12aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_12aclk)
            }
            #[doc = "13 ADC clocks"]
            #[inline(always)]
            pub fn _13aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_13aclk)
            }
            #[doc = "14 ADC clocks"]
            #[inline(always)]
            pub fn _14aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_14aclk)
            }
            #[doc = "15 ADC clocks"]
            #[inline(always)]
            pub fn _15aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_15aclk)
            }
            #[doc = "16 ADC clocks"]
            #[inline(always)]
            pub fn _16aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_16aclk)
            }
            #[doc = "17 ADC clocks"]
            #[inline(always)]
            pub fn _17aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_17aclk)
            }
            #[doc = "18 ADC clocks"]
            #[inline(always)]
            pub fn _18aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_18aclk)
            }
            #[doc = "19 ADC clocks"]
            #[inline(always)]
            pub fn _19aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_19aclk)
            }
            #[doc = "20 ADC clocks"]
            #[inline(always)]
            pub fn _20aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_20aclk)
            }
            #[doc = "21 ADC clocks"]
            #[inline(always)]
            pub fn _21aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_21aclk)
            }
            #[doc = "22 ADC clocks"]
            #[inline(always)]
            pub fn _22aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_22aclk)
            }
            #[doc = "23 ADC clocks"]
            #[inline(always)]
            pub fn _23aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_23aclk)
            }
            #[doc = "24 ADC clocks"]
            #[inline(always)]
            pub fn _24aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_24aclk)
            }
            #[doc = "25 ADC clocks"]
            #[inline(always)]
            pub fn _25aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_25aclk)
            }
            #[doc = "26 ADC clocks"]
            #[inline(always)]
            pub fn _26aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_26aclk)
            }
            #[doc = "27 ADC clocks"]
            #[inline(always)]
            pub fn _27aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_27aclk)
            }
            #[doc = "28 ADC clocks"]
            #[inline(always)]
            pub fn _28aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_28aclk)
            }
            #[doc = "29 ADC clocks"]
            #[inline(always)]
            pub fn _29aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_29aclk)
            }
            #[doc = "30 ADC clocks"]
            #[inline(always)]
            pub fn _30aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_30aclk)
            }
            #[doc = "31 ADC clocks"]
            #[inline(always)]
            pub fn _31aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_31aclk)
            }
            #[doc = "32 ADC clocks"]
            #[inline(always)]
            pub fn _32aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_32aclk)
            }
            #[doc = "33 ADC clocks"]
            #[inline(always)]
            pub fn _33aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_33aclk)
            }
            #[doc = "34 ADC clocks"]
            #[inline(always)]
            pub fn _34aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_34aclk)
            }
            #[doc = "35 ADC clocks"]
            #[inline(always)]
            pub fn _35aclk(self) -> &'a mut crate::W<REG> {
                self.variant(SampTime::_35aclk)
            }
        }
        #[doc = "Delay ADC Clock\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CkdyEnn {
            #[doc = "0: Enable ADC clock delay"]
            Enabled = 0,
            #[doc = "1: Disable ADC clock delay"]
            Disabled = 1,
        }
        impl From<CkdyEnn> for bool {
            #[inline(always)]
            fn from(variant: CkdyEnn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CKDY_ENN` reader - Delay ADC Clock"]
        pub type CkdyEnnR = crate::BitReader<CkdyEnn>;
        impl CkdyEnnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CkdyEnn {
                match self.bits {
                    false => CkdyEnn::Enabled,
                    true => CkdyEnn::Disabled,
                }
            }
            #[doc = "Enable ADC clock delay"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CkdyEnn::Enabled
            }
            #[doc = "Disable ADC clock delay"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CkdyEnn::Disabled
            }
        }
        #[doc = "Field `CKDY_ENN` writer - Delay ADC Clock"]
        pub type CkdyEnnW<'a, REG> = crate::BitWriter<'a, REG, CkdyEnn>;
        impl<'a, REG> CkdyEnnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Enable ADC clock delay"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(CkdyEnn::Enabled)
            }
            #[doc = "Disable ADC clock delay"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(CkdyEnn::Disabled)
            }
        }
        impl R {
            #[doc = "Bits 8:12 - ADC sample time"]
            #[inline(always)]
            pub fn samp_time(&self) -> SampTimeR {
                SampTimeR::new(((self.bits >> 8) & 0x1f) as u8)
            }
            #[doc = "Bit 15 - Delay ADC Clock"]
            #[inline(always)]
            pub fn ckdy_enn(&self) -> CkdyEnnR {
                CkdyEnnR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 8:12 - ADC sample time"]
            #[inline(always)]
            pub fn samp_time(&mut self) -> SampTimeW<AfeReg2Spec> {
                SampTimeW::new(self, 8)
            }
            #[doc = "Bit 15 - Delay ADC Clock"]
            #[inline(always)]
            pub fn ckdy_enn(&mut self) -> CkdyEnnW<AfeReg2Spec> {
                CkdyEnnW::new(self, 15)
            }
        }
        #[doc = "Analog reg2\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AfeReg2Spec;
        impl crate::RegisterSpec for AfeReg2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`afe_reg2::R`](R) reader structure"]
        impl crate::Readable for AfeReg2Spec {}
        #[doc = "`write(|w| ..)` method takes [`afe_reg2::W`](W) writer structure"]
        impl crate::Writable for AfeReg2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AFE_REG2 to value 0"]
        impl crate::Resettable for AfeReg2Spec {}
    }
    #[doc = "AFE_REG3 (rw) register accessor: Analog reg3\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afe_reg3`] module"]
    #[doc(alias = "AFE_REG3")]
    pub type AfeReg3 = crate::Reg<afe_reg3::AfeReg3Spec>;
    #[doc = "Analog reg3"]
    pub mod afe_reg3 {
        #[doc = "Register `AFE_REG3` reader"]
        pub type R = crate::R<AfeReg3Spec>;
        #[doc = "Register `AFE_REG3` writer"]
        pub type W = crate::W<AfeReg3Spec>;
        #[doc = "Bandgap output voltage tune\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Reftrim {
            #[doc = "0: 0mV"]
            _0mV = 0,
            #[doc = "1: 6.6mV"]
            _6p6mV = 1,
            #[doc = "2: 13.2mV"]
            _13p2mV = 2,
            #[doc = "3: 19.8mV"]
            _19p8mV = 3,
            #[doc = "4: -26.4mV"]
            N26p4mV = 4,
            #[doc = "5: -19.8mV"]
            N19p8mV = 5,
            #[doc = "6: -13.2mV"]
            N13p2mV = 6,
            #[doc = "7: -6.6mV"]
            N6p6mV = 7,
        }
        impl From<Reftrim> for u8 {
            #[inline(always)]
            fn from(variant: Reftrim) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Reftrim {
            type Ux = u8;
        }
        impl crate::IsEnum for Reftrim {}
        #[doc = "Field `REFTRIM` reader - Bandgap output voltage tune"]
        pub type ReftrimR = crate::FieldReader<Reftrim>;
        impl ReftrimR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Reftrim {
                match self.bits {
                    0 => Reftrim::_0mV,
                    1 => Reftrim::_6p6mV,
                    2 => Reftrim::_13p2mV,
                    3 => Reftrim::_19p8mV,
                    4 => Reftrim::N26p4mV,
                    5 => Reftrim::N19p8mV,
                    6 => Reftrim::N13p2mV,
                    7 => Reftrim::N6p6mV,
                    _ => unreachable!(),
                }
            }
            #[doc = "0mV"]
            #[inline(always)]
            pub fn is_0m_v(&self) -> bool {
                *self == Reftrim::_0mV
            }
            #[doc = "6.6mV"]
            #[inline(always)]
            pub fn is_6p6m_v(&self) -> bool {
                *self == Reftrim::_6p6mV
            }
            #[doc = "13.2mV"]
            #[inline(always)]
            pub fn is_13p2m_v(&self) -> bool {
                *self == Reftrim::_13p2mV
            }
            #[doc = "19.8mV"]
            #[inline(always)]
            pub fn is_19p8m_v(&self) -> bool {
                *self == Reftrim::_19p8mV
            }
            #[doc = "-26.4mV"]
            #[inline(always)]
            pub fn is_n26p4m_v(&self) -> bool {
                *self == Reftrim::N26p4mV
            }
            #[doc = "-19.8mV"]
            #[inline(always)]
            pub fn is_n19p8m_v(&self) -> bool {
                *self == Reftrim::N19p8mV
            }
            #[doc = "-13.2mV"]
            #[inline(always)]
            pub fn is_n13p2m_v(&self) -> bool {
                *self == Reftrim::N13p2mV
            }
            #[doc = "-6.6mV"]
            #[inline(always)]
            pub fn is_n6p6m_v(&self) -> bool {
                *self == Reftrim::N6p6mV
            }
        }
        #[doc = "Field `REFTRIM` writer - Bandgap output voltage tune"]
        pub type ReftrimW<'a, REG> = crate::FieldWriter<'a, REG, 3, Reftrim, crate::Safe>;
        impl<'a, REG> ReftrimW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "0mV"]
            #[inline(always)]
            pub fn _0m_v(self) -> &'a mut crate::W<REG> {
                self.variant(Reftrim::_0mV)
            }
            #[doc = "6.6mV"]
            #[inline(always)]
            pub fn _6p6m_v(self) -> &'a mut crate::W<REG> {
                self.variant(Reftrim::_6p6mV)
            }
            #[doc = "13.2mV"]
            #[inline(always)]
            pub fn _13p2m_v(self) -> &'a mut crate::W<REG> {
                self.variant(Reftrim::_13p2mV)
            }
            #[doc = "19.8mV"]
            #[inline(always)]
            pub fn _19p8m_v(self) -> &'a mut crate::W<REG> {
                self.variant(Reftrim::_19p8mV)
            }
            #[doc = "-26.4mV"]
            #[inline(always)]
            pub fn n26p4m_v(self) -> &'a mut crate::W<REG> {
                self.variant(Reftrim::N26p4mV)
            }
            #[doc = "-19.8mV"]
            #[inline(always)]
            pub fn n19p8m_v(self) -> &'a mut crate::W<REG> {
                self.variant(Reftrim::N19p8mV)
            }
            #[doc = "-13.2mV"]
            #[inline(always)]
            pub fn n13p2m_v(self) -> &'a mut crate::W<REG> {
                self.variant(Reftrim::N13p2mV)
            }
            #[doc = "-6.6mV"]
            #[inline(always)]
            pub fn n6p6m_v(self) -> &'a mut crate::W<REG> {
                self.variant(Reftrim::N6p6mV)
            }
        }
        impl R {
            #[doc = "Bits 4:6 - Bandgap output voltage tune"]
            #[inline(always)]
            pub fn reftrim(&self) -> ReftrimR {
                ReftrimR::new(((self.bits >> 4) & 7) as u8)
            }
        }
        impl W {
            #[doc = "Bits 4:6 - Bandgap output voltage tune"]
            #[inline(always)]
            pub fn reftrim(&mut self) -> ReftrimW<AfeReg3Spec> {
                ReftrimW::new(self, 4)
            }
        }
        #[doc = "Analog reg3\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AfeReg3Spec;
        impl crate::RegisterSpec for AfeReg3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`afe_reg3::R`](R) reader structure"]
        impl crate::Readable for AfeReg3Spec {}
        #[doc = "`write(|w| ..)` method takes [`afe_reg3::W`](W) writer structure"]
        impl crate::Writable for AfeReg3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AFE_REG3 to value 0"]
        impl crate::Resettable for AfeReg3Spec {}
    }
    #[doc = "AFE_REG4 (rw) register accessor: Analog reg4\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afe_reg4`] module"]
    #[doc(alias = "AFE_REG4")]
    pub type AfeReg4 = crate::Reg<afe_reg4::AfeReg4Spec>;
    #[doc = "Analog reg4"]
    pub mod afe_reg4 {
        #[doc = "Register `AFE_REG4` reader"]
        pub type R = crate::R<AfeReg4Spec>;
        #[doc = "Register `AFE_REG4` writer"]
        pub type W = crate::W<AfeReg4Spec>;
        #[doc = "LDO15 tune\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ldo15trim {
            #[doc = "0: 0.12"]
            _0p12 = 0,
            #[doc = "1: 0.08"]
            _0p08 = 1,
            #[doc = "2: 0.04"]
            _0p04 = 2,
            #[doc = "3: 0"]
            _0 = 3,
            #[doc = "4: -0.04"]
            N0p04 = 4,
            #[doc = "5: -0.08"]
            N0p08 = 5,
            #[doc = "6: 0.12"]
            _0p12_1 = 6,
            #[doc = "7: 0.12"]
            _0p12_2 = 7,
        }
        impl From<Ldo15trim> for u8 {
            #[inline(always)]
            fn from(variant: Ldo15trim) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ldo15trim {
            type Ux = u8;
        }
        impl crate::IsEnum for Ldo15trim {}
        #[doc = "Field `LDO15TRIM` reader - LDO15 tune"]
        pub type Ldo15trimR = crate::FieldReader<Ldo15trim>;
        impl Ldo15trimR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ldo15trim {
                match self.bits {
                    0 => Ldo15trim::_0p12,
                    1 => Ldo15trim::_0p08,
                    2 => Ldo15trim::_0p04,
                    3 => Ldo15trim::_0,
                    4 => Ldo15trim::N0p04,
                    5 => Ldo15trim::N0p08,
                    6 => Ldo15trim::_0p12_1,
                    7 => Ldo15trim::_0p12_2,
                    _ => unreachable!(),
                }
            }
            #[doc = "0.12"]
            #[inline(always)]
            pub fn is_0p12(&self) -> bool {
                *self == Ldo15trim::_0p12
            }
            #[doc = "0.08"]
            #[inline(always)]
            pub fn is_0p08(&self) -> bool {
                *self == Ldo15trim::_0p08
            }
            #[doc = "0.04"]
            #[inline(always)]
            pub fn is_0p04(&self) -> bool {
                *self == Ldo15trim::_0p04
            }
            #[doc = "0"]
            #[inline(always)]
            pub fn is_0(&self) -> bool {
                *self == Ldo15trim::_0
            }
            #[doc = "-0.04"]
            #[inline(always)]
            pub fn is_n0p04(&self) -> bool {
                *self == Ldo15trim::N0p04
            }
            #[doc = "-0.08"]
            #[inline(always)]
            pub fn is_n0p08(&self) -> bool {
                *self == Ldo15trim::N0p08
            }
            #[doc = "0.12"]
            #[inline(always)]
            pub fn is_0p12_1(&self) -> bool {
                *self == Ldo15trim::_0p12_1
            }
            #[doc = "0.12"]
            #[inline(always)]
            pub fn is_0p12_2(&self) -> bool {
                *self == Ldo15trim::_0p12_2
            }
        }
        #[doc = "Field `LDO15TRIM` writer - LDO15 tune"]
        pub type Ldo15trimW<'a, REG> = crate::FieldWriter<'a, REG, 3, Ldo15trim, crate::Safe>;
        impl<'a, REG> Ldo15trimW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "0.12"]
            #[inline(always)]
            pub fn _0p12(self) -> &'a mut crate::W<REG> {
                self.variant(Ldo15trim::_0p12)
            }
            #[doc = "0.08"]
            #[inline(always)]
            pub fn _0p08(self) -> &'a mut crate::W<REG> {
                self.variant(Ldo15trim::_0p08)
            }
            #[doc = "0.04"]
            #[inline(always)]
            pub fn _0p04(self) -> &'a mut crate::W<REG> {
                self.variant(Ldo15trim::_0p04)
            }
            #[doc = "0"]
            #[inline(always)]
            pub fn _0(self) -> &'a mut crate::W<REG> {
                self.variant(Ldo15trim::_0)
            }
            #[doc = "-0.04"]
            #[inline(always)]
            pub fn n0p04(self) -> &'a mut crate::W<REG> {
                self.variant(Ldo15trim::N0p04)
            }
            #[doc = "-0.08"]
            #[inline(always)]
            pub fn n0p08(self) -> &'a mut crate::W<REG> {
                self.variant(Ldo15trim::N0p08)
            }
            #[doc = "0.12"]
            #[inline(always)]
            pub fn _0p12_1(self) -> &'a mut crate::W<REG> {
                self.variant(Ldo15trim::_0p12_1)
            }
            #[doc = "0.12"]
            #[inline(always)]
            pub fn _0p12_2(self) -> &'a mut crate::W<REG> {
                self.variant(Ldo15trim::_0p12_2)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - LDO15 tune"]
            #[inline(always)]
            pub fn ldo15trim(&self) -> Ldo15trimR {
                Ldo15trimR::new((self.bits & 7) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - LDO15 tune"]
            #[inline(always)]
            pub fn ldo15trim(&mut self) -> Ldo15trimW<AfeReg4Spec> {
                Ldo15trimW::new(self, 0)
            }
        }
        #[doc = "Analog reg4\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AfeReg4Spec;
        impl crate::RegisterSpec for AfeReg4Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`afe_reg4::R`](R) reader structure"]
        impl crate::Readable for AfeReg4Spec {}
        #[doc = "`write(|w| ..)` method takes [`afe_reg4::W`](W) writer structure"]
        impl crate::Writable for AfeReg4Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AFE_REG4 to value 0"]
        impl crate::Resettable for AfeReg4Spec {}
    }
    #[doc = "AFE_REG5 (rw) register accessor: Analog reg5\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afe_reg5`] module"]
    #[doc(alias = "AFE_REG5")]
    pub type AfeReg5 = crate::Reg<afe_reg5::AfeReg5Spec>;
    #[doc = "Analog reg5"]
    pub mod afe_reg5 {
        #[doc = "Register `AFE_REG5` reader"]
        pub type R = crate::R<AfeReg5Spec>;
        #[doc = "Register `AFE_REG5` writer"]
        pub type W = crate::W<AfeReg5Spec>;
        #[doc = "32kHz RC clock tune\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Rcltrim {
            #[doc = "0: 0"]
            _0 = 0,
            #[doc = "1: 0.12"]
            _0p12 = 1,
            #[doc = "2: 0.27"]
            _0p27 = 2,
            #[doc = "3: 0.46"]
            _0p46 = 3,
            #[doc = "4: -0.13"]
            N0p13 = 4,
            #[doc = "8: -0.23"]
            N0p23 = 8,
            #[doc = "12: -0.32"]
            N0p32 = 12,
        }
        impl From<Rcltrim> for u8 {
            #[inline(always)]
            fn from(variant: Rcltrim) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Rcltrim {
            type Ux = u8;
        }
        impl crate::IsEnum for Rcltrim {}
        #[doc = "Field `RCLTRIM` reader - 32kHz RC clock tune"]
        pub type RcltrimR = crate::FieldReader<Rcltrim>;
        impl RcltrimR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Rcltrim> {
                match self.bits {
                    0 => Some(Rcltrim::_0),
                    1 => Some(Rcltrim::_0p12),
                    2 => Some(Rcltrim::_0p27),
                    3 => Some(Rcltrim::_0p46),
                    4 => Some(Rcltrim::N0p13),
                    8 => Some(Rcltrim::N0p23),
                    12 => Some(Rcltrim::N0p32),
                    _ => None,
                }
            }
            #[doc = "0"]
            #[inline(always)]
            pub fn is_0(&self) -> bool {
                *self == Rcltrim::_0
            }
            #[doc = "0.12"]
            #[inline(always)]
            pub fn is_0p12(&self) -> bool {
                *self == Rcltrim::_0p12
            }
            #[doc = "0.27"]
            #[inline(always)]
            pub fn is_0p27(&self) -> bool {
                *self == Rcltrim::_0p27
            }
            #[doc = "0.46"]
            #[inline(always)]
            pub fn is_0p46(&self) -> bool {
                *self == Rcltrim::_0p46
            }
            #[doc = "-0.13"]
            #[inline(always)]
            pub fn is_n0p13(&self) -> bool {
                *self == Rcltrim::N0p13
            }
            #[doc = "-0.23"]
            #[inline(always)]
            pub fn is_n0p23(&self) -> bool {
                *self == Rcltrim::N0p23
            }
            #[doc = "-0.32"]
            #[inline(always)]
            pub fn is_n0p32(&self) -> bool {
                *self == Rcltrim::N0p32
            }
        }
        #[doc = "Field `RCLTRIM` writer - 32kHz RC clock tune"]
        pub type RcltrimW<'a, REG> = crate::FieldWriter<'a, REG, 4, Rcltrim>;
        impl<'a, REG> RcltrimW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "0"]
            #[inline(always)]
            pub fn _0(self) -> &'a mut crate::W<REG> {
                self.variant(Rcltrim::_0)
            }
            #[doc = "0.12"]
            #[inline(always)]
            pub fn _0p12(self) -> &'a mut crate::W<REG> {
                self.variant(Rcltrim::_0p12)
            }
            #[doc = "0.27"]
            #[inline(always)]
            pub fn _0p27(self) -> &'a mut crate::W<REG> {
                self.variant(Rcltrim::_0p27)
            }
            #[doc = "0.46"]
            #[inline(always)]
            pub fn _0p46(self) -> &'a mut crate::W<REG> {
                self.variant(Rcltrim::_0p46)
            }
            #[doc = "-0.13"]
            #[inline(always)]
            pub fn n0p13(self) -> &'a mut crate::W<REG> {
                self.variant(Rcltrim::N0p13)
            }
            #[doc = "-0.23"]
            #[inline(always)]
            pub fn n0p23(self) -> &'a mut crate::W<REG> {
                self.variant(Rcltrim::N0p23)
            }
            #[doc = "-0.32"]
            #[inline(always)]
            pub fn n0p32(self) -> &'a mut crate::W<REG> {
                self.variant(Rcltrim::N0p32)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - 32kHz RC clock tune"]
            #[inline(always)]
            pub fn rcltrim(&self) -> RcltrimR {
                RcltrimR::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - 32kHz RC clock tune"]
            #[inline(always)]
            pub fn rcltrim(&mut self) -> RcltrimW<AfeReg5Spec> {
                RcltrimW::new(self, 0)
            }
        }
        #[doc = "Analog reg5\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AfeReg5Spec;
        impl crate::RegisterSpec for AfeReg5Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`afe_reg5::R`](R) reader structure"]
        impl crate::Readable for AfeReg5Spec {}
        #[doc = "`write(|w| ..)` method takes [`afe_reg5::W`](W) writer structure"]
        impl crate::Writable for AfeReg5Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AFE_REG5 to value 0"]
        impl crate::Resettable for AfeReg5Spec {}
    }
    #[doc = "AFE_REG6 (rw) register accessor: Analog reg6\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afe_reg6`] module"]
    #[doc(alias = "AFE_REG6")]
    pub type AfeReg6 = crate::Reg<afe_reg6::AfeReg6Spec>;
    #[doc = "Analog reg6"]
    pub mod afe_reg6 {
        #[doc = "Register `AFE_REG6` reader"]
        pub type R = crate::R<AfeReg6Spec>;
        #[doc = "Register `AFE_REG6` writer"]
        pub type W = crate::W<AfeReg6Spec>;
        #[doc = "4MHz RC clock tune\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Rchtrim {
            #[doc = "0: 0"]
            _0p0000 = 0,
            #[doc = "1: 0.0125"]
            _0p0125 = 1,
            #[doc = "2: 0.025"]
            _0p0250 = 2,
            #[doc = "3: 0.0375"]
            _0p0375 = 3,
            #[doc = "4: 0.05"]
            _0p0500 = 4,
            #[doc = "5: 0.0625"]
            _0p0625 = 5,
            #[doc = "6: 0.075"]
            _0p0750 = 6,
            #[doc = "7: 0.0875"]
            _0p0875 = 7,
            #[doc = "8: 0.1"]
            _0p1000 = 8,
            #[doc = "9: 0.1125"]
            _0p1125 = 9,
            #[doc = "10: 0.125"]
            _0p1250 = 10,
            #[doc = "11: 0.1375"]
            _0p1375 = 11,
            #[doc = "12: 0.15"]
            _0p1500 = 12,
            #[doc = "13: 0.1625"]
            _0p1625 = 13,
            #[doc = "14: 0.175"]
            _0p1750 = 14,
            #[doc = "15: 0.1875"]
            _0p1875 = 15,
            #[doc = "16: 0.2"]
            _0p2000 = 16,
            #[doc = "17: 0.2125"]
            _0p2125 = 17,
            #[doc = "18: 0.225"]
            _0p2250 = 18,
            #[doc = "19: 0.2375"]
            _0p2375 = 19,
            #[doc = "20: 0.25"]
            _0p2500 = 20,
            #[doc = "21: 0.2625"]
            _0p2625 = 21,
            #[doc = "22: 0.275"]
            _0p2750 = 22,
            #[doc = "23: 0.2875"]
            _0p2875 = 23,
            #[doc = "24: 0.3"]
            _0p3000 = 24,
            #[doc = "25: 0.3125"]
            _0p3125 = 25,
            #[doc = "26: 0.325"]
            _0p3250 = 26,
            #[doc = "27: 0.3375"]
            _0p3375 = 27,
            #[doc = "28: 0.35"]
            _0p3500 = 28,
            #[doc = "29: 0.3625"]
            _0p3625 = 29,
            #[doc = "30: 0.375"]
            _0p3750 = 30,
            #[doc = "31: 0.3875"]
            _0p3875 = 31,
            #[doc = "32: -0.4"]
            N0p4000 = 32,
            #[doc = "33: -0.3875"]
            N0p3875 = 33,
            #[doc = "34: -0.375"]
            N0p3750 = 34,
            #[doc = "35: -0.3625"]
            N0p3625 = 35,
            #[doc = "36: -0.35"]
            N0p3500 = 36,
            #[doc = "37: -0.3375"]
            N0p3375 = 37,
            #[doc = "38: -0.325"]
            N0p3250 = 38,
            #[doc = "39: -0.3125"]
            N0p3125 = 39,
            #[doc = "40: -0.3"]
            N0p3000 = 40,
            #[doc = "41: -0.2875"]
            N0p2875 = 41,
            #[doc = "42: -0.275"]
            N0p2750 = 42,
            #[doc = "43: -0.2625"]
            N0p2625 = 43,
            #[doc = "44: -0.25"]
            N0p2500 = 44,
            #[doc = "45: -0.2375"]
            N0p2375 = 45,
            #[doc = "46: -0.225"]
            N0p2250 = 46,
            #[doc = "47: -0.2125"]
            N0p2125 = 47,
            #[doc = "48: -0.2"]
            N0p2000 = 48,
            #[doc = "49: -0.1875"]
            N0p1875 = 49,
            #[doc = "50: -0.175"]
            N0p1750 = 50,
            #[doc = "51: -0.1625"]
            N0p1625 = 51,
            #[doc = "52: -0.15"]
            N0p1500 = 52,
            #[doc = "53: -0.1375"]
            N0p1375 = 53,
            #[doc = "54: -0.125"]
            N0p1250 = 54,
            #[doc = "55: -0.1125"]
            N0p1125 = 55,
            #[doc = "56: -0.1"]
            N0p1000 = 56,
            #[doc = "57: -0.0875"]
            N0p875 = 57,
            #[doc = "58: -0.075"]
            N0p750 = 58,
            #[doc = "59: -0.0625"]
            N0p625 = 59,
            #[doc = "60: -0.05"]
            N0p500 = 60,
            #[doc = "61: -0.0375"]
            N0p375 = 61,
            #[doc = "62: -0.025"]
            N0p250 = 62,
            #[doc = "63: -0.0125"]
            N0p125 = 63,
        }
        impl From<Rchtrim> for u8 {
            #[inline(always)]
            fn from(variant: Rchtrim) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Rchtrim {
            type Ux = u8;
        }
        impl crate::IsEnum for Rchtrim {}
        #[doc = "Field `RCHTRIM` reader - 4MHz RC clock tune"]
        pub type RchtrimR = crate::FieldReader<Rchtrim>;
        impl RchtrimR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Rchtrim {
                match self.bits {
                    0 => Rchtrim::_0p0000,
                    1 => Rchtrim::_0p0125,
                    2 => Rchtrim::_0p0250,
                    3 => Rchtrim::_0p0375,
                    4 => Rchtrim::_0p0500,
                    5 => Rchtrim::_0p0625,
                    6 => Rchtrim::_0p0750,
                    7 => Rchtrim::_0p0875,
                    8 => Rchtrim::_0p1000,
                    9 => Rchtrim::_0p1125,
                    10 => Rchtrim::_0p1250,
                    11 => Rchtrim::_0p1375,
                    12 => Rchtrim::_0p1500,
                    13 => Rchtrim::_0p1625,
                    14 => Rchtrim::_0p1750,
                    15 => Rchtrim::_0p1875,
                    16 => Rchtrim::_0p2000,
                    17 => Rchtrim::_0p2125,
                    18 => Rchtrim::_0p2250,
                    19 => Rchtrim::_0p2375,
                    20 => Rchtrim::_0p2500,
                    21 => Rchtrim::_0p2625,
                    22 => Rchtrim::_0p2750,
                    23 => Rchtrim::_0p2875,
                    24 => Rchtrim::_0p3000,
                    25 => Rchtrim::_0p3125,
                    26 => Rchtrim::_0p3250,
                    27 => Rchtrim::_0p3375,
                    28 => Rchtrim::_0p3500,
                    29 => Rchtrim::_0p3625,
                    30 => Rchtrim::_0p3750,
                    31 => Rchtrim::_0p3875,
                    32 => Rchtrim::N0p4000,
                    33 => Rchtrim::N0p3875,
                    34 => Rchtrim::N0p3750,
                    35 => Rchtrim::N0p3625,
                    36 => Rchtrim::N0p3500,
                    37 => Rchtrim::N0p3375,
                    38 => Rchtrim::N0p3250,
                    39 => Rchtrim::N0p3125,
                    40 => Rchtrim::N0p3000,
                    41 => Rchtrim::N0p2875,
                    42 => Rchtrim::N0p2750,
                    43 => Rchtrim::N0p2625,
                    44 => Rchtrim::N0p2500,
                    45 => Rchtrim::N0p2375,
                    46 => Rchtrim::N0p2250,
                    47 => Rchtrim::N0p2125,
                    48 => Rchtrim::N0p2000,
                    49 => Rchtrim::N0p1875,
                    50 => Rchtrim::N0p1750,
                    51 => Rchtrim::N0p1625,
                    52 => Rchtrim::N0p1500,
                    53 => Rchtrim::N0p1375,
                    54 => Rchtrim::N0p1250,
                    55 => Rchtrim::N0p1125,
                    56 => Rchtrim::N0p1000,
                    57 => Rchtrim::N0p875,
                    58 => Rchtrim::N0p750,
                    59 => Rchtrim::N0p625,
                    60 => Rchtrim::N0p500,
                    61 => Rchtrim::N0p375,
                    62 => Rchtrim::N0p250,
                    63 => Rchtrim::N0p125,
                    _ => unreachable!(),
                }
            }
            #[doc = "0"]
            #[inline(always)]
            pub fn is_0p0000(&self) -> bool {
                *self == Rchtrim::_0p0000
            }
            #[doc = "0.0125"]
            #[inline(always)]
            pub fn is_0p0125(&self) -> bool {
                *self == Rchtrim::_0p0125
            }
            #[doc = "0.025"]
            #[inline(always)]
            pub fn is_0p0250(&self) -> bool {
                *self == Rchtrim::_0p0250
            }
            #[doc = "0.0375"]
            #[inline(always)]
            pub fn is_0p0375(&self) -> bool {
                *self == Rchtrim::_0p0375
            }
            #[doc = "0.05"]
            #[inline(always)]
            pub fn is_0p0500(&self) -> bool {
                *self == Rchtrim::_0p0500
            }
            #[doc = "0.0625"]
            #[inline(always)]
            pub fn is_0p0625(&self) -> bool {
                *self == Rchtrim::_0p0625
            }
            #[doc = "0.075"]
            #[inline(always)]
            pub fn is_0p0750(&self) -> bool {
                *self == Rchtrim::_0p0750
            }
            #[doc = "0.0875"]
            #[inline(always)]
            pub fn is_0p0875(&self) -> bool {
                *self == Rchtrim::_0p0875
            }
            #[doc = "0.1"]
            #[inline(always)]
            pub fn is_0p1000(&self) -> bool {
                *self == Rchtrim::_0p1000
            }
            #[doc = "0.1125"]
            #[inline(always)]
            pub fn is_0p1125(&self) -> bool {
                *self == Rchtrim::_0p1125
            }
            #[doc = "0.125"]
            #[inline(always)]
            pub fn is_0p1250(&self) -> bool {
                *self == Rchtrim::_0p1250
            }
            #[doc = "0.1375"]
            #[inline(always)]
            pub fn is_0p1375(&self) -> bool {
                *self == Rchtrim::_0p1375
            }
            #[doc = "0.15"]
            #[inline(always)]
            pub fn is_0p1500(&self) -> bool {
                *self == Rchtrim::_0p1500
            }
            #[doc = "0.1625"]
            #[inline(always)]
            pub fn is_0p1625(&self) -> bool {
                *self == Rchtrim::_0p1625
            }
            #[doc = "0.175"]
            #[inline(always)]
            pub fn is_0p1750(&self) -> bool {
                *self == Rchtrim::_0p1750
            }
            #[doc = "0.1875"]
            #[inline(always)]
            pub fn is_0p1875(&self) -> bool {
                *self == Rchtrim::_0p1875
            }
            #[doc = "0.2"]
            #[inline(always)]
            pub fn is_0p2000(&self) -> bool {
                *self == Rchtrim::_0p2000
            }
            #[doc = "0.2125"]
            #[inline(always)]
            pub fn is_0p2125(&self) -> bool {
                *self == Rchtrim::_0p2125
            }
            #[doc = "0.225"]
            #[inline(always)]
            pub fn is_0p2250(&self) -> bool {
                *self == Rchtrim::_0p2250
            }
            #[doc = "0.2375"]
            #[inline(always)]
            pub fn is_0p2375(&self) -> bool {
                *self == Rchtrim::_0p2375
            }
            #[doc = "0.25"]
            #[inline(always)]
            pub fn is_0p2500(&self) -> bool {
                *self == Rchtrim::_0p2500
            }
            #[doc = "0.2625"]
            #[inline(always)]
            pub fn is_0p2625(&self) -> bool {
                *self == Rchtrim::_0p2625
            }
            #[doc = "0.275"]
            #[inline(always)]
            pub fn is_0p2750(&self) -> bool {
                *self == Rchtrim::_0p2750
            }
            #[doc = "0.2875"]
            #[inline(always)]
            pub fn is_0p2875(&self) -> bool {
                *self == Rchtrim::_0p2875
            }
            #[doc = "0.3"]
            #[inline(always)]
            pub fn is_0p3000(&self) -> bool {
                *self == Rchtrim::_0p3000
            }
            #[doc = "0.3125"]
            #[inline(always)]
            pub fn is_0p3125(&self) -> bool {
                *self == Rchtrim::_0p3125
            }
            #[doc = "0.325"]
            #[inline(always)]
            pub fn is_0p3250(&self) -> bool {
                *self == Rchtrim::_0p3250
            }
            #[doc = "0.3375"]
            #[inline(always)]
            pub fn is_0p3375(&self) -> bool {
                *self == Rchtrim::_0p3375
            }
            #[doc = "0.35"]
            #[inline(always)]
            pub fn is_0p3500(&self) -> bool {
                *self == Rchtrim::_0p3500
            }
            #[doc = "0.3625"]
            #[inline(always)]
            pub fn is_0p3625(&self) -> bool {
                *self == Rchtrim::_0p3625
            }
            #[doc = "0.375"]
            #[inline(always)]
            pub fn is_0p3750(&self) -> bool {
                *self == Rchtrim::_0p3750
            }
            #[doc = "0.3875"]
            #[inline(always)]
            pub fn is_0p3875(&self) -> bool {
                *self == Rchtrim::_0p3875
            }
            #[doc = "-0.4"]
            #[inline(always)]
            pub fn is_n0p4000(&self) -> bool {
                *self == Rchtrim::N0p4000
            }
            #[doc = "-0.3875"]
            #[inline(always)]
            pub fn is_n0p3875(&self) -> bool {
                *self == Rchtrim::N0p3875
            }
            #[doc = "-0.375"]
            #[inline(always)]
            pub fn is_n0p3750(&self) -> bool {
                *self == Rchtrim::N0p3750
            }
            #[doc = "-0.3625"]
            #[inline(always)]
            pub fn is_n0p3625(&self) -> bool {
                *self == Rchtrim::N0p3625
            }
            #[doc = "-0.35"]
            #[inline(always)]
            pub fn is_n0p3500(&self) -> bool {
                *self == Rchtrim::N0p3500
            }
            #[doc = "-0.3375"]
            #[inline(always)]
            pub fn is_n0p3375(&self) -> bool {
                *self == Rchtrim::N0p3375
            }
            #[doc = "-0.325"]
            #[inline(always)]
            pub fn is_n0p3250(&self) -> bool {
                *self == Rchtrim::N0p3250
            }
            #[doc = "-0.3125"]
            #[inline(always)]
            pub fn is_n0p3125(&self) -> bool {
                *self == Rchtrim::N0p3125
            }
            #[doc = "-0.3"]
            #[inline(always)]
            pub fn is_n0p3000(&self) -> bool {
                *self == Rchtrim::N0p3000
            }
            #[doc = "-0.2875"]
            #[inline(always)]
            pub fn is_n0p2875(&self) -> bool {
                *self == Rchtrim::N0p2875
            }
            #[doc = "-0.275"]
            #[inline(always)]
            pub fn is_n0p2750(&self) -> bool {
                *self == Rchtrim::N0p2750
            }
            #[doc = "-0.2625"]
            #[inline(always)]
            pub fn is_n0p2625(&self) -> bool {
                *self == Rchtrim::N0p2625
            }
            #[doc = "-0.25"]
            #[inline(always)]
            pub fn is_n0p2500(&self) -> bool {
                *self == Rchtrim::N0p2500
            }
            #[doc = "-0.2375"]
            #[inline(always)]
            pub fn is_n0p2375(&self) -> bool {
                *self == Rchtrim::N0p2375
            }
            #[doc = "-0.225"]
            #[inline(always)]
            pub fn is_n0p2250(&self) -> bool {
                *self == Rchtrim::N0p2250
            }
            #[doc = "-0.2125"]
            #[inline(always)]
            pub fn is_n0p2125(&self) -> bool {
                *self == Rchtrim::N0p2125
            }
            #[doc = "-0.2"]
            #[inline(always)]
            pub fn is_n0p2000(&self) -> bool {
                *self == Rchtrim::N0p2000
            }
            #[doc = "-0.1875"]
            #[inline(always)]
            pub fn is_n0p1875(&self) -> bool {
                *self == Rchtrim::N0p1875
            }
            #[doc = "-0.175"]
            #[inline(always)]
            pub fn is_n0p1750(&self) -> bool {
                *self == Rchtrim::N0p1750
            }
            #[doc = "-0.1625"]
            #[inline(always)]
            pub fn is_n0p1625(&self) -> bool {
                *self == Rchtrim::N0p1625
            }
            #[doc = "-0.15"]
            #[inline(always)]
            pub fn is_n0p1500(&self) -> bool {
                *self == Rchtrim::N0p1500
            }
            #[doc = "-0.1375"]
            #[inline(always)]
            pub fn is_n0p1375(&self) -> bool {
                *self == Rchtrim::N0p1375
            }
            #[doc = "-0.125"]
            #[inline(always)]
            pub fn is_n0p1250(&self) -> bool {
                *self == Rchtrim::N0p1250
            }
            #[doc = "-0.1125"]
            #[inline(always)]
            pub fn is_n0p1125(&self) -> bool {
                *self == Rchtrim::N0p1125
            }
            #[doc = "-0.1"]
            #[inline(always)]
            pub fn is_n0p1000(&self) -> bool {
                *self == Rchtrim::N0p1000
            }
            #[doc = "-0.0875"]
            #[inline(always)]
            pub fn is_n0p875(&self) -> bool {
                *self == Rchtrim::N0p875
            }
            #[doc = "-0.075"]
            #[inline(always)]
            pub fn is_n0p750(&self) -> bool {
                *self == Rchtrim::N0p750
            }
            #[doc = "-0.0625"]
            #[inline(always)]
            pub fn is_n0p625(&self) -> bool {
                *self == Rchtrim::N0p625
            }
            #[doc = "-0.05"]
            #[inline(always)]
            pub fn is_n0p500(&self) -> bool {
                *self == Rchtrim::N0p500
            }
            #[doc = "-0.0375"]
            #[inline(always)]
            pub fn is_n0p375(&self) -> bool {
                *self == Rchtrim::N0p375
            }
            #[doc = "-0.025"]
            #[inline(always)]
            pub fn is_n0p250(&self) -> bool {
                *self == Rchtrim::N0p250
            }
            #[doc = "-0.0125"]
            #[inline(always)]
            pub fn is_n0p125(&self) -> bool {
                *self == Rchtrim::N0p125
            }
        }
        #[doc = "Field `RCHTRIM` writer - 4MHz RC clock tune"]
        pub type RchtrimW<'a, REG> = crate::FieldWriter<'a, REG, 6, Rchtrim, crate::Safe>;
        impl<'a, REG> RchtrimW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "0"]
            #[inline(always)]
            pub fn _0p0000(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p0000)
            }
            #[doc = "0.0125"]
            #[inline(always)]
            pub fn _0p0125(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p0125)
            }
            #[doc = "0.025"]
            #[inline(always)]
            pub fn _0p0250(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p0250)
            }
            #[doc = "0.0375"]
            #[inline(always)]
            pub fn _0p0375(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p0375)
            }
            #[doc = "0.05"]
            #[inline(always)]
            pub fn _0p0500(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p0500)
            }
            #[doc = "0.0625"]
            #[inline(always)]
            pub fn _0p0625(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p0625)
            }
            #[doc = "0.075"]
            #[inline(always)]
            pub fn _0p0750(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p0750)
            }
            #[doc = "0.0875"]
            #[inline(always)]
            pub fn _0p0875(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p0875)
            }
            #[doc = "0.1"]
            #[inline(always)]
            pub fn _0p1000(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p1000)
            }
            #[doc = "0.1125"]
            #[inline(always)]
            pub fn _0p1125(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p1125)
            }
            #[doc = "0.125"]
            #[inline(always)]
            pub fn _0p1250(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p1250)
            }
            #[doc = "0.1375"]
            #[inline(always)]
            pub fn _0p1375(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p1375)
            }
            #[doc = "0.15"]
            #[inline(always)]
            pub fn _0p1500(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p1500)
            }
            #[doc = "0.1625"]
            #[inline(always)]
            pub fn _0p1625(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p1625)
            }
            #[doc = "0.175"]
            #[inline(always)]
            pub fn _0p1750(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p1750)
            }
            #[doc = "0.1875"]
            #[inline(always)]
            pub fn _0p1875(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p1875)
            }
            #[doc = "0.2"]
            #[inline(always)]
            pub fn _0p2000(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p2000)
            }
            #[doc = "0.2125"]
            #[inline(always)]
            pub fn _0p2125(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p2125)
            }
            #[doc = "0.225"]
            #[inline(always)]
            pub fn _0p2250(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p2250)
            }
            #[doc = "0.2375"]
            #[inline(always)]
            pub fn _0p2375(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p2375)
            }
            #[doc = "0.25"]
            #[inline(always)]
            pub fn _0p2500(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p2500)
            }
            #[doc = "0.2625"]
            #[inline(always)]
            pub fn _0p2625(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p2625)
            }
            #[doc = "0.275"]
            #[inline(always)]
            pub fn _0p2750(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p2750)
            }
            #[doc = "0.2875"]
            #[inline(always)]
            pub fn _0p2875(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p2875)
            }
            #[doc = "0.3"]
            #[inline(always)]
            pub fn _0p3000(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p3000)
            }
            #[doc = "0.3125"]
            #[inline(always)]
            pub fn _0p3125(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p3125)
            }
            #[doc = "0.325"]
            #[inline(always)]
            pub fn _0p3250(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p3250)
            }
            #[doc = "0.3375"]
            #[inline(always)]
            pub fn _0p3375(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p3375)
            }
            #[doc = "0.35"]
            #[inline(always)]
            pub fn _0p3500(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p3500)
            }
            #[doc = "0.3625"]
            #[inline(always)]
            pub fn _0p3625(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p3625)
            }
            #[doc = "0.375"]
            #[inline(always)]
            pub fn _0p3750(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p3750)
            }
            #[doc = "0.3875"]
            #[inline(always)]
            pub fn _0p3875(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::_0p3875)
            }
            #[doc = "-0.4"]
            #[inline(always)]
            pub fn n0p4000(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p4000)
            }
            #[doc = "-0.3875"]
            #[inline(always)]
            pub fn n0p3875(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p3875)
            }
            #[doc = "-0.375"]
            #[inline(always)]
            pub fn n0p3750(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p3750)
            }
            #[doc = "-0.3625"]
            #[inline(always)]
            pub fn n0p3625(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p3625)
            }
            #[doc = "-0.35"]
            #[inline(always)]
            pub fn n0p3500(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p3500)
            }
            #[doc = "-0.3375"]
            #[inline(always)]
            pub fn n0p3375(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p3375)
            }
            #[doc = "-0.325"]
            #[inline(always)]
            pub fn n0p3250(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p3250)
            }
            #[doc = "-0.3125"]
            #[inline(always)]
            pub fn n0p3125(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p3125)
            }
            #[doc = "-0.3"]
            #[inline(always)]
            pub fn n0p3000(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p3000)
            }
            #[doc = "-0.2875"]
            #[inline(always)]
            pub fn n0p2875(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p2875)
            }
            #[doc = "-0.275"]
            #[inline(always)]
            pub fn n0p2750(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p2750)
            }
            #[doc = "-0.2625"]
            #[inline(always)]
            pub fn n0p2625(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p2625)
            }
            #[doc = "-0.25"]
            #[inline(always)]
            pub fn n0p2500(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p2500)
            }
            #[doc = "-0.2375"]
            #[inline(always)]
            pub fn n0p2375(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p2375)
            }
            #[doc = "-0.225"]
            #[inline(always)]
            pub fn n0p2250(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p2250)
            }
            #[doc = "-0.2125"]
            #[inline(always)]
            pub fn n0p2125(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p2125)
            }
            #[doc = "-0.2"]
            #[inline(always)]
            pub fn n0p2000(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p2000)
            }
            #[doc = "-0.1875"]
            #[inline(always)]
            pub fn n0p1875(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p1875)
            }
            #[doc = "-0.175"]
            #[inline(always)]
            pub fn n0p1750(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p1750)
            }
            #[doc = "-0.1625"]
            #[inline(always)]
            pub fn n0p1625(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p1625)
            }
            #[doc = "-0.15"]
            #[inline(always)]
            pub fn n0p1500(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p1500)
            }
            #[doc = "-0.1375"]
            #[inline(always)]
            pub fn n0p1375(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p1375)
            }
            #[doc = "-0.125"]
            #[inline(always)]
            pub fn n0p1250(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p1250)
            }
            #[doc = "-0.1125"]
            #[inline(always)]
            pub fn n0p1125(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p1125)
            }
            #[doc = "-0.1"]
            #[inline(always)]
            pub fn n0p1000(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p1000)
            }
            #[doc = "-0.0875"]
            #[inline(always)]
            pub fn n0p875(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p875)
            }
            #[doc = "-0.075"]
            #[inline(always)]
            pub fn n0p750(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p750)
            }
            #[doc = "-0.0625"]
            #[inline(always)]
            pub fn n0p625(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p625)
            }
            #[doc = "-0.05"]
            #[inline(always)]
            pub fn n0p500(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p500)
            }
            #[doc = "-0.0375"]
            #[inline(always)]
            pub fn n0p375(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p375)
            }
            #[doc = "-0.025"]
            #[inline(always)]
            pub fn n0p250(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p250)
            }
            #[doc = "-0.0125"]
            #[inline(always)]
            pub fn n0p125(self) -> &'a mut crate::W<REG> {
                self.variant(Rchtrim::N0p125)
            }
        }
        impl R {
            #[doc = "Bits 0:5 - 4MHz RC clock tune"]
            #[inline(always)]
            pub fn rchtrim(&self) -> RchtrimR {
                RchtrimR::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:5 - 4MHz RC clock tune"]
            #[inline(always)]
            pub fn rchtrim(&mut self) -> RchtrimW<AfeReg6Spec> {
                RchtrimW::new(self, 0)
            }
        }
        #[doc = "Analog reg6\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_reg6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_reg6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AfeReg6Spec;
        impl crate::RegisterSpec for AfeReg6Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`afe_reg6::R`](R) reader structure"]
        impl crate::Readable for AfeReg6Spec {}
        #[doc = "`write(|w| ..)` method takes [`afe_reg6::W`](W) writer structure"]
        impl crate::Writable for AfeReg6Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AFE_REG6 to value 0"]
        impl crate::Resettable for AfeReg6Spec {}
    }
    #[doc = "AFE_DAC (rw) register accessor: DAC digital input\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_dac::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_dac::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afe_dac`] module"]
    #[doc(alias = "AFE_DAC")]
    pub type AfeDac = crate::Reg<afe_dac::AfeDacSpec>;
    #[doc = "DAC digital input"]
    pub mod afe_dac {
        #[doc = "Register `AFE_DAC` reader"]
        pub type R = crate::R<AfeDacSpec>;
        #[doc = "Register `AFE_DAC` writer"]
        pub type W = crate::W<AfeDacSpec>;
        #[doc = "Field `DAC_IN` reader - DAC digital input value"]
        pub type DacInR = crate::FieldReader;
        #[doc = "Field `DAC_IN` writer - DAC digital input value"]
        pub type DacInW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - DAC digital input value"]
            #[inline(always)]
            pub fn dac_in(&self) -> DacInR {
                DacInR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - DAC digital input value"]
            #[inline(always)]
            pub fn dac_in(&mut self) -> DacInW<AfeDacSpec> {
                DacInW::new(self, 0)
            }
        }
        #[doc = "DAC digital input\n\nYou can [`read`](crate::Reg::read) this register and get [`afe_dac::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afe_dac::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AfeDacSpec;
        impl crate::RegisterSpec for AfeDacSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`afe_dac::R`](R) reader structure"]
        impl crate::Readable for AfeDacSpec {}
        #[doc = "`write(|w| ..)` method takes [`afe_dac::W`](W) writer structure"]
        impl crate::Writable for AfeDacSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AFE_DAC to value 0"]
        impl crate::Resettable for AfeDacSpec {}
    }
    #[doc = "CLK_CFG (rw) register accessor: Clock configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_cfg`] module"]
    #[doc(alias = "CLK_CFG")]
    pub type ClkCfg = crate::Reg<clk_cfg::ClkCfgSpec>;
    #[doc = "Clock configuration"]
    pub mod clk_cfg {
        #[doc = "Register `CLK_CFG` reader"]
        pub type R = crate::R<ClkCfgSpec>;
        #[doc = "Register `CLK_CFG` writer"]
        pub type W = crate::W<ClkCfgSpec>;
        #[doc = "Clock enable of every 8 cycles\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ClkDiv {
            #[doc = "0: Divided by 8"]
            Div8 = 0,
            #[doc = "17: Divided by 4"]
            Div4 = 17,
            #[doc = "85: Divided by 2"]
            Div2 = 85,
            #[doc = "255: Divided by 1"]
            Div1 = 255,
        }
        impl From<ClkDiv> for u8 {
            #[inline(always)]
            fn from(variant: ClkDiv) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ClkDiv {
            type Ux = u8;
        }
        impl crate::IsEnum for ClkDiv {}
        #[doc = "Field `CLK_DIV` reader - Clock enable of every 8 cycles"]
        pub type ClkDivR = crate::FieldReader<ClkDiv>;
        impl ClkDivR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<ClkDiv> {
                match self.bits {
                    0 => Some(ClkDiv::Div8),
                    17 => Some(ClkDiv::Div4),
                    85 => Some(ClkDiv::Div2),
                    255 => Some(ClkDiv::Div1),
                    _ => None,
                }
            }
            #[doc = "Divided by 8"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ClkDiv::Div8
            }
            #[doc = "Divided by 4"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ClkDiv::Div4
            }
            #[doc = "Divided by 2"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ClkDiv::Div2
            }
            #[doc = "Divided by 1"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == ClkDiv::Div1
            }
        }
        #[doc = "Field `CLK_DIV` writer - Clock enable of every 8 cycles"]
        pub type ClkDivW<'a, REG> = crate::FieldWriter<'a, REG, 8, ClkDiv>;
        impl<'a, REG> ClkDivW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div8)
            }
            #[doc = "Divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div4)
            }
            #[doc = "Divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div2)
            }
            #[doc = "Divided by 1"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div1)
            }
        }
        #[doc = "Select PLL or HRC as system clock\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ClkSel {
            #[doc = "0: Use 4MHz HRC as system clock"]
            Hrc = 0,
            #[doc = "1: Use PLL clock as system clock"]
            Pll = 1,
            #[doc = "2: Use LRC clock as system clock"]
            Lrc = 2,
            #[doc = "3: Use LRC clock as system clock"]
            Lrc1 = 3,
        }
        impl From<ClkSel> for u8 {
            #[inline(always)]
            fn from(variant: ClkSel) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ClkSel {
            type Ux = u8;
        }
        impl crate::IsEnum for ClkSel {}
        #[doc = "Field `CLK_SEL` reader - Select PLL or HRC as system clock"]
        pub type ClkSelR = crate::FieldReader<ClkSel>;
        impl ClkSelR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ClkSel {
                match self.bits {
                    0 => ClkSel::Hrc,
                    1 => ClkSel::Pll,
                    2 => ClkSel::Lrc,
                    3 => ClkSel::Lrc1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Use 4MHz HRC as system clock"]
            #[inline(always)]
            pub fn is_hrc(&self) -> bool {
                *self == ClkSel::Hrc
            }
            #[doc = "Use PLL clock as system clock"]
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                *self == ClkSel::Pll
            }
            #[doc = "Use LRC clock as system clock"]
            #[inline(always)]
            pub fn is_lrc(&self) -> bool {
                *self == ClkSel::Lrc
            }
            #[doc = "Use LRC clock as system clock"]
            #[inline(always)]
            pub fn is_lrc_1(&self) -> bool {
                *self == ClkSel::Lrc1
            }
        }
        #[doc = "Field `CLK_SEL` writer - Select PLL or HRC as system clock"]
        pub type ClkSelW<'a, REG> = crate::FieldWriter<'a, REG, 2, ClkSel, crate::Safe>;
        impl<'a, REG> ClkSelW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Use 4MHz HRC as system clock"]
            #[inline(always)]
            pub fn hrc(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSel::Hrc)
            }
            #[doc = "Use PLL clock as system clock"]
            #[inline(always)]
            pub fn pll(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSel::Pll)
            }
            #[doc = "Use LRC clock as system clock"]
            #[inline(always)]
            pub fn lrc(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSel::Lrc)
            }
            #[doc = "Use LRC clock as system clock"]
            #[inline(always)]
            pub fn lrc_1(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSel::Lrc1)
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Clock enable of every 8 cycles"]
            #[inline(always)]
            pub fn clk_div(&self) -> ClkDivR {
                ClkDivR::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:9 - Select PLL or HRC as system clock"]
            #[inline(always)]
            pub fn clk_sel(&self) -> ClkSelR {
                ClkSelR::new(((self.bits >> 8) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Clock enable of every 8 cycles"]
            #[inline(always)]
            pub fn clk_div(&mut self) -> ClkDivW<ClkCfgSpec> {
                ClkDivW::new(self, 0)
            }
            #[doc = "Bits 8:9 - Select PLL or HRC as system clock"]
            #[inline(always)]
            pub fn clk_sel(&mut self) -> ClkSelW<ClkCfgSpec> {
                ClkSelW::new(self, 8)
            }
        }
        #[doc = "Clock configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClkCfgSpec;
        impl crate::RegisterSpec for ClkCfgSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clk_cfg::R`](R) reader structure"]
        impl crate::Readable for ClkCfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`clk_cfg::W`](W) writer structure"]
        impl crate::Writable for ClkCfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLK_CFG to value 0"]
        impl crate::Resettable for ClkCfgSpec {}
    }
    #[doc = "IO_CFG (rw) register accessor: IO configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`io_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`io_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@io_cfg`] module"]
    #[doc(alias = "IO_CFG")]
    pub type IoCfg = crate::Reg<io_cfg::IoCfgSpec>;
    #[doc = "IO configuration"]
    pub mod io_cfg {
        #[doc = "Register `IO_CFG` reader"]
        pub type R = crate::R<IoCfgSpec>;
        #[doc = "Register `IO_CFG` writer"]
        pub type W = crate::W<IoCfgSpec>;
        #[doc = "Use RSTn as GPIO\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RstIo {
            #[doc = "0: As RSTn"]
            Disabled = 0,
            #[doc = "1: As GPIO"]
            Enabled = 1,
        }
        impl From<RstIo> for bool {
            #[inline(always)]
            fn from(variant: RstIo) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RST_IO` reader - Use RSTn as GPIO"]
        pub type RstIoR = crate::BitReader<RstIo>;
        impl RstIoR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RstIo {
                match self.bits {
                    false => RstIo::Disabled,
                    true => RstIo::Enabled,
                }
            }
            #[doc = "As RSTn"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RstIo::Disabled
            }
            #[doc = "As GPIO"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RstIo::Enabled
            }
        }
        #[doc = "Field `RST_IO` writer - Use RSTn as GPIO"]
        pub type RstIoW<'a, REG> = crate::BitWriter<'a, REG, RstIo>;
        impl<'a, REG> RstIoW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "As RSTn"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(RstIo::Disabled)
            }
            #[doc = "As GPIO"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(RstIo::Enabled)
            }
        }
        #[doc = "Use SWD as GPIO\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SwdIo {
            #[doc = "0: P1\\[9:8\\] As GPIO"]
            Enabled = 0,
            #[doc = "1: P1\\[9:8\\] As SWD"]
            Disabled = 1,
        }
        impl From<SwdIo> for bool {
            #[inline(always)]
            fn from(variant: SwdIo) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SWD_IO` reader - Use SWD as GPIO"]
        pub type SwdIoR = crate::BitReader<SwdIo>;
        impl SwdIoR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SwdIo {
                match self.bits {
                    false => SwdIo::Enabled,
                    true => SwdIo::Disabled,
                }
            }
            #[doc = "P1\\[9:8\\] As GPIO"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SwdIo::Enabled
            }
            #[doc = "P1\\[9:8\\] As SWD"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SwdIo::Disabled
            }
        }
        #[doc = "Field `SWD_IO` writer - Use SWD as GPIO"]
        pub type SwdIoW<'a, REG> = crate::BitWriter<'a, REG, SwdIo>;
        impl<'a, REG> SwdIoW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "P1\\[9:8\\] As GPIO"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(SwdIo::Enabled)
            }
            #[doc = "P1\\[9:8\\] As SWD"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(SwdIo::Disabled)
            }
        }
        impl R {
            #[doc = "Bit 5 - Use RSTn as GPIO"]
            #[inline(always)]
            pub fn rst_io(&self) -> RstIoR {
                RstIoR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Use SWD as GPIO"]
            #[inline(always)]
            pub fn swd_io(&self) -> SwdIoR {
                SwdIoR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 5 - Use RSTn as GPIO"]
            #[inline(always)]
            pub fn rst_io(&mut self) -> RstIoW<IoCfgSpec> {
                RstIoW::new(self, 5)
            }
            #[doc = "Bit 6 - Use SWD as GPIO"]
            #[inline(always)]
            pub fn swd_io(&mut self) -> SwdIoW<IoCfgSpec> {
                SwdIoW::new(self, 6)
            }
        }
        #[doc = "IO configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`io_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`io_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IoCfgSpec;
        impl crate::RegisterSpec for IoCfgSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`io_cfg::R`](R) reader structure"]
        impl crate::Readable for IoCfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`io_cfg::W`](W) writer structure"]
        impl crate::Writable for IoCfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IO_CFG to value 0"]
        impl crate::Resettable for IoCfgSpec {}
    }
    #[doc = "DBG_CFG (rw) register accessor: IO configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`dbg_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dbg_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dbg_cfg`] module"]
    #[doc(alias = "DBG_CFG")]
    pub type DbgCfg = crate::Reg<dbg_cfg::DbgCfgSpec>;
    #[doc = "IO configuration"]
    pub mod dbg_cfg {
        #[doc = "Register `DBG_CFG` reader"]
        pub type R = crate::R<DbgCfgSpec>;
        #[doc = "Register `DBG_CFG` writer"]
        pub type W = crate::W<DbgCfgSpec>;
        #[doc = "Debug sleep mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DbgSlp {
            #[doc = "0: Not debug"]
            Disabled = 0,
            #[doc = "1: Debug"]
            Enabled = 1,
        }
        impl From<DbgSlp> for bool {
            #[inline(always)]
            fn from(variant: DbgSlp) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DBG_SLP` reader - Debug sleep mode"]
        pub type DbgSlpR = crate::BitReader<DbgSlp>;
        impl DbgSlpR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DbgSlp {
                match self.bits {
                    false => DbgSlp::Disabled,
                    true => DbgSlp::Enabled,
                }
            }
            #[doc = "Not debug"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DbgSlp::Disabled
            }
            #[doc = "Debug"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DbgSlp::Enabled
            }
        }
        #[doc = "Field `DBG_SLP` writer - Debug sleep mode"]
        pub type DbgSlpW<'a, REG> = crate::BitWriter<'a, REG, DbgSlp>;
        impl<'a, REG> DbgSlpW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Not debug"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(DbgSlp::Disabled)
            }
            #[doc = "Debug"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(DbgSlp::Enabled)
            }
        }
        #[doc = "Debug stop mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DbgStop {
            #[doc = "0: Not debug"]
            Disabled = 0,
            #[doc = "1: Debug"]
            Enabled = 1,
        }
        impl From<DbgStop> for bool {
            #[inline(always)]
            fn from(variant: DbgStop) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DBG_STOP` reader - Debug stop mode"]
        pub type DbgStopR = crate::BitReader<DbgStop>;
        impl DbgStopR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DbgStop {
                match self.bits {
                    false => DbgStop::Disabled,
                    true => DbgStop::Enabled,
                }
            }
            #[doc = "Not debug"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DbgStop::Disabled
            }
            #[doc = "Debug"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DbgStop::Enabled
            }
        }
        #[doc = "Field `DBG_STOP` writer - Debug stop mode"]
        pub type DbgStopW<'a, REG> = crate::BitWriter<'a, REG, DbgStop>;
        impl<'a, REG> DbgStopW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Not debug"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(DbgStop::Disabled)
            }
            #[doc = "Debug"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(DbgStop::Enabled)
            }
        }
        #[doc = "Stop IWDG during debug\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DbgIwdgStop {
            #[doc = "0: Not stop"]
            Disabled = 0,
            #[doc = "1: Stop"]
            Enabled = 1,
        }
        impl From<DbgIwdgStop> for bool {
            #[inline(always)]
            fn from(variant: DbgIwdgStop) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DBG_IWDG_STOP` reader - Stop IWDG during debug"]
        pub type DbgIwdgStopR = crate::BitReader<DbgIwdgStop>;
        impl DbgIwdgStopR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DbgIwdgStop {
                match self.bits {
                    false => DbgIwdgStop::Disabled,
                    true => DbgIwdgStop::Enabled,
                }
            }
            #[doc = "Not stop"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DbgIwdgStop::Disabled
            }
            #[doc = "Stop"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DbgIwdgStop::Enabled
            }
        }
        #[doc = "Field `DBG_IWDG_STOP` writer - Stop IWDG during debug"]
        pub type DbgIwdgStopW<'a, REG> = crate::BitWriter<'a, REG, DbgIwdgStop>;
        impl<'a, REG> DbgIwdgStopW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Not stop"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(DbgIwdgStop::Disabled)
            }
            #[doc = "Stop"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(DbgIwdgStop::Enabled)
            }
        }
        #[doc = "Stop Timer0 during debug\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DbgTim0Stop {
            #[doc = "0: Not stop"]
            Disabled = 0,
            #[doc = "1: Stop"]
            Enabled = 1,
        }
        impl From<DbgTim0Stop> for bool {
            #[inline(always)]
            fn from(variant: DbgTim0Stop) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DBG_TIM0_STOP` reader - Stop Timer0 during debug"]
        pub type DbgTim0StopR = crate::BitReader<DbgTim0Stop>;
        impl DbgTim0StopR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DbgTim0Stop {
                match self.bits {
                    false => DbgTim0Stop::Disabled,
                    true => DbgTim0Stop::Enabled,
                }
            }
            #[doc = "Not stop"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DbgTim0Stop::Disabled
            }
            #[doc = "Stop"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DbgTim0Stop::Enabled
            }
        }
        #[doc = "Field `DBG_TIM0_STOP` writer - Stop Timer0 during debug"]
        pub type DbgTim0StopW<'a, REG> = crate::BitWriter<'a, REG, DbgTim0Stop>;
        impl<'a, REG> DbgTim0StopW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Not stop"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(DbgTim0Stop::Disabled)
            }
            #[doc = "Stop"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(DbgTim0Stop::Enabled)
            }
        }
        #[doc = "Stop Timer1 during debug\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DbgTim1Stop {
            #[doc = "0: Not stop"]
            Disabled = 0,
            #[doc = "1: Stop"]
            Enabled = 1,
        }
        impl From<DbgTim1Stop> for bool {
            #[inline(always)]
            fn from(variant: DbgTim1Stop) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DBG_TIM1_STOP` reader - Stop Timer1 during debug"]
        pub type DbgTim1StopR = crate::BitReader<DbgTim1Stop>;
        impl DbgTim1StopR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DbgTim1Stop {
                match self.bits {
                    false => DbgTim1Stop::Disabled,
                    true => DbgTim1Stop::Enabled,
                }
            }
            #[doc = "Not stop"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DbgTim1Stop::Disabled
            }
            #[doc = "Stop"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DbgTim1Stop::Enabled
            }
        }
        #[doc = "Field `DBG_TIM1_STOP` writer - Stop Timer1 during debug"]
        pub type DbgTim1StopW<'a, REG> = crate::BitWriter<'a, REG, DbgTim1Stop>;
        impl<'a, REG> DbgTim1StopW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Not stop"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(DbgTim1Stop::Disabled)
            }
            #[doc = "Stop"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(DbgTim1Stop::Enabled)
            }
        }
        #[doc = "Whether debug soft reset could reset peripherals' registers\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SftRstPeri {
            #[doc = "0: Not reset"]
            Disabled = 0,
            #[doc = "1: Reset"]
            Enabled = 1,
        }
        impl From<SftRstPeri> for bool {
            #[inline(always)]
            fn from(variant: SftRstPeri) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SFT_RST_PERI` reader - Whether debug soft reset could reset peripherals' registers"]
        pub type SftRstPeriR = crate::BitReader<SftRstPeri>;
        impl SftRstPeriR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SftRstPeri {
                match self.bits {
                    false => SftRstPeri::Disabled,
                    true => SftRstPeri::Enabled,
                }
            }
            #[doc = "Not reset"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SftRstPeri::Disabled
            }
            #[doc = "Reset"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SftRstPeri::Enabled
            }
        }
        #[doc = "Field `SFT_RST_PERI` writer - Whether debug soft reset could reset peripherals' registers"]
        pub type SftRstPeriW<'a, REG> = crate::BitWriter<'a, REG, SftRstPeri>;
        impl<'a, REG> SftRstPeriW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Not reset"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(SftRstPeri::Disabled)
            }
            #[doc = "Reset"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(SftRstPeri::Enabled)
            }
        }
        #[doc = "Field `SW_IRQ` writer - Software IRQ flag"]
        pub type SwIrqW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SW_IRQ_TRIG` writer - Write to generate sw IRQ"]
        pub type SwIrqTrigW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bit 0 - Debug sleep mode"]
            #[inline(always)]
            pub fn dbg_slp(&self) -> DbgSlpR {
                DbgSlpR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Debug stop mode"]
            #[inline(always)]
            pub fn dbg_stop(&self) -> DbgStopR {
                DbgStopR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 5 - Stop IWDG during debug"]
            #[inline(always)]
            pub fn dbg_iwdg_stop(&self) -> DbgIwdgStopR {
                DbgIwdgStopR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 8 - Stop Timer0 during debug"]
            #[inline(always)]
            pub fn dbg_tim0_stop(&self) -> DbgTim0StopR {
                DbgTim0StopR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Stop Timer1 during debug"]
            #[inline(always)]
            pub fn dbg_tim1_stop(&self) -> DbgTim1StopR {
                DbgTim1StopR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 14 - Whether debug soft reset could reset peripherals' registers"]
            #[inline(always)]
            pub fn sft_rst_peri(&self) -> SftRstPeriR {
                SftRstPeriR::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Debug sleep mode"]
            #[inline(always)]
            pub fn dbg_slp(&mut self) -> DbgSlpW<DbgCfgSpec> {
                DbgSlpW::new(self, 0)
            }
            #[doc = "Bit 1 - Debug stop mode"]
            #[inline(always)]
            pub fn dbg_stop(&mut self) -> DbgStopW<DbgCfgSpec> {
                DbgStopW::new(self, 1)
            }
            #[doc = "Bit 5 - Stop IWDG during debug"]
            #[inline(always)]
            pub fn dbg_iwdg_stop(&mut self) -> DbgIwdgStopW<DbgCfgSpec> {
                DbgIwdgStopW::new(self, 5)
            }
            #[doc = "Bit 8 - Stop Timer0 during debug"]
            #[inline(always)]
            pub fn dbg_tim0_stop(&mut self) -> DbgTim0StopW<DbgCfgSpec> {
                DbgTim0StopW::new(self, 8)
            }
            #[doc = "Bit 9 - Stop Timer1 during debug"]
            #[inline(always)]
            pub fn dbg_tim1_stop(&mut self) -> DbgTim1StopW<DbgCfgSpec> {
                DbgTim1StopW::new(self, 9)
            }
            #[doc = "Bit 14 - Whether debug soft reset could reset peripherals' registers"]
            #[inline(always)]
            pub fn sft_rst_peri(&mut self) -> SftRstPeriW<DbgCfgSpec> {
                SftRstPeriW::new(self, 14)
            }
            #[doc = "Bit 15 - Software IRQ flag"]
            #[inline(always)]
            pub fn sw_irq(&mut self) -> SwIrqW<DbgCfgSpec> {
                SwIrqW::new(self, 15)
            }
            #[doc = "Bits 16:31 - Write to generate sw IRQ"]
            #[inline(always)]
            pub fn sw_irq_trig(&mut self) -> SwIrqTrigW<DbgCfgSpec> {
                SwIrqTrigW::new(self, 16)
            }
        }
        #[doc = "IO configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`dbg_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dbg_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DbgCfgSpec;
        impl crate::RegisterSpec for DbgCfgSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dbg_cfg::R`](R) reader structure"]
        impl crate::Readable for DbgCfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`dbg_cfg::W`](W) writer structure"]
        impl crate::Writable for DbgCfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DBG_CFG to value 0"]
        impl crate::Resettable for DbgCfgSpec {}
    }
    #[doc = "CLK_DIV0 (rw) register accessor: I2C Clock division ratio\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_div0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_div0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_div0`] module"]
    #[doc(alias = "CLK_DIV0")]
    pub type ClkDiv0 = crate::Reg<clk_div0::ClkDiv0Spec>;
    #[doc = "I2C Clock division ratio"]
    pub mod clk_div0 {
        #[doc = "Register `CLK_DIV0` reader"]
        pub type R = crate::R<ClkDiv0Spec>;
        #[doc = "Register `CLK_DIV0` writer"]
        pub type W = crate::W<ClkDiv0Spec>;
        #[doc = "Field `I2C_CLK_DIV` reader - I2C_CLK=MCLK/(CLK_DIV0+1)"]
        pub type I2cClkDivR = crate::FieldReader<u16>;
        #[doc = "Field `I2C_CLK_DIV` writer - I2C_CLK=MCLK/(CLK_DIV0+1)"]
        pub type I2cClkDivW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - I2C_CLK=MCLK/(CLK_DIV0+1)"]
            #[inline(always)]
            pub fn i2c_clk_div(&self) -> I2cClkDivR {
                I2cClkDivR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - I2C_CLK=MCLK/(CLK_DIV0+1)"]
            #[inline(always)]
            pub fn i2c_clk_div(&mut self) -> I2cClkDivW<ClkDiv0Spec> {
                I2cClkDivW::new(self, 0)
            }
        }
        #[doc = "I2C Clock division ratio\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_div0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_div0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClkDiv0Spec;
        impl crate::RegisterSpec for ClkDiv0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clk_div0::R`](R) reader structure"]
        impl crate::Readable for ClkDiv0Spec {}
        #[doc = "`write(|w| ..)` method takes [`clk_div0::W`](W) writer structure"]
        impl crate::Writable for ClkDiv0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLK_DIV0 to value 0"]
        impl crate::Resettable for ClkDiv0Spec {}
    }
    #[doc = "CLK_DIV2 (rw) register accessor: UART 0/1 Clock division ratio\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_div2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_div2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_div2`] module"]
    #[doc(alias = "CLK_DIV2")]
    pub type ClkDiv2 = crate::Reg<clk_div2::ClkDiv2Spec>;
    #[doc = "UART 0/1 Clock division ratio"]
    pub mod clk_div2 {
        #[doc = "Register `CLK_DIV2` reader"]
        pub type R = crate::R<ClkDiv2Spec>;
        #[doc = "Register `CLK_DIV2` writer"]
        pub type W = crate::W<ClkDiv2Spec>;
        #[doc = "Field `UART_CLK_DIV` reader - UART_CLK=MCLK/(CLK_DIV2+1)"]
        pub type UartClkDivR = crate::FieldReader<u16>;
        #[doc = "Field `UART_CLK_DIV` writer - UART_CLK=MCLK/(CLK_DIV2+1)"]
        pub type UartClkDivW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - UART_CLK=MCLK/(CLK_DIV2+1)"]
            #[inline(always)]
            pub fn uart_clk_div(&self) -> UartClkDivR {
                UartClkDivR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - UART_CLK=MCLK/(CLK_DIV2+1)"]
            #[inline(always)]
            pub fn uart_clk_div(&mut self) -> UartClkDivW<ClkDiv2Spec> {
                UartClkDivW::new(self, 0)
            }
        }
        #[doc = "UART 0/1 Clock division ratio\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_div2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_div2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClkDiv2Spec;
        impl crate::RegisterSpec for ClkDiv2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clk_div2::R`](R) reader structure"]
        impl crate::Readable for ClkDiv2Spec {}
        #[doc = "`write(|w| ..)` method takes [`clk_div2::W`](W) writer structure"]
        impl crate::Writable for ClkDiv2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLK_DIV2 to value 0"]
        impl crate::Resettable for ClkDiv2Spec {}
    }
    #[doc = "CLK_FEN (rw) register accessor: Peripheral clock enable\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_fen::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_fen::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_fen`] module"]
    #[doc(alias = "CLK_FEN")]
    pub type ClkFen = crate::Reg<clk_fen::ClkFenSpec>;
    #[doc = "Peripheral clock enable"]
    pub mod clk_fen {
        #[doc = "Register `CLK_FEN` reader"]
        pub type R = crate::R<ClkFenSpec>;
        #[doc = "Register `CLK_FEN` writer"]
        pub type W = crate::W<ClkFenSpec>;
        #[doc = "I2C module clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum I2cClkEn {
            #[doc = "0: Clock is disabled"]
            Disabled = 0,
            #[doc = "1: Clock is enabled"]
            Enabled = 1,
        }
        impl From<I2cClkEn> for bool {
            #[inline(always)]
            fn from(variant: I2cClkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `I2C_CLK_EN` reader - I2C module clock enable"]
        pub type I2cClkEnR = crate::BitReader<I2cClkEn>;
        impl I2cClkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> I2cClkEn {
                match self.bits {
                    false => I2cClkEn::Disabled,
                    true => I2cClkEn::Enabled,
                }
            }
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == I2cClkEn::Disabled
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == I2cClkEn::Enabled
            }
        }
        #[doc = "Field `I2C_CLK_EN` writer - I2C module clock enable"]
        pub type I2cClkEnW<'a, REG> = crate::BitWriter<'a, REG, I2cClkEn>;
        impl<'a, REG> I2cClkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(I2cClkEn::Disabled)
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(I2cClkEn::Enabled)
            }
        }
        #[doc = "Hall module clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HallClkEn {
            #[doc = "0: Clock is disabled"]
            Disabled = 0,
            #[doc = "1: Clock is enabled"]
            Enabled = 1,
        }
        impl From<HallClkEn> for bool {
            #[inline(always)]
            fn from(variant: HallClkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `HALL_CLK_EN` reader - Hall module clock enable"]
        pub type HallClkEnR = crate::BitReader<HallClkEn>;
        impl HallClkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> HallClkEn {
                match self.bits {
                    false => HallClkEn::Disabled,
                    true => HallClkEn::Enabled,
                }
            }
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == HallClkEn::Disabled
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == HallClkEn::Enabled
            }
        }
        #[doc = "Field `HALL_CLK_EN` writer - Hall module clock enable"]
        pub type HallClkEnW<'a, REG> = crate::BitWriter<'a, REG, HallClkEn>;
        impl<'a, REG> HallClkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(HallClkEn::Disabled)
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(HallClkEn::Enabled)
            }
        }
        #[doc = "UART module clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UartClkEn {
            #[doc = "0: Clock is disabled"]
            Disabled = 0,
            #[doc = "1: Clock is enabled"]
            Enabled = 1,
        }
        impl From<UartClkEn> for bool {
            #[inline(always)]
            fn from(variant: UartClkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `UART_CLK_EN` reader - UART module clock enable"]
        pub type UartClkEnR = crate::BitReader<UartClkEn>;
        impl UartClkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> UartClkEn {
                match self.bits {
                    false => UartClkEn::Disabled,
                    true => UartClkEn::Enabled,
                }
            }
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UartClkEn::Disabled
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UartClkEn::Enabled
            }
        }
        #[doc = "Field `UART_CLK_EN` writer - UART module clock enable"]
        pub type UartClkEnW<'a, REG> = crate::BitWriter<'a, REG, UartClkEn>;
        impl<'a, REG> UartClkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(UartClkEn::Disabled)
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(UartClkEn::Enabled)
            }
        }
        #[doc = "CMP module clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CmpClkEn {
            #[doc = "0: Clock is disabled"]
            Disabled = 0,
            #[doc = "1: Clock is enabled"]
            Enabled = 1,
        }
        impl From<CmpClkEn> for bool {
            #[inline(always)]
            fn from(variant: CmpClkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP_CLK_EN` reader - CMP module clock enable"]
        pub type CmpClkEnR = crate::BitReader<CmpClkEn>;
        impl CmpClkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CmpClkEn {
                match self.bits {
                    false => CmpClkEn::Disabled,
                    true => CmpClkEn::Enabled,
                }
            }
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CmpClkEn::Disabled
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CmpClkEn::Enabled
            }
        }
        #[doc = "Field `CMP_CLK_EN` writer - CMP module clock enable"]
        pub type CmpClkEnW<'a, REG> = crate::BitWriter<'a, REG, CmpClkEn>;
        impl<'a, REG> CmpClkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(CmpClkEn::Disabled)
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(CmpClkEn::Enabled)
            }
        }
        #[doc = "MCPWM module clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum McpwmClkEn {
            #[doc = "0: Clock is disabled"]
            Disabled = 0,
            #[doc = "1: Clock is enabled"]
            Enabled = 1,
        }
        impl From<McpwmClkEn> for bool {
            #[inline(always)]
            fn from(variant: McpwmClkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MCPWM_CLK_EN` reader - MCPWM module clock enable"]
        pub type McpwmClkEnR = crate::BitReader<McpwmClkEn>;
        impl McpwmClkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> McpwmClkEn {
                match self.bits {
                    false => McpwmClkEn::Disabled,
                    true => McpwmClkEn::Enabled,
                }
            }
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == McpwmClkEn::Disabled
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == McpwmClkEn::Enabled
            }
        }
        #[doc = "Field `MCPWM_CLK_EN` writer - MCPWM module clock enable"]
        pub type McpwmClkEnW<'a, REG> = crate::BitWriter<'a, REG, McpwmClkEn>;
        impl<'a, REG> McpwmClkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(McpwmClkEn::Disabled)
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(McpwmClkEn::Enabled)
            }
        }
        #[doc = "Timer0 module clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Timer0ClkEn {
            #[doc = "0: Clock is disabled"]
            Disabled = 0,
            #[doc = "1: Clock is enabled"]
            Enabled = 1,
        }
        impl From<Timer0ClkEn> for bool {
            #[inline(always)]
            fn from(variant: Timer0ClkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIMER0_CLK_EN` reader - Timer0 module clock enable"]
        pub type Timer0ClkEnR = crate::BitReader<Timer0ClkEn>;
        impl Timer0ClkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Timer0ClkEn {
                match self.bits {
                    false => Timer0ClkEn::Disabled,
                    true => Timer0ClkEn::Enabled,
                }
            }
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Timer0ClkEn::Disabled
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Timer0ClkEn::Enabled
            }
        }
        #[doc = "Field `TIMER0_CLK_EN` writer - Timer0 module clock enable"]
        pub type Timer0ClkEnW<'a, REG> = crate::BitWriter<'a, REG, Timer0ClkEn>;
        impl<'a, REG> Timer0ClkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Timer0ClkEn::Disabled)
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Timer0ClkEn::Enabled)
            }
        }
        #[doc = "Timer1 module clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Timer1ClkEn {
            #[doc = "0: Clock is disabled"]
            Disabled = 0,
            #[doc = "1: Clock is enabled"]
            Enabled = 1,
        }
        impl From<Timer1ClkEn> for bool {
            #[inline(always)]
            fn from(variant: Timer1ClkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIMER1_CLK_EN` reader - Timer1 module clock enable"]
        pub type Timer1ClkEnR = crate::BitReader<Timer1ClkEn>;
        impl Timer1ClkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Timer1ClkEn {
                match self.bits {
                    false => Timer1ClkEn::Disabled,
                    true => Timer1ClkEn::Enabled,
                }
            }
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Timer1ClkEn::Disabled
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Timer1ClkEn::Enabled
            }
        }
        #[doc = "Field `TIMER1_CLK_EN` writer - Timer1 module clock enable"]
        pub type Timer1ClkEnW<'a, REG> = crate::BitWriter<'a, REG, Timer1ClkEn>;
        impl<'a, REG> Timer1ClkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Timer1ClkEn::Disabled)
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Timer1ClkEn::Enabled)
            }
        }
        #[doc = "DIV module clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DivClkEn {
            #[doc = "0: Clock is disabled"]
            Disabled = 0,
            #[doc = "1: Clock is enabled"]
            Enabled = 1,
        }
        impl From<DivClkEn> for bool {
            #[inline(always)]
            fn from(variant: DivClkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIV_CLK_EN` reader - DIV module clock enable"]
        pub type DivClkEnR = crate::BitReader<DivClkEn>;
        impl DivClkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DivClkEn {
                match self.bits {
                    false => DivClkEn::Disabled,
                    true => DivClkEn::Enabled,
                }
            }
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DivClkEn::Disabled
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DivClkEn::Enabled
            }
        }
        #[doc = "Field `DIV_CLK_EN` writer - DIV module clock enable"]
        pub type DivClkEnW<'a, REG> = crate::BitWriter<'a, REG, DivClkEn>;
        impl<'a, REG> DivClkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(DivClkEn::Disabled)
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(DivClkEn::Enabled)
            }
        }
        #[doc = "SPI module clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SpiClkEn {
            #[doc = "0: Clock is disabled"]
            Disabled = 0,
            #[doc = "1: Clock is enabled"]
            Enabled = 1,
        }
        impl From<SpiClkEn> for bool {
            #[inline(always)]
            fn from(variant: SpiClkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SPI_CLK_EN` reader - SPI module clock enable"]
        pub type SpiClkEnR = crate::BitReader<SpiClkEn>;
        impl SpiClkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SpiClkEn {
                match self.bits {
                    false => SpiClkEn::Disabled,
                    true => SpiClkEn::Enabled,
                }
            }
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SpiClkEn::Disabled
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SpiClkEn::Enabled
            }
        }
        #[doc = "Field `SPI_CLK_EN` writer - SPI module clock enable"]
        pub type SpiClkEnW<'a, REG> = crate::BitWriter<'a, REG, SpiClkEn>;
        impl<'a, REG> SpiClkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(SpiClkEn::Disabled)
            }
            #[doc = "Clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(SpiClkEn::Enabled)
            }
        }
        impl R {
            #[doc = "Bit 0 - I2C module clock enable"]
            #[inline(always)]
            pub fn i2c_clk_en(&self) -> I2cClkEnR {
                I2cClkEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Hall module clock enable"]
            #[inline(always)]
            pub fn hall_clk_en(&self) -> HallClkEnR {
                HallClkEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - UART module clock enable"]
            #[inline(always)]
            pub fn uart_clk_en(&self) -> UartClkEnR {
                UartClkEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - CMP module clock enable"]
            #[inline(always)]
            pub fn cmp_clk_en(&self) -> CmpClkEnR {
                CmpClkEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - MCPWM module clock enable"]
            #[inline(always)]
            pub fn mcpwm_clk_en(&self) -> McpwmClkEnR {
                McpwmClkEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Timer0 module clock enable"]
            #[inline(always)]
            pub fn timer0_clk_en(&self) -> Timer0ClkEnR {
                Timer0ClkEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Timer1 module clock enable"]
            #[inline(always)]
            pub fn timer1_clk_en(&self) -> Timer1ClkEnR {
                Timer1ClkEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - DIV module clock enable"]
            #[inline(always)]
            pub fn div_clk_en(&self) -> DivClkEnR {
                DivClkEnR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 10 - SPI module clock enable"]
            #[inline(always)]
            pub fn spi_clk_en(&self) -> SpiClkEnR {
                SpiClkEnR::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - I2C module clock enable"]
            #[inline(always)]
            pub fn i2c_clk_en(&mut self) -> I2cClkEnW<ClkFenSpec> {
                I2cClkEnW::new(self, 0)
            }
            #[doc = "Bit 1 - Hall module clock enable"]
            #[inline(always)]
            pub fn hall_clk_en(&mut self) -> HallClkEnW<ClkFenSpec> {
                HallClkEnW::new(self, 1)
            }
            #[doc = "Bit 2 - UART module clock enable"]
            #[inline(always)]
            pub fn uart_clk_en(&mut self) -> UartClkEnW<ClkFenSpec> {
                UartClkEnW::new(self, 2)
            }
            #[doc = "Bit 3 - CMP module clock enable"]
            #[inline(always)]
            pub fn cmp_clk_en(&mut self) -> CmpClkEnW<ClkFenSpec> {
                CmpClkEnW::new(self, 3)
            }
            #[doc = "Bit 4 - MCPWM module clock enable"]
            #[inline(always)]
            pub fn mcpwm_clk_en(&mut self) -> McpwmClkEnW<ClkFenSpec> {
                McpwmClkEnW::new(self, 4)
            }
            #[doc = "Bit 5 - Timer0 module clock enable"]
            #[inline(always)]
            pub fn timer0_clk_en(&mut self) -> Timer0ClkEnW<ClkFenSpec> {
                Timer0ClkEnW::new(self, 5)
            }
            #[doc = "Bit 6 - Timer1 module clock enable"]
            #[inline(always)]
            pub fn timer1_clk_en(&mut self) -> Timer1ClkEnW<ClkFenSpec> {
                Timer1ClkEnW::new(self, 6)
            }
            #[doc = "Bit 8 - DIV module clock enable"]
            #[inline(always)]
            pub fn div_clk_en(&mut self) -> DivClkEnW<ClkFenSpec> {
                DivClkEnW::new(self, 8)
            }
            #[doc = "Bit 10 - SPI module clock enable"]
            #[inline(always)]
            pub fn spi_clk_en(&mut self) -> SpiClkEnW<ClkFenSpec> {
                SpiClkEnW::new(self, 10)
            }
        }
        #[doc = "Peripheral clock enable\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_fen::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_fen::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClkFenSpec;
        impl crate::RegisterSpec for ClkFenSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clk_fen::R`](R) reader structure"]
        impl crate::Readable for ClkFenSpec {}
        #[doc = "`write(|w| ..)` method takes [`clk_fen::W`](W) writer structure"]
        impl crate::Writable for ClkFenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLK_FEN to value 0"]
        impl crate::Resettable for ClkFenSpec {}
    }
    #[doc = "SFR_RST (rw) register accessor: Peripheral soft reset\n\nYou can [`read`](crate::Reg::read) this register and get [`sfr_rst::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sfr_rst::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sfr_rst`] module"]
    #[doc(alias = "SFR_RST")]
    pub type SfrRst = crate::Reg<sfr_rst::SfrRstSpec>;
    #[doc = "Peripheral soft reset"]
    pub mod sfr_rst {
        #[doc = "Register `SFR_RST` reader"]
        pub type R = crate::R<SfrRstSpec>;
        #[doc = "Register `SFR_RST` writer"]
        pub type W = crate::W<SfrRstSpec>;
        #[doc = "I2C module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum I2cSftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<I2cSftRst> for bool {
            #[inline(always)]
            fn from(variant: I2cSftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `I2C_SFT_RST` reader - I2C module soft reset"]
        pub type I2cSftRstR = crate::BitReader<I2cSftRst>;
        impl I2cSftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> I2cSftRst {
                match self.bits {
                    false => I2cSftRst::Release,
                    true => I2cSftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == I2cSftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == I2cSftRst::Reset
            }
        }
        #[doc = "Field `I2C_SFT_RST` writer - I2C module soft reset"]
        pub type I2cSftRstW<'a, REG> = crate::BitWriter<'a, REG, I2cSftRst>;
        impl<'a, REG> I2cSftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(I2cSftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(I2cSftRst::Reset)
            }
        }
        #[doc = "Hall module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HallSftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<HallSftRst> for bool {
            #[inline(always)]
            fn from(variant: HallSftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `HALL_SFT_RST` reader - Hall module soft reset"]
        pub type HallSftRstR = crate::BitReader<HallSftRst>;
        impl HallSftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> HallSftRst {
                match self.bits {
                    false => HallSftRst::Release,
                    true => HallSftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == HallSftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == HallSftRst::Reset
            }
        }
        #[doc = "Field `HALL_SFT_RST` writer - Hall module soft reset"]
        pub type HallSftRstW<'a, REG> = crate::BitWriter<'a, REG, HallSftRst>;
        impl<'a, REG> HallSftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(HallSftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(HallSftRst::Reset)
            }
        }
        #[doc = "UART module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UartSftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<UartSftRst> for bool {
            #[inline(always)]
            fn from(variant: UartSftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `UART_SFT_RST` reader - UART module soft reset"]
        pub type UartSftRstR = crate::BitReader<UartSftRst>;
        impl UartSftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> UartSftRst {
                match self.bits {
                    false => UartSftRst::Release,
                    true => UartSftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == UartSftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == UartSftRst::Reset
            }
        }
        #[doc = "Field `UART_SFT_RST` writer - UART module soft reset"]
        pub type UartSftRstW<'a, REG> = crate::BitWriter<'a, REG, UartSftRst>;
        impl<'a, REG> UartSftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(UartSftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(UartSftRst::Reset)
            }
        }
        #[doc = "CMP module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CmpSftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<CmpSftRst> for bool {
            #[inline(always)]
            fn from(variant: CmpSftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP_SFT_RST` reader - CMP module soft reset"]
        pub type CmpSftRstR = crate::BitReader<CmpSftRst>;
        impl CmpSftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CmpSftRst {
                match self.bits {
                    false => CmpSftRst::Release,
                    true => CmpSftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == CmpSftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == CmpSftRst::Reset
            }
        }
        #[doc = "Field `CMP_SFT_RST` writer - CMP module soft reset"]
        pub type CmpSftRstW<'a, REG> = crate::BitWriter<'a, REG, CmpSftRst>;
        impl<'a, REG> CmpSftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(CmpSftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(CmpSftRst::Reset)
            }
        }
        #[doc = "MCPWM module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum McpwmSftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<McpwmSftRst> for bool {
            #[inline(always)]
            fn from(variant: McpwmSftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MCPWM_SFT_RST` reader - MCPWM module soft reset"]
        pub type McpwmSftRstR = crate::BitReader<McpwmSftRst>;
        impl McpwmSftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> McpwmSftRst {
                match self.bits {
                    false => McpwmSftRst::Release,
                    true => McpwmSftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == McpwmSftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == McpwmSftRst::Reset
            }
        }
        #[doc = "Field `MCPWM_SFT_RST` writer - MCPWM module soft reset"]
        pub type McpwmSftRstW<'a, REG> = crate::BitWriter<'a, REG, McpwmSftRst>;
        impl<'a, REG> McpwmSftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(McpwmSftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(McpwmSftRst::Reset)
            }
        }
        #[doc = "Timer0 module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Timer0SftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<Timer0SftRst> for bool {
            #[inline(always)]
            fn from(variant: Timer0SftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIMER0_SFT_RST` reader - Timer0 module soft reset"]
        pub type Timer0SftRstR = crate::BitReader<Timer0SftRst>;
        impl Timer0SftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Timer0SftRst {
                match self.bits {
                    false => Timer0SftRst::Release,
                    true => Timer0SftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == Timer0SftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == Timer0SftRst::Reset
            }
        }
        #[doc = "Field `TIMER0_SFT_RST` writer - Timer0 module soft reset"]
        pub type Timer0SftRstW<'a, REG> = crate::BitWriter<'a, REG, Timer0SftRst>;
        impl<'a, REG> Timer0SftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(Timer0SftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(Timer0SftRst::Reset)
            }
        }
        #[doc = "Timer1 module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Timer1SftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<Timer1SftRst> for bool {
            #[inline(always)]
            fn from(variant: Timer1SftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIMER1_SFT_RST` reader - Timer1 module soft reset"]
        pub type Timer1SftRstR = crate::BitReader<Timer1SftRst>;
        impl Timer1SftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Timer1SftRst {
                match self.bits {
                    false => Timer1SftRst::Release,
                    true => Timer1SftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == Timer1SftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == Timer1SftRst::Reset
            }
        }
        #[doc = "Field `TIMER1_SFT_RST` writer - Timer1 module soft reset"]
        pub type Timer1SftRstW<'a, REG> = crate::BitWriter<'a, REG, Timer1SftRst>;
        impl<'a, REG> Timer1SftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(Timer1SftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(Timer1SftRst::Reset)
            }
        }
        #[doc = "GPIO module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum GpioSftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<GpioSftRst> for bool {
            #[inline(always)]
            fn from(variant: GpioSftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `GPIO_SFT_RST` reader - GPIO module soft reset"]
        pub type GpioSftRstR = crate::BitReader<GpioSftRst>;
        impl GpioSftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> GpioSftRst {
                match self.bits {
                    false => GpioSftRst::Release,
                    true => GpioSftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == GpioSftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == GpioSftRst::Reset
            }
        }
        #[doc = "Field `GPIO_SFT_RST` writer - GPIO module soft reset"]
        pub type GpioSftRstW<'a, REG> = crate::BitWriter<'a, REG, GpioSftRst>;
        impl<'a, REG> GpioSftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(GpioSftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(GpioSftRst::Reset)
            }
        }
        #[doc = "DSP module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DspSftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<DspSftRst> for bool {
            #[inline(always)]
            fn from(variant: DspSftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DSP_SFT_RST` reader - DSP module soft reset"]
        pub type DspSftRstR = crate::BitReader<DspSftRst>;
        impl DspSftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DspSftRst {
                match self.bits {
                    false => DspSftRst::Release,
                    true => DspSftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == DspSftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == DspSftRst::Reset
            }
        }
        #[doc = "Field `DSP_SFT_RST` writer - DSP module soft reset"]
        pub type DspSftRstW<'a, REG> = crate::BitWriter<'a, REG, DspSftRst>;
        impl<'a, REG> DspSftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(DspSftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(DspSftRst::Reset)
            }
        }
        #[doc = "ADC interface module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AdcSftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<AdcSftRst> for bool {
            #[inline(always)]
            fn from(variant: AdcSftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ADC_SFT_RST` reader - ADC interface module soft reset"]
        pub type AdcSftRstR = crate::BitReader<AdcSftRst>;
        impl AdcSftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> AdcSftRst {
                match self.bits {
                    false => AdcSftRst::Release,
                    true => AdcSftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == AdcSftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == AdcSftRst::Reset
            }
        }
        #[doc = "Field `ADC_SFT_RST` writer - ADC interface module soft reset"]
        pub type AdcSftRstW<'a, REG> = crate::BitWriter<'a, REG, AdcSftRst>;
        impl<'a, REG> AdcSftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(AdcSftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(AdcSftRst::Reset)
            }
        }
        #[doc = "SPI module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SpiSftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<SpiSftRst> for bool {
            #[inline(always)]
            fn from(variant: SpiSftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SPI_SFT_RST` reader - SPI module soft reset"]
        pub type SpiSftRstR = crate::BitReader<SpiSftRst>;
        impl SpiSftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SpiSftRst {
                match self.bits {
                    false => SpiSftRst::Release,
                    true => SpiSftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == SpiSftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == SpiSftRst::Reset
            }
        }
        #[doc = "Field `SPI_SFT_RST` writer - SPI module soft reset"]
        pub type SpiSftRstW<'a, REG> = crate::BitWriter<'a, REG, SpiSftRst>;
        impl<'a, REG> SpiSftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(SpiSftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(SpiSftRst::Reset)
            }
        }
        #[doc = "DMA module soft reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DmaSftRst {
            #[doc = "0: reset release"]
            Release = 0,
            #[doc = "1: reset"]
            Reset = 1,
        }
        impl From<DmaSftRst> for bool {
            #[inline(always)]
            fn from(variant: DmaSftRst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DMA_SFT_RST` reader - DMA module soft reset"]
        pub type DmaSftRstR = crate::BitReader<DmaSftRst>;
        impl DmaSftRstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DmaSftRst {
                match self.bits {
                    false => DmaSftRst::Release,
                    true => DmaSftRst::Reset,
                }
            }
            #[doc = "reset release"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == DmaSftRst::Release
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == DmaSftRst::Reset
            }
        }
        #[doc = "Field `DMA_SFT_RST` writer - DMA module soft reset"]
        pub type DmaSftRstW<'a, REG> = crate::BitWriter<'a, REG, DmaSftRst>;
        impl<'a, REG> DmaSftRstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "reset release"]
            #[inline(always)]
            pub fn release(self) -> &'a mut crate::W<REG> {
                self.variant(DmaSftRst::Release)
            }
            #[doc = "reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(DmaSftRst::Reset)
            }
        }
        impl R {
            #[doc = "Bit 0 - I2C module soft reset"]
            #[inline(always)]
            pub fn i2c_sft_rst(&self) -> I2cSftRstR {
                I2cSftRstR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Hall module soft reset"]
            #[inline(always)]
            pub fn hall_sft_rst(&self) -> HallSftRstR {
                HallSftRstR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - UART module soft reset"]
            #[inline(always)]
            pub fn uart_sft_rst(&self) -> UartSftRstR {
                UartSftRstR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - CMP module soft reset"]
            #[inline(always)]
            pub fn cmp_sft_rst(&self) -> CmpSftRstR {
                CmpSftRstR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - MCPWM module soft reset"]
            #[inline(always)]
            pub fn mcpwm_sft_rst(&self) -> McpwmSftRstR {
                McpwmSftRstR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Timer0 module soft reset"]
            #[inline(always)]
            pub fn timer0_sft_rst(&self) -> Timer0SftRstR {
                Timer0SftRstR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Timer1 module soft reset"]
            #[inline(always)]
            pub fn timer1_sft_rst(&self) -> Timer1SftRstR {
                Timer1SftRstR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - GPIO module soft reset"]
            #[inline(always)]
            pub fn gpio_sft_rst(&self) -> GpioSftRstR {
                GpioSftRstR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - DSP module soft reset"]
            #[inline(always)]
            pub fn dsp_sft_rst(&self) -> DspSftRstR {
                DspSftRstR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - ADC interface module soft reset"]
            #[inline(always)]
            pub fn adc_sft_rst(&self) -> AdcSftRstR {
                AdcSftRstR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - SPI module soft reset"]
            #[inline(always)]
            pub fn spi_sft_rst(&self) -> SpiSftRstR {
                SpiSftRstR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - DMA module soft reset"]
            #[inline(always)]
            pub fn dma_sft_rst(&self) -> DmaSftRstR {
                DmaSftRstR::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - I2C module soft reset"]
            #[inline(always)]
            pub fn i2c_sft_rst(&mut self) -> I2cSftRstW<SfrRstSpec> {
                I2cSftRstW::new(self, 0)
            }
            #[doc = "Bit 1 - Hall module soft reset"]
            #[inline(always)]
            pub fn hall_sft_rst(&mut self) -> HallSftRstW<SfrRstSpec> {
                HallSftRstW::new(self, 1)
            }
            #[doc = "Bit 2 - UART module soft reset"]
            #[inline(always)]
            pub fn uart_sft_rst(&mut self) -> UartSftRstW<SfrRstSpec> {
                UartSftRstW::new(self, 2)
            }
            #[doc = "Bit 3 - CMP module soft reset"]
            #[inline(always)]
            pub fn cmp_sft_rst(&mut self) -> CmpSftRstW<SfrRstSpec> {
                CmpSftRstW::new(self, 3)
            }
            #[doc = "Bit 4 - MCPWM module soft reset"]
            #[inline(always)]
            pub fn mcpwm_sft_rst(&mut self) -> McpwmSftRstW<SfrRstSpec> {
                McpwmSftRstW::new(self, 4)
            }
            #[doc = "Bit 5 - Timer0 module soft reset"]
            #[inline(always)]
            pub fn timer0_sft_rst(&mut self) -> Timer0SftRstW<SfrRstSpec> {
                Timer0SftRstW::new(self, 5)
            }
            #[doc = "Bit 6 - Timer1 module soft reset"]
            #[inline(always)]
            pub fn timer1_sft_rst(&mut self) -> Timer1SftRstW<SfrRstSpec> {
                Timer1SftRstW::new(self, 6)
            }
            #[doc = "Bit 7 - GPIO module soft reset"]
            #[inline(always)]
            pub fn gpio_sft_rst(&mut self) -> GpioSftRstW<SfrRstSpec> {
                GpioSftRstW::new(self, 7)
            }
            #[doc = "Bit 8 - DSP module soft reset"]
            #[inline(always)]
            pub fn dsp_sft_rst(&mut self) -> DspSftRstW<SfrRstSpec> {
                DspSftRstW::new(self, 8)
            }
            #[doc = "Bit 9 - ADC interface module soft reset"]
            #[inline(always)]
            pub fn adc_sft_rst(&mut self) -> AdcSftRstW<SfrRstSpec> {
                AdcSftRstW::new(self, 9)
            }
            #[doc = "Bit 10 - SPI module soft reset"]
            #[inline(always)]
            pub fn spi_sft_rst(&mut self) -> SpiSftRstW<SfrRstSpec> {
                SpiSftRstW::new(self, 10)
            }
            #[doc = "Bit 11 - DMA module soft reset"]
            #[inline(always)]
            pub fn dma_sft_rst(&mut self) -> DmaSftRstW<SfrRstSpec> {
                DmaSftRstW::new(self, 11)
            }
        }
        #[doc = "Peripheral soft reset\n\nYou can [`read`](crate::Reg::read) this register and get [`sfr_rst::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sfr_rst::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SfrRstSpec;
        impl crate::RegisterSpec for SfrRstSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sfr_rst::R`](R) reader structure"]
        impl crate::Readable for SfrRstSpec {}
        #[doc = "`write(|w| ..)` method takes [`sfr_rst::W`](W) writer structure"]
        impl crate::Writable for SfrRstSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SFR_RST to value 0"]
        impl crate::Resettable for SfrRstSpec {}
    }
    #[doc = "PROTECT (w) register accessor: System reg protect\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`protect::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@protect`] module"]
    #[doc(alias = "PROTECT")]
    pub type Protect = crate::Reg<protect::ProtectSpec>;
    #[doc = "System reg protect"]
    pub mod protect {
        #[doc = "Register `PROTECT` writer"]
        pub type W = crate::W<ProtectSpec>;
        #[doc = "Write 0x7A83 to unlock protection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u16)]
        pub enum Psw {
            #[doc = "31363: system register write protect password"]
            Psw = 31363,
        }
        impl From<Psw> for u16 {
            #[inline(always)]
            fn from(variant: Psw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Psw {
            type Ux = u16;
        }
        impl crate::IsEnum for Psw {}
        #[doc = "Field `PSW` writer - Write 0x7A83 to unlock protection"]
        pub type PswW<'a, REG> = crate::FieldWriter<'a, REG, 16, Psw>;
        impl<'a, REG> PswW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u16>,
        {
            #[doc = "system register write protect password"]
            #[inline(always)]
            pub fn psw(self) -> &'a mut crate::W<REG> {
                self.variant(Psw::Psw)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Write 0x7A83 to unlock protection"]
            #[inline(always)]
            pub fn psw(&mut self) -> PswW<ProtectSpec> {
                PswW::new(self, 0)
            }
        }
        #[doc = "System reg protect\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`protect::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ProtectSpec;
        impl crate::RegisterSpec for ProtectSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`protect::W`](W) writer structure"]
        impl crate::Writable for ProtectSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PROTECT to value 0"]
        impl crate::Resettable for ProtectSpec {}
    }
    #[doc = "FLSE (w) register accessor: Flash erase protection\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flse::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@flse`] module"]
    #[doc(alias = "FLSE")]
    pub type Flse = crate::Reg<flse::FlseSpec>;
    #[doc = "Flash erase protection"]
    pub mod flse {
        #[doc = "Register `FLSE` writer"]
        pub type W = crate::W<FlseSpec>;
        #[doc = "Write 0x8FCA to unlock protection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u16)]
        pub enum Psw {
            #[doc = "36810: flash erase protect password"]
            Psw = 36810,
        }
        impl From<Psw> for u16 {
            #[inline(always)]
            fn from(variant: Psw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Psw {
            type Ux = u16;
        }
        impl crate::IsEnum for Psw {}
        #[doc = "Field `PSW` writer - Write 0x8FCA to unlock protection"]
        pub type PswW<'a, REG> = crate::FieldWriter<'a, REG, 16, Psw>;
        impl<'a, REG> PswW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u16>,
        {
            #[doc = "flash erase protect password"]
            #[inline(always)]
            pub fn psw(self) -> &'a mut crate::W<REG> {
                self.variant(Psw::Psw)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Write 0x8FCA to unlock protection"]
            #[inline(always)]
            pub fn psw(&mut self) -> PswW<FlseSpec> {
                PswW::new(self, 0)
            }
        }
        #[doc = "Flash erase protection\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flse::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FlseSpec;
        impl crate::RegisterSpec for FlseSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`flse::W`](W) writer structure"]
        impl crate::Writable for FlseSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FLSE to value 0"]
        impl crate::Resettable for FlseSpec {}
    }
    #[doc = "FLSP (w) register accessor: Flash program protection\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flsp::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@flsp`] module"]
    #[doc(alias = "FLSP")]
    pub type Flsp = crate::Reg<flsp::FlspSpec>;
    #[doc = "Flash program protection"]
    pub mod flsp {
        #[doc = "Register `FLSP` writer"]
        pub type W = crate::W<FlspSpec>;
        #[doc = "Write 0x8F35 to unlock protection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u16)]
        pub enum Psw {
            #[doc = "36661: flash program protect password"]
            Psw = 36661,
        }
        impl From<Psw> for u16 {
            #[inline(always)]
            fn from(variant: Psw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Psw {
            type Ux = u16;
        }
        impl crate::IsEnum for Psw {}
        #[doc = "Field `PSW` writer - Write 0x8F35 to unlock protection"]
        pub type PswW<'a, REG> = crate::FieldWriter<'a, REG, 16, Psw>;
        impl<'a, REG> PswW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u16>,
        {
            #[doc = "flash program protect password"]
            #[inline(always)]
            pub fn psw(self) -> &'a mut crate::W<REG> {
                self.variant(Psw::Psw)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Write 0x8F35 to unlock protection"]
            #[inline(always)]
            pub fn psw(&mut self) -> PswW<FlspSpec> {
                PswW::new(self, 0)
            }
        }
        #[doc = "Flash program protection\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flsp::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FlspSpec;
        impl crate::RegisterSpec for FlspSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`flsp::W`](W) writer structure"]
        impl crate::Writable for FlspSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FLSP to value 0"]
        impl crate::Resettable for FlspSpec {}
    }
}
#[doc = "FLASH registers"]
pub type Flash = crate::Periph<flash::RegisterBlock, 0x0001_0000>;
impl core::fmt::Debug for Flash {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flash").finish()
    }
}
#[doc = "FLASH registers"]
pub mod flash {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        cfg: Cfg,
        addr: Addr,
        wdata: Wdata,
        rdata: Rdata,
        erase: Erase,
        protect: Protect,
        ready: Ready,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Flash Configure Register"]
        #[inline(always)]
        pub const fn cfg(&self) -> &Cfg {
            &self.cfg
        }
        #[doc = "0x04 - Flash Access Address Register"]
        #[inline(always)]
        pub const fn addr(&self) -> &Addr {
            &self.addr
        }
        #[doc = "0x08 - Flash Write Data Register"]
        #[inline(always)]
        pub const fn wdata(&self) -> &Wdata {
            &self.wdata
        }
        #[doc = "0x0c - Flash Read Data Register"]
        #[inline(always)]
        pub const fn rdata(&self) -> &Rdata {
            &self.rdata
        }
        #[doc = "0x10 - Flash Register Trig Erase Operation(Write 0x7654DCBA to Trig Erase Operation)"]
        #[inline(always)]
        pub const fn erase(&self) -> &Erase {
            &self.erase
        }
        #[doc = "0x14 - Read to update Flash Protection Status"]
        #[inline(always)]
        pub const fn protect(&self) -> &Protect {
            &self.protect
        }
        #[doc = "0x18 - Flash Busy/Idle Status"]
        #[inline(always)]
        pub const fn ready(&self) -> &Ready {
            &self.ready
        }
    }
    #[doc = "CFG (rw) register accessor: Flash Configure Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"]
    #[doc(alias = "CFG")]
    pub type Cfg = crate::Reg<cfg::CfgSpec>;
    #[doc = "Flash Configure Register"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CfgSpec>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CfgSpec>;
        #[doc = "Program/Erase timer baseline\n\nValue on reset: 32"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Tbs {
            #[doc = "48: Program/Erase Timer value @ 48Mhz"]
            _48mhz = 48,
            #[doc = "23: Program/Erase Timer value @ 24Mhz"]
            _24mhz = 23,
            #[doc = "11: Program/Erase Timer value @ 12Mhz"]
            _12mhz = 11,
        }
        impl From<Tbs> for u8 {
            #[inline(always)]
            fn from(variant: Tbs) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Tbs {
            type Ux = u8;
        }
        impl crate::IsEnum for Tbs {}
        #[doc = "Field `TBS` reader - Program/Erase timer baseline"]
        pub type TbsR = crate::FieldReader<Tbs>;
        impl TbsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Tbs> {
                match self.bits {
                    48 => Some(Tbs::_48mhz),
                    23 => Some(Tbs::_24mhz),
                    11 => Some(Tbs::_12mhz),
                    _ => None,
                }
            }
            #[doc = "Program/Erase Timer value @ 48Mhz"]
            #[inline(always)]
            pub fn is_48mhz(&self) -> bool {
                *self == Tbs::_48mhz
            }
            #[doc = "Program/Erase Timer value @ 24Mhz"]
            #[inline(always)]
            pub fn is_24mhz(&self) -> bool {
                *self == Tbs::_24mhz
            }
            #[doc = "Program/Erase Timer value @ 12Mhz"]
            #[inline(always)]
            pub fn is_12mhz(&self) -> bool {
                *self == Tbs::_12mhz
            }
        }
        #[doc = "Field `TBS` writer - Program/Erase timer baseline"]
        pub type TbsW<'a, REG> = crate::FieldWriter<'a, REG, 6, Tbs>;
        impl<'a, REG> TbsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Program/Erase Timer value @ 48Mhz"]
            #[inline(always)]
            pub fn _48mhz(self) -> &'a mut crate::W<REG> {
                self.variant(Tbs::_48mhz)
            }
            #[doc = "Program/Erase Timer value @ 24Mhz"]
            #[inline(always)]
            pub fn _24mhz(self) -> &'a mut crate::W<REG> {
                self.variant(Tbs::_24mhz)
            }
            #[doc = "Program/Erase Timer value @ 12Mhz"]
            #[inline(always)]
            pub fn _12mhz(self) -> &'a mut crate::W<REG> {
                self.variant(Tbs::_12mhz)
            }
        }
        #[doc = "Access Main or NVR\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Region {
            #[doc = "0: Main access"]
            Main = 0,
            #[doc = "1: NVR access"]
            Nvr = 1,
        }
        impl From<Region> for bool {
            #[inline(always)]
            fn from(variant: Region) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `REGION` reader - Access Main or NVR"]
        pub type RegionR = crate::BitReader<Region>;
        impl RegionR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Region {
                match self.bits {
                    false => Region::Main,
                    true => Region::Nvr,
                }
            }
            #[doc = "Main access"]
            #[inline(always)]
            pub fn is_main(&self) -> bool {
                *self == Region::Main
            }
            #[doc = "NVR access"]
            #[inline(always)]
            pub fn is_nvr(&self) -> bool {
                *self == Region::Nvr
            }
        }
        #[doc = "Field `REGION` writer - Access Main or NVR"]
        pub type RegionW<'a, REG> = crate::BitWriter<'a, REG, Region>;
        impl<'a, REG> RegionW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Main access"]
            #[inline(always)]
            pub fn main(self) -> &'a mut crate::W<REG> {
                self.variant(Region::Main)
            }
            #[doc = "NVR access"]
            #[inline(always)]
            pub fn nvr(self) -> &'a mut crate::W<REG> {
                self.variant(Region::Nvr)
            }
        }
        #[doc = "Erase Type: Sector/Full\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ErsType {
            #[doc = "0: Sector erase"]
            Sector = 0,
            #[doc = "1: Full chip erase"]
            Chip = 1,
        }
        impl From<ErsType> for bool {
            #[inline(always)]
            fn from(variant: ErsType) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ERS_TYPE` reader - Erase Type: Sector/Full"]
        pub type ErsTypeR = crate::BitReader<ErsType>;
        impl ErsTypeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ErsType {
                match self.bits {
                    false => ErsType::Sector,
                    true => ErsType::Chip,
                }
            }
            #[doc = "Sector erase"]
            #[inline(always)]
            pub fn is_sector(&self) -> bool {
                *self == ErsType::Sector
            }
            #[doc = "Full chip erase"]
            #[inline(always)]
            pub fn is_chip(&self) -> bool {
                *self == ErsType::Chip
            }
        }
        #[doc = "Field `ERS_TYPE` writer - Erase Type: Sector/Full"]
        pub type ErsTypeW<'a, REG> = crate::BitWriter<'a, REG, ErsType>;
        impl<'a, REG> ErsTypeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Sector erase"]
            #[inline(always)]
            pub fn sector(self) -> &'a mut crate::W<REG> {
                self.variant(ErsType::Sector)
            }
            #[doc = "Full chip erase"]
            #[inline(always)]
            pub fn chip(self) -> &'a mut crate::W<REG> {
                self.variant(ErsType::Chip)
            }
        }
        #[doc = "Prefetch Function Enable or Disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Pref {
            #[doc = "0: Prefetch is disabled"]
            Disabled = 0,
            #[doc = "1: Prefetch is enabled"]
            Enabled = 1,
        }
        impl From<Pref> for bool {
            #[inline(always)]
            fn from(variant: Pref) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PREF` reader - Prefetch Function Enable or Disable"]
        pub type PrefR = crate::BitReader<Pref>;
        impl PrefR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Pref {
                match self.bits {
                    false => Pref::Disabled,
                    true => Pref::Enabled,
                }
            }
            #[doc = "Prefetch is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Pref::Disabled
            }
            #[doc = "Prefetch is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Pref::Enabled
            }
        }
        #[doc = "Field `PREF` writer - Prefetch Function Enable or Disable"]
        pub type PrefW<'a, REG> = crate::BitWriter<'a, REG, Pref>;
        impl<'a, REG> PrefW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Prefetch is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Pref::Disabled)
            }
            #[doc = "Prefetch is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Pref::Enabled)
            }
        }
        #[doc = "Flash address is incremented automatically or not during sequent access\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AdrInc {
            #[doc = "0: Address incrementation is disabled"]
            Disabled = 0,
            #[doc = "1: Address incrementation is enabled"]
            Enabled = 1,
        }
        impl From<AdrInc> for bool {
            #[inline(always)]
            fn from(variant: AdrInc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ADR_INC` reader - Flash address is incremented automatically or not during sequent access"]
        pub type AdrIncR = crate::BitReader<AdrInc>;
        impl AdrIncR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> AdrInc {
                match self.bits {
                    false => AdrInc::Disabled,
                    true => AdrInc::Enabled,
                }
            }
            #[doc = "Address incrementation is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == AdrInc::Disabled
            }
            #[doc = "Address incrementation is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == AdrInc::Enabled
            }
        }
        #[doc = "Field `ADR_INC` writer - Flash address is incremented automatically or not during sequent access"]
        pub type AdrIncW<'a, REG> = crate::BitWriter<'a, REG, AdrInc>;
        impl<'a, REG> AdrIncW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Address incrementation is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(AdrInc::Disabled)
            }
            #[doc = "Address incrementation is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(AdrInc::Enabled)
            }
        }
        #[doc = "Flash program operation is enabled or not\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PrgEn {
            #[doc = "0: Program is disabled"]
            Disabled = 0,
            #[doc = "1: Program is enabled"]
            Enabled = 1,
        }
        impl From<PrgEn> for bool {
            #[inline(always)]
            fn from(variant: PrgEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PRG_EN` reader - Flash program operation is enabled or not"]
        pub type PrgEnR = crate::BitReader<PrgEn>;
        impl PrgEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PrgEn {
                match self.bits {
                    false => PrgEn::Disabled,
                    true => PrgEn::Enabled,
                }
            }
            #[doc = "Program is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PrgEn::Disabled
            }
            #[doc = "Program is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PrgEn::Enabled
            }
        }
        #[doc = "Field `PRG_EN` writer - Flash program operation is enabled or not"]
        pub type PrgEnW<'a, REG> = crate::BitWriter<'a, REG, PrgEn>;
        impl<'a, REG> PrgEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Program is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(PrgEn::Disabled)
            }
            #[doc = "Program is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(PrgEn::Enabled)
            }
        }
        #[doc = "Flash erase operation enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ErsEn {
            #[doc = "0: Erase is disabled"]
            Disabled = 0,
            #[doc = "1: Erase is enabled"]
            Enabled = 1,
        }
        impl From<ErsEn> for bool {
            #[inline(always)]
            fn from(variant: ErsEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ERS_EN` reader - Flash erase operation enable"]
        pub type ErsEnR = crate::BitReader<ErsEn>;
        impl ErsEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ErsEn {
                match self.bits {
                    false => ErsEn::Disabled,
                    true => ErsEn::Enabled,
                }
            }
            #[doc = "Erase is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ErsEn::Disabled
            }
            #[doc = "Erase is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ErsEn::Enabled
            }
        }
        #[doc = "Field `ERS_EN` writer - Flash erase operation enable"]
        pub type ErsEnW<'a, REG> = crate::BitWriter<'a, REG, ErsEn>;
        impl<'a, REG> ErsEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Erase is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(ErsEn::Disabled)
            }
            #[doc = "Erase is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(ErsEn::Enabled)
            }
        }
        impl R {
            #[doc = "Bits 0:5 - Program/Erase timer baseline"]
            #[inline(always)]
            pub fn tbs(&self) -> TbsR {
                TbsR::new((self.bits & 0x3f) as u8)
            }
            #[doc = "Bit 11 - Access Main or NVR"]
            #[inline(always)]
            pub fn region(&self) -> RegionR {
                RegionR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 15 - Erase Type: Sector/Full"]
            #[inline(always)]
            pub fn ers_type(&self) -> ErsTypeR {
                ErsTypeR::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 19 - Prefetch Function Enable or Disable"]
            #[inline(always)]
            pub fn pref(&self) -> PrefR {
                PrefR::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 23 - Flash address is incremented automatically or not during sequent access"]
            #[inline(always)]
            pub fn adr_inc(&self) -> AdrIncR {
                AdrIncR::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 27 - Flash program operation is enabled or not"]
            #[inline(always)]
            pub fn prg_en(&self) -> PrgEnR {
                PrgEnR::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 31 - Flash erase operation enable"]
            #[inline(always)]
            pub fn ers_en(&self) -> ErsEnR {
                ErsEnR::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:5 - Program/Erase timer baseline"]
            #[inline(always)]
            pub fn tbs(&mut self) -> TbsW<CfgSpec> {
                TbsW::new(self, 0)
            }
            #[doc = "Bit 11 - Access Main or NVR"]
            #[inline(always)]
            pub fn region(&mut self) -> RegionW<CfgSpec> {
                RegionW::new(self, 11)
            }
            #[doc = "Bit 15 - Erase Type: Sector/Full"]
            #[inline(always)]
            pub fn ers_type(&mut self) -> ErsTypeW<CfgSpec> {
                ErsTypeW::new(self, 15)
            }
            #[doc = "Bit 19 - Prefetch Function Enable or Disable"]
            #[inline(always)]
            pub fn pref(&mut self) -> PrefW<CfgSpec> {
                PrefW::new(self, 19)
            }
            #[doc = "Bit 23 - Flash address is incremented automatically or not during sequent access"]
            #[inline(always)]
            pub fn adr_inc(&mut self) -> AdrIncW<CfgSpec> {
                AdrIncW::new(self, 23)
            }
            #[doc = "Bit 27 - Flash program operation is enabled or not"]
            #[inline(always)]
            pub fn prg_en(&mut self) -> PrgEnW<CfgSpec> {
                PrgEnW::new(self, 27)
            }
            #[doc = "Bit 31 - Flash erase operation enable"]
            #[inline(always)]
            pub fn ers_en(&mut self) -> ErsEnW<CfgSpec> {
                ErsEnW::new(self, 31)
            }
        }
        #[doc = "Flash Configure Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgSpec;
        impl crate::RegisterSpec for CfgSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFG to value 0x60"]
        impl crate::Resettable for CfgSpec {
            const RESET_VALUE: u32 = 0x60;
        }
    }
    #[doc = "ADDR (rw) register accessor: Flash Access Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`addr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@addr`] module"]
    #[doc(alias = "ADDR")]
    pub type Addr = crate::Reg<addr::AddrSpec>;
    #[doc = "Flash Access Address Register"]
    pub mod addr {
        #[doc = "Register `ADDR` reader"]
        pub type R = crate::R<AddrSpec>;
        #[doc = "Register `ADDR` writer"]
        pub type W = crate::W<AddrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Flash Access Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`addr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AddrSpec;
        impl crate::RegisterSpec for AddrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`addr::R`](R) reader structure"]
        impl crate::Readable for AddrSpec {}
        #[doc = "`write(|w| ..)` method takes [`addr::W`](W) writer structure"]
        impl crate::Writable for AddrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets ADDR to value 0"]
        impl crate::Resettable for AddrSpec {}
    }
    #[doc = "WDATA (w) register accessor: Flash Write Data Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wdata::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wdata`] module"]
    #[doc(alias = "WDATA")]
    pub type Wdata = crate::Reg<wdata::WdataSpec>;
    #[doc = "Flash Write Data Register"]
    pub mod wdata {
        #[doc = "Register `WDATA` writer"]
        pub type W = crate::W<WdataSpec>;
        impl core::fmt::Debug for crate::generic::Reg<WdataSpec> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {}
        #[doc = "Flash Write Data Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wdata::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct WdataSpec;
        impl crate::RegisterSpec for WdataSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`wdata::W`](W) writer structure"]
        impl crate::Writable for WdataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets WDATA to value 0"]
        impl crate::Resettable for WdataSpec {}
    }
    #[doc = "RDATA (r) register accessor: Flash Read Data Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rdata::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rdata`] module"]
    #[doc(alias = "RDATA")]
    pub type Rdata = crate::Reg<rdata::RdataSpec>;
    #[doc = "Flash Read Data Register"]
    pub mod rdata {
        #[doc = "Register `RDATA` reader"]
        pub type R = crate::R<RdataSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        #[doc = "Flash Read Data Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rdata::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RdataSpec;
        impl crate::RegisterSpec for RdataSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rdata::R`](R) reader structure"]
        impl crate::Readable for RdataSpec {}
        #[doc = "`reset()` method sets RDATA to value 0"]
        impl crate::Resettable for RdataSpec {}
    }
    #[doc = "ERASE (w) register accessor: Flash Register Trig Erase Operation(Write 0x7654DCBA to Trig Erase Operation)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`erase::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@erase`] module"]
    #[doc(alias = "ERASE")]
    pub type Erase = crate::Reg<erase::EraseSpec>;
    #[doc = "Flash Register Trig Erase Operation(Write 0x7654DCBA to Trig Erase Operation)"]
    pub mod erase {
        #[doc = "Register `ERASE` writer"]
        pub type W = crate::W<EraseSpec>;
        impl core::fmt::Debug for crate::generic::Reg<EraseSpec> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {}
        #[doc = "Flash Register Trig Erase Operation(Write 0x7654DCBA to Trig Erase Operation)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`erase::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EraseSpec;
        impl crate::RegisterSpec for EraseSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`erase::W`](W) writer structure"]
        impl crate::Writable for EraseSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets ERASE to value 0"]
        impl crate::Resettable for EraseSpec {}
    }
    #[doc = "PROTECT (r) register accessor: Read to update Flash Protection Status\n\nYou can [`read`](crate::Reg::read) this register and get [`protect::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@protect`] module"]
    #[doc(alias = "PROTECT")]
    pub type Protect = crate::Reg<protect::ProtectSpec>;
    #[doc = "Read to update Flash Protection Status"]
    pub mod protect {
        #[doc = "Register `PROTECT` reader"]
        pub type R = crate::R<ProtectSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        #[doc = "Read to update Flash Protection Status\n\nYou can [`read`](crate::Reg::read) this register and get [`protect::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ProtectSpec;
        impl crate::RegisterSpec for ProtectSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`protect::R`](R) reader structure"]
        impl crate::Readable for ProtectSpec {}
        #[doc = "`reset()` method sets PROTECT to value 0"]
        impl crate::Resettable for ProtectSpec {}
    }
    #[doc = "READY (r) register accessor: Flash Busy/Idle Status\n\nYou can [`read`](crate::Reg::read) this register and get [`ready::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ready`] module"]
    #[doc(alias = "READY")]
    pub type Ready = crate::Reg<ready::ReadySpec>;
    #[doc = "Flash Busy/Idle Status"]
    pub mod ready {
        #[doc = "Register `READY` reader"]
        pub type R = crate::R<ReadySpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        #[doc = "Flash Busy/Idle Status\n\nYou can [`read`](crate::Reg::read) this register and get [`ready::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ReadySpec;
        impl crate::RegisterSpec for ReadySpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ready::R`](R) reader structure"]
        impl crate::Readable for ReadySpec {}
        #[doc = "`reset()` method sets READY to value 0"]
        impl crate::Resettable for ReadySpec {}
    }
}
#[doc = "SPI registers"]
pub type Spi = crate::Periph<spi::RegisterBlock, 0x4001_0000>;
impl core::fmt::Debug for Spi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi").finish()
    }
}
#[doc = "SPI registers"]
pub mod spi {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        cfg: Cfg,
        _reserved1: [u8; 0x02],
        ie: Ie,
        _reserved2: [u8; 0x02],
        baud: Baud,
        _reserved3: [u8; 0x02],
        txdata: Txdata,
        _reserved4: [u8; 0x02],
        rxdata: Rxdata,
        _reserved5: [u8; 0x02],
        size: Size,
    }
    impl RegisterBlock {
        #[doc = "0x00 - SPI Control Register"]
        #[inline(always)]
        pub const fn cfg(&self) -> &Cfg {
            &self.cfg
        }
        #[doc = "0x04 - SPI Interrupt Register"]
        #[inline(always)]
        pub const fn ie(&self) -> &Ie {
            &self.ie
        }
        #[doc = "0x08 - SPI Buadrate"]
        #[inline(always)]
        pub const fn baud(&self) -> &Baud {
            &self.baud
        }
        #[doc = "0x0c - SPI Tx Data"]
        #[inline(always)]
        pub const fn txdata(&self) -> &Txdata {
            &self.txdata
        }
        #[doc = "0x10 - SPI Rx Data"]
        #[inline(always)]
        pub const fn rxdata(&self) -> &Rxdata {
            &self.rxdata
        }
        #[doc = "0x14 - SPI Data length in bits"]
        #[inline(always)]
        pub const fn size(&self) -> &Size {
            &self.size
        }
    }
    #[doc = "CFG (rw) register accessor: SPI Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"]
    #[doc(alias = "CFG")]
    pub type Cfg = crate::Reg<cfg::CfgSpec>;
    #[doc = "SPI Control Register"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CfgSpec>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CfgSpec>;
        #[doc = "SPI module enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum En {
            #[doc = "0: disable spi module"]
            Disabled = 0,
            #[doc = "1: enable spi module"]
            Enabled = 1,
        }
        impl From<En> for bool {
            #[inline(always)]
            fn from(variant: En) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EN` reader - SPI module enable"]
        pub type EnR = crate::BitReader<En>;
        impl EnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> En {
                match self.bits {
                    false => En::Disabled,
                    true => En::Enabled,
                }
            }
            #[doc = "disable spi module"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == En::Disabled
            }
            #[doc = "enable spi module"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == En::Enabled
            }
        }
        #[doc = "Field `EN` writer - SPI module enable"]
        pub type EnW<'a, REG> = crate::BitWriter<'a, REG, En>;
        impl<'a, REG> EnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "disable spi module"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Disabled)
            }
            #[doc = "enable spi module"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Enabled)
            }
        }
        #[doc = "SPI data endianness\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Endian {
            #[doc = "0: big endian mode, most significant bit sent first"]
            Big = 0,
            #[doc = "1: little endian mode, least significant bit sent first"]
            Little = 1,
        }
        impl From<Endian> for bool {
            #[inline(always)]
            fn from(variant: Endian) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ENDIAN` reader - SPI data endianness"]
        pub type EndianR = crate::BitReader<Endian>;
        impl EndianR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Endian {
                match self.bits {
                    false => Endian::Big,
                    true => Endian::Little,
                }
            }
            #[doc = "big endian mode, most significant bit sent first"]
            #[inline(always)]
            pub fn is_big(&self) -> bool {
                *self == Endian::Big
            }
            #[doc = "little endian mode, least significant bit sent first"]
            #[inline(always)]
            pub fn is_little(&self) -> bool {
                *self == Endian::Little
            }
        }
        #[doc = "Field `ENDIAN` writer - SPI data endianness"]
        pub type EndianW<'a, REG> = crate::BitWriter<'a, REG, Endian>;
        impl<'a, REG> EndianW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "big endian mode, most significant bit sent first"]
            #[inline(always)]
            pub fn big(self) -> &'a mut crate::W<REG> {
                self.variant(Endian::Big)
            }
            #[doc = "little endian mode, least significant bit sent first"]
            #[inline(always)]
            pub fn little(self) -> &'a mut crate::W<REG> {
                self.variant(Endian::Little)
            }
        }
        #[doc = "Clock polarity\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpol {
            #[doc = "0: clock default value is low"]
            Low = 0,
            #[doc = "1: clock default value is high"]
            High = 1,
        }
        impl From<Cpol> for bool {
            #[inline(always)]
            fn from(variant: Cpol) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPOL` reader - Clock polarity"]
        pub type CpolR = crate::BitReader<Cpol>;
        impl CpolR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpol {
                match self.bits {
                    false => Cpol::Low,
                    true => Cpol::High,
                }
            }
            #[doc = "clock default value is low"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == Cpol::Low
            }
            #[doc = "clock default value is high"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == Cpol::High
            }
        }
        #[doc = "Field `CPOL` writer - Clock polarity"]
        pub type CpolW<'a, REG> = crate::BitWriter<'a, REG, Cpol>;
        impl<'a, REG> CpolW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "clock default value is low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut crate::W<REG> {
                self.variant(Cpol::Low)
            }
            #[doc = "clock default value is high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut crate::W<REG> {
                self.variant(Cpol::High)
            }
        }
        #[doc = "Clock phase\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpha {
            #[doc = "0: positive clock edge sample data, negative clock edge send data"]
            Prnt = 0,
            #[doc = "1: positive clock edge send data, negative clock edge sample data"]
            Ptnr = 1,
        }
        impl From<Cpha> for bool {
            #[inline(always)]
            fn from(variant: Cpha) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPHA` reader - Clock phase"]
        pub type CphaR = crate::BitReader<Cpha>;
        impl CphaR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpha {
                match self.bits {
                    false => Cpha::Prnt,
                    true => Cpha::Ptnr,
                }
            }
            #[doc = "positive clock edge sample data, negative clock edge send data"]
            #[inline(always)]
            pub fn is_prnt(&self) -> bool {
                *self == Cpha::Prnt
            }
            #[doc = "positive clock edge send data, negative clock edge sample data"]
            #[inline(always)]
            pub fn is_ptnr(&self) -> bool {
                *self == Cpha::Ptnr
            }
        }
        #[doc = "Field `CPHA` writer - Clock phase"]
        pub type CphaW<'a, REG> = crate::BitWriter<'a, REG, Cpha>;
        impl<'a, REG> CphaW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "positive clock edge sample data, negative clock edge send data"]
            #[inline(always)]
            pub fn prnt(self) -> &'a mut crate::W<REG> {
                self.variant(Cpha::Prnt)
            }
            #[doc = "positive clock edge send data, negative clock edge sample data"]
            #[inline(always)]
            pub fn ptnr(self) -> &'a mut crate::W<REG> {
                self.variant(Cpha::Ptnr)
            }
        }
        #[doc = "SPI device is master or slave\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ms {
            #[doc = "0: slave mode"]
            Slave = 0,
            #[doc = "1: master mode"]
            Master = 1,
        }
        impl From<Ms> for bool {
            #[inline(always)]
            fn from(variant: Ms) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MS` reader - SPI device is master or slave"]
        pub type MsR = crate::BitReader<Ms>;
        impl MsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ms {
                match self.bits {
                    false => Ms::Slave,
                    true => Ms::Master,
                }
            }
            #[doc = "slave mode"]
            #[inline(always)]
            pub fn is_slave(&self) -> bool {
                *self == Ms::Slave
            }
            #[doc = "master mode"]
            #[inline(always)]
            pub fn is_master(&self) -> bool {
                *self == Ms::Master
            }
        }
        #[doc = "Field `MS` writer - SPI device is master or slave"]
        pub type MsW<'a, REG> = crate::BitWriter<'a, REG, Ms>;
        impl<'a, REG> MsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "slave mode"]
            #[inline(always)]
            pub fn slave(self) -> &'a mut crate::W<REG> {
                self.variant(Ms::Slave)
            }
            #[doc = "master mode"]
            #[inline(always)]
            pub fn master(self) -> &'a mut crate::W<REG> {
                self.variant(Ms::Master)
            }
        }
        #[doc = "SPI chip select control big\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cs {
            #[doc = "0: if in spi slave mode, always selected"]
            Always0 = 0,
            #[doc = "1: if in spi slave mode, SPI_CS signal is from spi master"]
            FromMaster = 1,
        }
        impl From<Cs> for bool {
            #[inline(always)]
            fn from(variant: Cs) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CS` reader - SPI chip select control big"]
        pub type CsR = crate::BitReader<Cs>;
        impl CsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cs {
                match self.bits {
                    false => Cs::Always0,
                    true => Cs::FromMaster,
                }
            }
            #[doc = "if in spi slave mode, always selected"]
            #[inline(always)]
            pub fn is_always0(&self) -> bool {
                *self == Cs::Always0
            }
            #[doc = "if in spi slave mode, SPI_CS signal is from spi master"]
            #[inline(always)]
            pub fn is_from_master(&self) -> bool {
                *self == Cs::FromMaster
            }
        }
        #[doc = "Field `CS` writer - SPI chip select control big"]
        pub type CsW<'a, REG> = crate::BitWriter<'a, REG, Cs>;
        impl<'a, REG> CsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "if in spi slave mode, always selected"]
            #[inline(always)]
            pub fn always0(self) -> &'a mut crate::W<REG> {
                self.variant(Cs::Always0)
            }
            #[doc = "if in spi slave mode, SPI_CS signal is from spi master"]
            #[inline(always)]
            pub fn from_master(self) -> &'a mut crate::W<REG> {
                self.variant(Cs::FromMaster)
            }
        }
        #[doc = "Half duplex config\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Duplex {
            #[doc = "3: Half duplex with Rx only"]
            DuplexRx = 3,
            #[doc = "2: Half duplex with Tx only"]
            DuplexTx = 2,
            #[doc = "1: No duplex"]
            NoDuplex = 1,
            #[doc = "0: No duplex"]
            NoDuplex1 = 0,
        }
        impl From<Duplex> for u8 {
            #[inline(always)]
            fn from(variant: Duplex) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Duplex {
            type Ux = u8;
        }
        impl crate::IsEnum for Duplex {}
        #[doc = "Field `DUPLEX` reader - Half duplex config"]
        pub type DuplexR = crate::FieldReader<Duplex>;
        impl DuplexR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Duplex {
                match self.bits {
                    3 => Duplex::DuplexRx,
                    2 => Duplex::DuplexTx,
                    1 => Duplex::NoDuplex,
                    0 => Duplex::NoDuplex1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Half duplex with Rx only"]
            #[inline(always)]
            pub fn is_duplex_rx(&self) -> bool {
                *self == Duplex::DuplexRx
            }
            #[doc = "Half duplex with Tx only"]
            #[inline(always)]
            pub fn is_duplex_tx(&self) -> bool {
                *self == Duplex::DuplexTx
            }
            #[doc = "No duplex"]
            #[inline(always)]
            pub fn is_no_duplex(&self) -> bool {
                *self == Duplex::NoDuplex
            }
            #[doc = "No duplex"]
            #[inline(always)]
            pub fn is_no_duplex_1(&self) -> bool {
                *self == Duplex::NoDuplex1
            }
        }
        #[doc = "Field `DUPLEX` writer - Half duplex config"]
        pub type DuplexW<'a, REG> = crate::FieldWriter<'a, REG, 2, Duplex, crate::Safe>;
        impl<'a, REG> DuplexW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Half duplex with Rx only"]
            #[inline(always)]
            pub fn duplex_rx(self) -> &'a mut crate::W<REG> {
                self.variant(Duplex::DuplexRx)
            }
            #[doc = "Half duplex with Tx only"]
            #[inline(always)]
            pub fn duplex_tx(self) -> &'a mut crate::W<REG> {
                self.variant(Duplex::DuplexTx)
            }
            #[doc = "No duplex"]
            #[inline(always)]
            pub fn no_duplex(self) -> &'a mut crate::W<REG> {
                self.variant(Duplex::NoDuplex)
            }
            #[doc = "No duplex"]
            #[inline(always)]
            pub fn no_duplex_1(self) -> &'a mut crate::W<REG> {
                self.variant(Duplex::NoDuplex1)
            }
        }
        impl R {
            #[doc = "Bit 0 - SPI module enable"]
            #[inline(always)]
            pub fn en(&self) -> EnR {
                EnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - SPI data endianness"]
            #[inline(always)]
            pub fn endian(&self) -> EndianR {
                EndianR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&self) -> CpolR {
                CpolR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&self) -> CphaR {
                CphaR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - SPI device is master or slave"]
            #[inline(always)]
            pub fn ms(&self) -> MsR {
                MsR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - SPI chip select control big"]
            #[inline(always)]
            pub fn cs(&self) -> CsR {
                CsR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bits 6:7 - Half duplex config"]
            #[inline(always)]
            pub fn duplex(&self) -> DuplexR {
                DuplexR::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - SPI module enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EnW<CfgSpec> {
                EnW::new(self, 0)
            }
            #[doc = "Bit 1 - SPI data endianness"]
            #[inline(always)]
            pub fn endian(&mut self) -> EndianW<CfgSpec> {
                EndianW::new(self, 1)
            }
            #[doc = "Bit 2 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&mut self) -> CpolW<CfgSpec> {
                CpolW::new(self, 2)
            }
            #[doc = "Bit 3 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&mut self) -> CphaW<CfgSpec> {
                CphaW::new(self, 3)
            }
            #[doc = "Bit 4 - SPI device is master or slave"]
            #[inline(always)]
            pub fn ms(&mut self) -> MsW<CfgSpec> {
                MsW::new(self, 4)
            }
            #[doc = "Bit 5 - SPI chip select control big"]
            #[inline(always)]
            pub fn cs(&mut self) -> CsW<CfgSpec> {
                CsW::new(self, 5)
            }
            #[doc = "Bits 6:7 - Half duplex config"]
            #[inline(always)]
            pub fn duplex(&mut self) -> DuplexW<CfgSpec> {
                DuplexW::new(self, 6)
            }
        }
        #[doc = "SPI Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgSpec;
        impl crate::RegisterSpec for CfgSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFG to value 0x24"]
        impl crate::Resettable for CfgSpec {
            const RESET_VALUE: u16 = 0x24;
        }
    }
    #[doc = "IE (rw) register accessor: SPI Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie`] module"]
    #[doc(alias = "IE")]
    pub type Ie = crate::Reg<ie::IeSpec>;
    #[doc = "SPI Interrupt Register"]
    pub mod ie {
        #[doc = "Register `IE` reader"]
        pub type R = crate::R<IeSpec>;
        #[doc = "Register `IE` writer"]
        pub type W = crate::W<IeSpec>;
        #[doc = "Overflow Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OvIf {
            #[doc = "0: SPI overflow interrupt is cleared"]
            Clear = 0,
            #[doc = "1: SPI overflow interrupt is set"]
            Set = 1,
        }
        impl From<OvIf> for bool {
            #[inline(always)]
            fn from(variant: OvIf) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OV_IF` reader - Overflow Interrupt"]
        pub type OvIfR = crate::BitReader<OvIf>;
        impl OvIfR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OvIf {
                match self.bits {
                    false => OvIf::Clear,
                    true => OvIf::Set,
                }
            }
            #[doc = "SPI overflow interrupt is cleared"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == OvIf::Clear
            }
            #[doc = "SPI overflow interrupt is set"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == OvIf::Set
            }
        }
        #[doc = "Field `OV_IF` writer - Overflow Interrupt"]
        pub type OvIfW<'a, REG> = crate::BitWriter<'a, REG, OvIf>;
        impl<'a, REG> OvIfW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "SPI overflow interrupt is cleared"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(OvIf::Clear)
            }
            #[doc = "SPI overflow interrupt is set"]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(OvIf::Set)
            }
        }
        #[doc = "Abnormal Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AbIf {
            #[doc = "0: SPI abnormal interrupt is cleared"]
            Clear = 0,
            #[doc = "1: SPI abnormal interrupt is set"]
            Set = 1,
        }
        impl From<AbIf> for bool {
            #[inline(always)]
            fn from(variant: AbIf) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `AB_IF` reader - Abnormal Interrupt"]
        pub type AbIfR = crate::BitReader<AbIf>;
        impl AbIfR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> AbIf {
                match self.bits {
                    false => AbIf::Clear,
                    true => AbIf::Set,
                }
            }
            #[doc = "SPI abnormal interrupt is cleared"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == AbIf::Clear
            }
            #[doc = "SPI abnormal interrupt is set"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == AbIf::Set
            }
        }
        #[doc = "Field `AB_IF` writer - Abnormal Interrupt"]
        pub type AbIfW<'a, REG> = crate::BitWriter<'a, REG, AbIf>;
        impl<'a, REG> AbIfW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "SPI abnormal interrupt is cleared"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(AbIf::Clear)
            }
            #[doc = "SPI abnormal interrupt is set"]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(AbIf::Set)
            }
        }
        #[doc = "Transfer Complete Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CmpltIf {
            #[doc = "0: SPI transfer complete interrupt is cleared"]
            Clear = 0,
            #[doc = "1: SPI transfer complete interrupt is set"]
            Set = 1,
        }
        impl From<CmpltIf> for bool {
            #[inline(always)]
            fn from(variant: CmpltIf) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMPLT_IF` reader - Transfer Complete Interrupt"]
        pub type CmpltIfR = crate::BitReader<CmpltIf>;
        impl CmpltIfR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CmpltIf {
                match self.bits {
                    false => CmpltIf::Clear,
                    true => CmpltIf::Set,
                }
            }
            #[doc = "SPI transfer complete interrupt is cleared"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == CmpltIf::Clear
            }
            #[doc = "SPI transfer complete interrupt is set"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == CmpltIf::Set
            }
        }
        #[doc = "Field `CMPLT_IF` writer - Transfer Complete Interrupt"]
        pub type CmpltIfW<'a, REG> = crate::BitWriter<'a, REG, CmpltIf>;
        impl<'a, REG> CmpltIfW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "SPI transfer complete interrupt is cleared"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(CmpltIf::Clear)
            }
            #[doc = "SPI transfer complete interrupt is set"]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(CmpltIf::Set)
            }
        }
        #[doc = "Trigger Source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TransTrig {
            #[doc = "0: Trigger comes from internal source. Only active in master mode"]
            Internal = 0,
            #[doc = "1: Trigger comes from external source"]
            External = 1,
        }
        impl From<TransTrig> for bool {
            #[inline(always)]
            fn from(variant: TransTrig) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TRANS_TRIG` reader - Trigger Source"]
        pub type TransTrigR = crate::BitReader<TransTrig>;
        impl TransTrigR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TransTrig {
                match self.bits {
                    false => TransTrig::Internal,
                    true => TransTrig::External,
                }
            }
            #[doc = "Trigger comes from internal source. Only active in master mode"]
            #[inline(always)]
            pub fn is_internal(&self) -> bool {
                *self == TransTrig::Internal
            }
            #[doc = "Trigger comes from external source"]
            #[inline(always)]
            pub fn is_external(&self) -> bool {
                *self == TransTrig::External
            }
        }
        #[doc = "Field `TRANS_TRIG` writer - Trigger Source"]
        pub type TransTrigW<'a, REG> = crate::BitWriter<'a, REG, TransTrig>;
        impl<'a, REG> TransTrigW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Trigger comes from internal source. Only active in master mode"]
            #[inline(always)]
            pub fn internal(self) -> &'a mut crate::W<REG> {
                self.variant(TransTrig::Internal)
            }
            #[doc = "Trigger comes from external source"]
            #[inline(always)]
            pub fn external(self) -> &'a mut crate::W<REG> {
                self.variant(TransTrig::External)
            }
        }
        #[doc = "Overflow Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OvIe {
            #[doc = "0: SPI overflow interrupt is disabled"]
            Disabled = 0,
            #[doc = "1: SPI overflow interrupt is enabled"]
            Enabled = 1,
        }
        impl From<OvIe> for bool {
            #[inline(always)]
            fn from(variant: OvIe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OV_IE` reader - Overflow Interrupt Enable"]
        pub type OvIeR = crate::BitReader<OvIe>;
        impl OvIeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OvIe {
                match self.bits {
                    false => OvIe::Disabled,
                    true => OvIe::Enabled,
                }
            }
            #[doc = "SPI overflow interrupt is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OvIe::Disabled
            }
            #[doc = "SPI overflow interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OvIe::Enabled
            }
        }
        #[doc = "Field `OV_IE` writer - Overflow Interrupt Enable"]
        pub type OvIeW<'a, REG> = crate::BitWriter<'a, REG, OvIe>;
        impl<'a, REG> OvIeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "SPI overflow interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(OvIe::Disabled)
            }
            #[doc = "SPI overflow interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(OvIe::Enabled)
            }
        }
        #[doc = "Abnormal Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AbIe {
            #[doc = "0: SPI abnormal interrupt is disabled"]
            Disabled = 0,
            #[doc = "1: SPI abnormal interrupt is enabled"]
            Enabled = 1,
        }
        impl From<AbIe> for bool {
            #[inline(always)]
            fn from(variant: AbIe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `AB_IE` reader - Abnormal Interrupt Enable"]
        pub type AbIeR = crate::BitReader<AbIe>;
        impl AbIeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> AbIe {
                match self.bits {
                    false => AbIe::Disabled,
                    true => AbIe::Enabled,
                }
            }
            #[doc = "SPI abnormal interrupt is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == AbIe::Disabled
            }
            #[doc = "SPI abnormal interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == AbIe::Enabled
            }
        }
        #[doc = "Field `AB_IE` writer - Abnormal Interrupt Enable"]
        pub type AbIeW<'a, REG> = crate::BitWriter<'a, REG, AbIe>;
        impl<'a, REG> AbIeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "SPI abnormal interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(AbIe::Disabled)
            }
            #[doc = "SPI abnormal interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(AbIe::Enabled)
            }
        }
        #[doc = "Transfer Complete Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CmpltIe {
            #[doc = "0: SPI transfer complete interrupt is disabled"]
            Disabled = 0,
            #[doc = "1: SPI transfer complete interrupt is enabled"]
            Enabled = 1,
        }
        impl From<CmpltIe> for bool {
            #[inline(always)]
            fn from(variant: CmpltIe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMPLT_IE` reader - Transfer Complete Interrupt Enable"]
        pub type CmpltIeR = crate::BitReader<CmpltIe>;
        impl CmpltIeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CmpltIe {
                match self.bits {
                    false => CmpltIe::Disabled,
                    true => CmpltIe::Enabled,
                }
            }
            #[doc = "SPI transfer complete interrupt is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CmpltIe::Disabled
            }
            #[doc = "SPI transfer complete interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CmpltIe::Enabled
            }
        }
        #[doc = "Field `CMPLT_IE` writer - Transfer Complete Interrupt Enable"]
        pub type CmpltIeW<'a, REG> = crate::BitWriter<'a, REG, CmpltIe>;
        impl<'a, REG> CmpltIeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "SPI transfer complete interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(CmpltIe::Disabled)
            }
            #[doc = "SPI transfer complete interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(CmpltIe::Enabled)
            }
        }
        #[doc = "Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ie {
            #[doc = "0: SPI interrupt is disabled"]
            Disabled = 0,
            #[doc = "1: SPI interrupt is enabled"]
            Enabled = 1,
        }
        impl From<Ie> for bool {
            #[inline(always)]
            fn from(variant: Ie) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IE` reader - Interrupt Enable"]
        pub type IeR = crate::BitReader<Ie>;
        impl IeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ie {
                match self.bits {
                    false => Ie::Disabled,
                    true => Ie::Enabled,
                }
            }
            #[doc = "SPI interrupt is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ie::Disabled
            }
            #[doc = "SPI interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ie::Enabled
            }
        }
        #[doc = "Field `IE` writer - Interrupt Enable"]
        pub type IeW<'a, REG> = crate::BitWriter<'a, REG, Ie>;
        impl<'a, REG> IeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "SPI interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ie::Disabled)
            }
            #[doc = "SPI interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ie::Enabled)
            }
        }
        impl R {
            #[doc = "Bit 0 - Overflow Interrupt"]
            #[inline(always)]
            pub fn ov_if(&self) -> OvIfR {
                OvIfR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Abnormal Interrupt"]
            #[inline(always)]
            pub fn ab_if(&self) -> AbIfR {
                AbIfR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Transfer Complete Interrupt"]
            #[inline(always)]
            pub fn cmplt_if(&self) -> CmpltIfR {
                CmpltIfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Trigger Source"]
            #[inline(always)]
            pub fn trans_trig(&self) -> TransTrigR {
                TransTrigR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Overflow Interrupt Enable"]
            #[inline(always)]
            pub fn ov_ie(&self) -> OvIeR {
                OvIeR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Abnormal Interrupt Enable"]
            #[inline(always)]
            pub fn ab_ie(&self) -> AbIeR {
                AbIeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Transfer Complete Interrupt Enable"]
            #[inline(always)]
            pub fn cmplt_ie(&self) -> CmpltIeR {
                CmpltIeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Interrupt Enable"]
            #[inline(always)]
            pub fn ie(&self) -> IeR {
                IeR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Overflow Interrupt"]
            #[inline(always)]
            pub fn ov_if(&mut self) -> OvIfW<IeSpec> {
                OvIfW::new(self, 0)
            }
            #[doc = "Bit 1 - Abnormal Interrupt"]
            #[inline(always)]
            pub fn ab_if(&mut self) -> AbIfW<IeSpec> {
                AbIfW::new(self, 1)
            }
            #[doc = "Bit 2 - Transfer Complete Interrupt"]
            #[inline(always)]
            pub fn cmplt_if(&mut self) -> CmpltIfW<IeSpec> {
                CmpltIfW::new(self, 2)
            }
            #[doc = "Bit 3 - Trigger Source"]
            #[inline(always)]
            pub fn trans_trig(&mut self) -> TransTrigW<IeSpec> {
                TransTrigW::new(self, 3)
            }
            #[doc = "Bit 4 - Overflow Interrupt Enable"]
            #[inline(always)]
            pub fn ov_ie(&mut self) -> OvIeW<IeSpec> {
                OvIeW::new(self, 4)
            }
            #[doc = "Bit 5 - Abnormal Interrupt Enable"]
            #[inline(always)]
            pub fn ab_ie(&mut self) -> AbIeW<IeSpec> {
                AbIeW::new(self, 5)
            }
            #[doc = "Bit 6 - Transfer Complete Interrupt Enable"]
            #[inline(always)]
            pub fn cmplt_ie(&mut self) -> CmpltIeW<IeSpec> {
                CmpltIeW::new(self, 6)
            }
            #[doc = "Bit 7 - Interrupt Enable"]
            #[inline(always)]
            pub fn ie(&mut self) -> IeW<IeSpec> {
                IeW::new(self, 7)
            }
        }
        #[doc = "SPI Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IeSpec;
        impl crate::RegisterSpec for IeSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`ie::R`](R) reader structure"]
        impl crate::Readable for IeSpec {}
        #[doc = "`write(|w| ..)` method takes [`ie::W`](W) writer structure"]
        impl crate::Writable for IeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE to value 0"]
        impl crate::Resettable for IeSpec {}
    }
    #[doc = "BAUD (rw) register accessor: SPI Buadrate\n\nYou can [`read`](crate::Reg::read) this register and get [`baud::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`baud::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@baud`] module"]
    #[doc(alias = "BAUD")]
    pub type Baud = crate::Reg<baud::BaudSpec>;
    #[doc = "SPI Buadrate"]
    pub mod baud {
        #[doc = "Register `BAUD` reader"]
        pub type R = crate::R<BaudSpec>;
        #[doc = "Register `BAUD` writer"]
        pub type W = crate::W<BaudSpec>;
        #[doc = "Field `BAUD` reader - SPI baudrate = sys_clk/(2*BAUD+1) BAUD should be larger than 3"]
        pub type BaudR = crate::FieldReader;
        #[doc = "Field `BAUD` writer - SPI baudrate = sys_clk/(2*BAUD+1) BAUD should be larger than 3"]
        pub type BaudW<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        #[doc = "by DMA or CPU\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TransMode {
            #[doc = "0: Transfer by DMA"]
            Dma = 0,
            #[doc = "1: Transfer by CPU"]
            Cpu = 1,
        }
        impl From<TransMode> for bool {
            #[inline(always)]
            fn from(variant: TransMode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TRANS_MODE` reader - by DMA or CPU"]
        pub type TransModeR = crate::BitReader<TransMode>;
        impl TransModeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TransMode {
                match self.bits {
                    false => TransMode::Dma,
                    true => TransMode::Cpu,
                }
            }
            #[doc = "Transfer by DMA"]
            #[inline(always)]
            pub fn is_dma(&self) -> bool {
                *self == TransMode::Dma
            }
            #[doc = "Transfer by CPU"]
            #[inline(always)]
            pub fn is_cpu(&self) -> bool {
                *self == TransMode::Cpu
            }
        }
        #[doc = "Field `TRANS_MODE` writer - by DMA or CPU"]
        pub type TransModeW<'a, REG> = crate::BitWriter<'a, REG, TransMode>;
        impl<'a, REG> TransModeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Transfer by DMA"]
            #[inline(always)]
            pub fn dma(self) -> &'a mut crate::W<REG> {
                self.variant(TransMode::Dma)
            }
            #[doc = "Transfer by CPU"]
            #[inline(always)]
            pub fn cpu(self) -> &'a mut crate::W<REG> {
                self.variant(TransMode::Cpu)
            }
        }
        impl R {
            #[doc = "Bits 0:6 - SPI baudrate = sys_clk/(2*BAUD+1) BAUD should be larger than 3"]
            #[inline(always)]
            pub fn baud(&self) -> BaudR {
                BaudR::new((self.bits & 0x7f) as u8)
            }
            #[doc = "Bit 8 - by DMA or CPU"]
            #[inline(always)]
            pub fn trans_mode(&self) -> TransModeR {
                TransModeR::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - SPI baudrate = sys_clk/(2*BAUD+1) BAUD should be larger than 3"]
            #[inline(always)]
            pub fn baud(&mut self) -> BaudW<BaudSpec> {
                BaudW::new(self, 0)
            }
            #[doc = "Bit 8 - by DMA or CPU"]
            #[inline(always)]
            pub fn trans_mode(&mut self) -> TransModeW<BaudSpec> {
                TransModeW::new(self, 8)
            }
        }
        #[doc = "SPI Buadrate\n\nYou can [`read`](crate::Reg::read) this register and get [`baud::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`baud::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BaudSpec;
        impl crate::RegisterSpec for BaudSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`baud::R`](R) reader structure"]
        impl crate::Readable for BaudSpec {}
        #[doc = "`write(|w| ..)` method takes [`baud::W`](W) writer structure"]
        impl crate::Writable for BaudSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BAUD to value 0"]
        impl crate::Resettable for BaudSpec {}
    }
    #[doc = "TXDATA (rw) register accessor: SPI Tx Data\n\nYou can [`read`](crate::Reg::read) this register and get [`txdata::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdata::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txdata`] module"]
    #[doc(alias = "TXDATA")]
    pub type Txdata = crate::Reg<txdata::TxdataSpec>;
    #[doc = "SPI Tx Data"]
    pub mod txdata {
        #[doc = "Register `TXDATA` reader"]
        pub type R = crate::R<TxdataSpec>;
        #[doc = "Register `TXDATA` writer"]
        pub type W = crate::W<TxdataSpec>;
        #[doc = "Field `TXDATA` reader - Tx Data"]
        pub type TxdataR = crate::FieldReader<u16>;
        #[doc = "Field `TXDATA` writer - Tx Data"]
        pub type TxdataW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Tx Data"]
            #[inline(always)]
            pub fn txdata(&self) -> TxdataR {
                TxdataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Tx Data"]
            #[inline(always)]
            pub fn txdata(&mut self) -> TxdataW<TxdataSpec> {
                TxdataW::new(self, 0)
            }
        }
        #[doc = "SPI Tx Data\n\nYou can [`read`](crate::Reg::read) this register and get [`txdata::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdata::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TxdataSpec;
        impl crate::RegisterSpec for TxdataSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`txdata::R`](R) reader structure"]
        impl crate::Readable for TxdataSpec {}
        #[doc = "`write(|w| ..)` method takes [`txdata::W`](W) writer structure"]
        impl crate::Writable for TxdataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TXDATA to value 0"]
        impl crate::Resettable for TxdataSpec {}
    }
    #[doc = "RXDATA (rw) register accessor: SPI Rx Data\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdata::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxdata::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxdata`] module"]
    #[doc(alias = "RXDATA")]
    pub type Rxdata = crate::Reg<rxdata::RxdataSpec>;
    #[doc = "SPI Rx Data"]
    pub mod rxdata {
        #[doc = "Register `RXDATA` reader"]
        pub type R = crate::R<RxdataSpec>;
        #[doc = "Register `RXDATA` writer"]
        pub type W = crate::W<RxdataSpec>;
        #[doc = "Field `RXDATA` reader - Rx Data"]
        pub type RxdataR = crate::FieldReader<u16>;
        #[doc = "Field `RXDATA` writer - Rx Data"]
        pub type RxdataW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Rx Data"]
            #[inline(always)]
            pub fn rxdata(&self) -> RxdataR {
                RxdataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Rx Data"]
            #[inline(always)]
            pub fn rxdata(&mut self) -> RxdataW<RxdataSpec> {
                RxdataW::new(self, 0)
            }
        }
        #[doc = "SPI Rx Data\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdata::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxdata::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RxdataSpec;
        impl crate::RegisterSpec for RxdataSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`rxdata::R`](R) reader structure"]
        impl crate::Readable for RxdataSpec {}
        #[doc = "`write(|w| ..)` method takes [`rxdata::W`](W) writer structure"]
        impl crate::Writable for RxdataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets RXDATA to value 0"]
        impl crate::Resettable for RxdataSpec {}
    }
    #[doc = "SIZE (rw) register accessor: SPI Data length in bits\n\nYou can [`read`](crate::Reg::read) this register and get [`size::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`size::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@size`] module"]
    #[doc(alias = "SIZE")]
    pub type Size = crate::Reg<size::SizeSpec>;
    #[doc = "SPI Data length in bits"]
    pub mod size {
        #[doc = "Register `SIZE` reader"]
        pub type R = crate::R<SizeSpec>;
        #[doc = "Register `SIZE` writer"]
        pub type W = crate::W<SizeSpec>;
        #[doc = "Data length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Bitsize {
            #[doc = "8: 8bit per byte"]
            _8bit = 8,
            #[doc = "9: 9bit per byte"]
            _9bit = 9,
            #[doc = "10: 10bit per byte"]
            _10bit = 10,
            #[doc = "11: 11bit per byte"]
            _11bit = 11,
            #[doc = "12: 12bit per byte"]
            _12bit = 12,
            #[doc = "13: 13bit per byte"]
            _13bit = 13,
            #[doc = "14: 14bit per byte"]
            _14bit = 14,
            #[doc = "15: 15bit per byte"]
            _15bit = 15,
            #[doc = "16: 16bit per byte"]
            _16bit = 16,
        }
        impl From<Bitsize> for u8 {
            #[inline(always)]
            fn from(variant: Bitsize) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Bitsize {
            type Ux = u8;
        }
        impl crate::IsEnum for Bitsize {}
        #[doc = "Field `BITSIZE` reader - Data length"]
        pub type BitsizeR = crate::FieldReader<Bitsize>;
        impl BitsizeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Bitsize> {
                match self.bits {
                    8 => Some(Bitsize::_8bit),
                    9 => Some(Bitsize::_9bit),
                    10 => Some(Bitsize::_10bit),
                    11 => Some(Bitsize::_11bit),
                    12 => Some(Bitsize::_12bit),
                    13 => Some(Bitsize::_13bit),
                    14 => Some(Bitsize::_14bit),
                    15 => Some(Bitsize::_15bit),
                    16 => Some(Bitsize::_16bit),
                    _ => None,
                }
            }
            #[doc = "8bit per byte"]
            #[inline(always)]
            pub fn is_8bit(&self) -> bool {
                *self == Bitsize::_8bit
            }
            #[doc = "9bit per byte"]
            #[inline(always)]
            pub fn is_9bit(&self) -> bool {
                *self == Bitsize::_9bit
            }
            #[doc = "10bit per byte"]
            #[inline(always)]
            pub fn is_10bit(&self) -> bool {
                *self == Bitsize::_10bit
            }
            #[doc = "11bit per byte"]
            #[inline(always)]
            pub fn is_11bit(&self) -> bool {
                *self == Bitsize::_11bit
            }
            #[doc = "12bit per byte"]
            #[inline(always)]
            pub fn is_12bit(&self) -> bool {
                *self == Bitsize::_12bit
            }
            #[doc = "13bit per byte"]
            #[inline(always)]
            pub fn is_13bit(&self) -> bool {
                *self == Bitsize::_13bit
            }
            #[doc = "14bit per byte"]
            #[inline(always)]
            pub fn is_14bit(&self) -> bool {
                *self == Bitsize::_14bit
            }
            #[doc = "15bit per byte"]
            #[inline(always)]
            pub fn is_15bit(&self) -> bool {
                *self == Bitsize::_15bit
            }
            #[doc = "16bit per byte"]
            #[inline(always)]
            pub fn is_16bit(&self) -> bool {
                *self == Bitsize::_16bit
            }
        }
        #[doc = "Field `BITSIZE` writer - Data length"]
        pub type BitsizeW<'a, REG> = crate::FieldWriter<'a, REG, 5, Bitsize>;
        impl<'a, REG> BitsizeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "8bit per byte"]
            #[inline(always)]
            pub fn _8bit(self) -> &'a mut crate::W<REG> {
                self.variant(Bitsize::_8bit)
            }
            #[doc = "9bit per byte"]
            #[inline(always)]
            pub fn _9bit(self) -> &'a mut crate::W<REG> {
                self.variant(Bitsize::_9bit)
            }
            #[doc = "10bit per byte"]
            #[inline(always)]
            pub fn _10bit(self) -> &'a mut crate::W<REG> {
                self.variant(Bitsize::_10bit)
            }
            #[doc = "11bit per byte"]
            #[inline(always)]
            pub fn _11bit(self) -> &'a mut crate::W<REG> {
                self.variant(Bitsize::_11bit)
            }
            #[doc = "12bit per byte"]
            #[inline(always)]
            pub fn _12bit(self) -> &'a mut crate::W<REG> {
                self.variant(Bitsize::_12bit)
            }
            #[doc = "13bit per byte"]
            #[inline(always)]
            pub fn _13bit(self) -> &'a mut crate::W<REG> {
                self.variant(Bitsize::_13bit)
            }
            #[doc = "14bit per byte"]
            #[inline(always)]
            pub fn _14bit(self) -> &'a mut crate::W<REG> {
                self.variant(Bitsize::_14bit)
            }
            #[doc = "15bit per byte"]
            #[inline(always)]
            pub fn _15bit(self) -> &'a mut crate::W<REG> {
                self.variant(Bitsize::_15bit)
            }
            #[doc = "16bit per byte"]
            #[inline(always)]
            pub fn _16bit(self) -> &'a mut crate::W<REG> {
                self.variant(Bitsize::_16bit)
            }
        }
        impl R {
            #[doc = "Bits 0:4 - Data length"]
            #[inline(always)]
            pub fn bitsize(&self) -> BitsizeR {
                BitsizeR::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:4 - Data length"]
            #[inline(always)]
            pub fn bitsize(&mut self) -> BitsizeW<SizeSpec> {
                BitsizeW::new(self, 0)
            }
        }
        #[doc = "SPI Data length in bits\n\nYou can [`read`](crate::Reg::read) this register and get [`size::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`size::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SizeSpec;
        impl crate::RegisterSpec for SizeSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`size::R`](R) reader structure"]
        impl crate::Readable for SizeSpec {}
        #[doc = "`write(|w| ..)` method takes [`size::W`](W) writer structure"]
        impl crate::Writable for SizeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SIZE to value 0"]
        impl crate::Resettable for SizeSpec {}
    }
}
#[doc = "I2C registers"]
pub type I2c = crate::Periph<i2c::RegisterBlock, 0x4001_0100>;
impl core::fmt::Debug for I2c {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c").finish()
    }
}
#[doc = "I2C registers"]
pub mod i2c {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        addr: Addr,
        _reserved1: [u8; 0x03],
        cfg: Cfg,
        _reserved2: [u8; 0x03],
        scr: Scr,
        _reserved3: [u8; 0x03],
        data: Data,
        _reserved4: [u8; 0x03],
        mscr: Mscr,
        _reserved5: [u8; 0x03],
        bcr: Bcr,
        _reserved6: [u8; 0x03],
        bsize: Bsize,
    }
    impl RegisterBlock {
        #[doc = "0x00 - I2C Device Address"]
        #[inline(always)]
        pub const fn addr(&self) -> &Addr {
            &self.addr
        }
        #[doc = "0x04 - I2C Configuration"]
        #[inline(always)]
        pub const fn cfg(&self) -> &Cfg {
            &self.cfg
        }
        #[doc = "0x08 - I2C State_Control"]
        #[inline(always)]
        pub const fn scr(&self) -> &Scr {
            &self.scr
        }
        #[doc = "0x0c - I2C Data Regsiter"]
        #[inline(always)]
        pub const fn data(&self) -> &Data {
            &self.data
        }
        #[doc = "0x10 - I2C Master State_Control"]
        #[inline(always)]
        pub const fn mscr(&self) -> &Mscr {
            &self.mscr
        }
        #[doc = "0x14 - I2C Burst Control"]
        #[inline(always)]
        pub const fn bcr(&self) -> &Bcr {
            &self.bcr
        }
        #[doc = "0x18 - DMA Length"]
        #[inline(always)]
        pub const fn bsize(&self) -> &Bsize {
            &self.bsize
        }
    }
    #[doc = "ADDR (rw) register accessor: I2C Device Address\n\nYou can [`read`](crate::Reg::read) this register and get [`addr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@addr`] module"]
    #[doc(alias = "ADDR")]
    pub type Addr = crate::Reg<addr::AddrSpec>;
    #[doc = "I2C Device Address"]
    pub mod addr {
        #[doc = "Register `ADDR` reader"]
        pub type R = crate::R<AddrSpec>;
        #[doc = "Register `ADDR` writer"]
        pub type W = crate::W<AddrSpec>;
        #[doc = "Field `ADDR` reader - i2c device address"]
        pub type AddrR = crate::FieldReader;
        #[doc = "Field `ADDR` writer - i2c device address"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        #[doc = "i2c address compared by hardware control bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AddrCmp {
            #[doc = "0: disable address compare by hardware"]
            Disabled = 0,
            #[doc = "1: enable address compare by hardware"]
            Enabled = 1,
        }
        impl From<AddrCmp> for bool {
            #[inline(always)]
            fn from(variant: AddrCmp) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ADDR_CMP` reader - i2c address compared by hardware control bit"]
        pub type AddrCmpR = crate::BitReader<AddrCmp>;
        impl AddrCmpR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> AddrCmp {
                match self.bits {
                    false => AddrCmp::Disabled,
                    true => AddrCmp::Enabled,
                }
            }
            #[doc = "disable address compare by hardware"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == AddrCmp::Disabled
            }
            #[doc = "enable address compare by hardware"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == AddrCmp::Enabled
            }
        }
        #[doc = "Field `ADDR_CMP` writer - i2c address compared by hardware control bit"]
        pub type AddrCmpW<'a, REG> = crate::BitWriter<'a, REG, AddrCmp>;
        impl<'a, REG> AddrCmpW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "disable address compare by hardware"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(AddrCmp::Disabled)
            }
            #[doc = "enable address compare by hardware"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(AddrCmp::Enabled)
            }
        }
        impl R {
            #[doc = "Bits 0:6 - i2c device address"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(self.bits & 0x7f)
            }
            #[doc = "Bit 7 - i2c address compared by hardware control bit"]
            #[inline(always)]
            pub fn addr_cmp(&self) -> AddrCmpR {
                AddrCmpR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - i2c device address"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<AddrSpec> {
                AddrW::new(self, 0)
            }
            #[doc = "Bit 7 - i2c address compared by hardware control bit"]
            #[inline(always)]
            pub fn addr_cmp(&mut self) -> AddrCmpW<AddrSpec> {
                AddrCmpW::new(self, 7)
            }
        }
        #[doc = "I2C Device Address\n\nYou can [`read`](crate::Reg::read) this register and get [`addr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AddrSpec;
        impl crate::RegisterSpec for AddrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`addr::R`](R) reader structure"]
        impl crate::Readable for AddrSpec {}
        #[doc = "`write(|w| ..)` method takes [`addr::W`](W) writer structure"]
        impl crate::Writable for AddrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets ADDR to value 0"]
        impl crate::Resettable for AddrSpec {}
    }
    #[doc = "CFG (rw) register accessor: I2C Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"]
    #[doc(alias = "CFG")]
    pub type Cfg = crate::Reg<cfg::CfgSpec>;
    #[doc = "I2C Configuration"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CfgSpec>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CfgSpec>;
        #[doc = "i2c slave mode control bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SlvMode {
            #[doc = "0: I2C slave mode is disabled"]
            Disabled = 0,
            #[doc = "1: I2C slave mode is enabled"]
            Enabled = 1,
        }
        impl From<SlvMode> for bool {
            #[inline(always)]
            fn from(variant: SlvMode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SLV_MODE` reader - i2c slave mode control bit"]
        pub type SlvModeR = crate::BitReader<SlvMode>;
        impl SlvModeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SlvMode {
                match self.bits {
                    false => SlvMode::Disabled,
                    true => SlvMode::Enabled,
                }
            }
            #[doc = "I2C slave mode is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SlvMode::Disabled
            }
            #[doc = "I2C slave mode is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SlvMode::Enabled
            }
        }
        #[doc = "Field `SLV_MODE` writer - i2c slave mode control bit"]
        pub type SlvModeW<'a, REG> = crate::BitWriter<'a, REG, SlvMode>;
        impl<'a, REG> SlvModeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "I2C slave mode is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(SlvMode::Disabled)
            }
            #[doc = "I2C slave mode is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(SlvMode::Enabled)
            }
        }
        #[doc = "i2c master mode control bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MstMode {
            #[doc = "0: I2C master mode is disabled"]
            Disabled = 0,
            #[doc = "1: I2C master mode is enabled"]
            Enabled = 1,
        }
        impl From<MstMode> for bool {
            #[inline(always)]
            fn from(variant: MstMode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MST_MODE` reader - i2c master mode control bit"]
        pub type MstModeR = crate::BitReader<MstMode>;
        impl MstModeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MstMode {
                match self.bits {
                    false => MstMode::Disabled,
                    true => MstMode::Enabled,
                }
            }
            #[doc = "I2C master mode is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MstMode::Disabled
            }
            #[doc = "I2C master mode is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MstMode::Enabled
            }
        }
        #[doc = "Field `MST_MODE` writer - i2c master mode control bit"]
        pub type MstModeW<'a, REG> = crate::BitWriter<'a, REG, MstMode>;
        impl<'a, REG> MstModeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "I2C master mode is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(MstMode::Disabled)
            }
            #[doc = "I2C master mode is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(MstMode::Enabled)
            }
        }
        #[doc = "i2c bus error interrupt control bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum StopIe {
            #[doc = "0: I2C stop interrupt is disabled"]
            Disabled = 0,
            #[doc = "1: I2C stop interrupt is enabled"]
            Enabled = 1,
        }
        impl From<StopIe> for bool {
            #[inline(always)]
            fn from(variant: StopIe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `STOP_IE` reader - i2c bus error interrupt control bit"]
        pub type StopIeR = crate::BitReader<StopIe>;
        impl StopIeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> StopIe {
                match self.bits {
                    false => StopIe::Disabled,
                    true => StopIe::Enabled,
                }
            }
            #[doc = "I2C stop interrupt is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == StopIe::Disabled
            }
            #[doc = "I2C stop interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == StopIe::Enabled
            }
        }
        #[doc = "Field `STOP_IE` writer - i2c bus error interrupt control bit"]
        pub type StopIeW<'a, REG> = crate::BitWriter<'a, REG, StopIe>;
        impl<'a, REG> StopIeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "I2C stop interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(StopIe::Disabled)
            }
            #[doc = "I2C stop interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(StopIe::Enabled)
            }
        }
        #[doc = "i2c bus error interrupt control bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BusErrIe {
            #[doc = "0: I2C bus error interrupt disable"]
            Disabled = 0,
            #[doc = "1: I2C bus error interrupt enable.only valid in master mode, master will release bus to idle state"]
            Enabled = 1,
        }
        impl From<BusErrIe> for bool {
            #[inline(always)]
            fn from(variant: BusErrIe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BUS_ERR_IE` reader - i2c bus error interrupt control bit"]
        pub type BusErrIeR = crate::BitReader<BusErrIe>;
        impl BusErrIeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BusErrIe {
                match self.bits {
                    false => BusErrIe::Disabled,
                    true => BusErrIe::Enabled,
                }
            }
            #[doc = "I2C bus error interrupt disable"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BusErrIe::Disabled
            }
            #[doc = "I2C bus error interrupt enable.only valid in master mode, master will release bus to idle state"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BusErrIe::Enabled
            }
        }
        #[doc = "Field `BUS_ERR_IE` writer - i2c bus error interrupt control bit"]
        pub type BusErrIeW<'a, REG> = crate::BitWriter<'a, REG, BusErrIe>;
        impl<'a, REG> BusErrIeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "I2C bus error interrupt disable"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(BusErrIe::Disabled)
            }
            #[doc = "I2C bus error interrupt enable.only valid in master mode, master will release bus to idle state"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(BusErrIe::Enabled)
            }
        }
        #[doc = "i2c transfer complete interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TcIe {
            #[doc = "0: I2C transfer complete interrupt is disabled"]
            Disabled = 0,
            #[doc = "1: I2C transfer complete interrupt is enabled"]
            Enabled = 1,
        }
        impl From<TcIe> for bool {
            #[inline(always)]
            fn from(variant: TcIe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TC_IE` reader - i2c transfer complete interrupt enable"]
        pub type TcIeR = crate::BitReader<TcIe>;
        impl TcIeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TcIe {
                match self.bits {
                    false => TcIe::Disabled,
                    true => TcIe::Enabled,
                }
            }
            #[doc = "I2C transfer complete interrupt is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TcIe::Disabled
            }
            #[doc = "I2C transfer complete interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TcIe::Enabled
            }
        }
        #[doc = "Field `TC_IE` writer - i2c transfer complete interrupt enable"]
        pub type TcIeW<'a, REG> = crate::BitWriter<'a, REG, TcIe>;
        impl<'a, REG> TcIeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "I2C transfer complete interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(TcIe::Disabled)
            }
            #[doc = "I2C transfer complete interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(TcIe::Enabled)
            }
        }
        #[doc = "i2c interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ie {
            #[doc = "0: I2C interrupt is disabled"]
            Disabled = 0,
            #[doc = "1: I2C interrupt is enabled"]
            Enabled = 1,
        }
        impl From<Ie> for bool {
            #[inline(always)]
            fn from(variant: Ie) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IE` reader - i2c interrupt enable"]
        pub type IeR = crate::BitReader<Ie>;
        impl IeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ie {
                match self.bits {
                    false => Ie::Disabled,
                    true => Ie::Enabled,
                }
            }
            #[doc = "I2C interrupt is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ie::Disabled
            }
            #[doc = "I2C interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ie::Enabled
            }
        }
        #[doc = "Field `IE` writer - i2c interrupt enable"]
        pub type IeW<'a, REG> = crate::BitWriter<'a, REG, Ie>;
        impl<'a, REG> IeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "I2C interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ie::Disabled)
            }
            #[doc = "I2C interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ie::Enabled)
            }
        }
        impl R {
            #[doc = "Bit 0 - i2c slave mode control bit"]
            #[inline(always)]
            pub fn slv_mode(&self) -> SlvModeR {
                SlvModeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - i2c master mode control bit"]
            #[inline(always)]
            pub fn mst_mode(&self) -> MstModeR {
                MstModeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 4 - i2c bus error interrupt control bit"]
            #[inline(always)]
            pub fn stop_ie(&self) -> StopIeR {
                StopIeR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - i2c bus error interrupt control bit"]
            #[inline(always)]
            pub fn bus_err_ie(&self) -> BusErrIeR {
                BusErrIeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - i2c transfer complete interrupt enable"]
            #[inline(always)]
            pub fn tc_ie(&self) -> TcIeR {
                TcIeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - i2c interrupt enable"]
            #[inline(always)]
            pub fn ie(&self) -> IeR {
                IeR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - i2c slave mode control bit"]
            #[inline(always)]
            pub fn slv_mode(&mut self) -> SlvModeW<CfgSpec> {
                SlvModeW::new(self, 0)
            }
            #[doc = "Bit 1 - i2c master mode control bit"]
            #[inline(always)]
            pub fn mst_mode(&mut self) -> MstModeW<CfgSpec> {
                MstModeW::new(self, 1)
            }
            #[doc = "Bit 4 - i2c bus error interrupt control bit"]
            #[inline(always)]
            pub fn stop_ie(&mut self) -> StopIeW<CfgSpec> {
                StopIeW::new(self, 4)
            }
            #[doc = "Bit 5 - i2c bus error interrupt control bit"]
            #[inline(always)]
            pub fn bus_err_ie(&mut self) -> BusErrIeW<CfgSpec> {
                BusErrIeW::new(self, 5)
            }
            #[doc = "Bit 6 - i2c transfer complete interrupt enable"]
            #[inline(always)]
            pub fn tc_ie(&mut self) -> TcIeW<CfgSpec> {
                TcIeW::new(self, 6)
            }
            #[doc = "Bit 7 - i2c interrupt enable"]
            #[inline(always)]
            pub fn ie(&mut self) -> IeW<CfgSpec> {
                IeW::new(self, 7)
            }
        }
        #[doc = "I2C Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgSpec;
        impl crate::RegisterSpec for CfgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFG to value 0"]
        impl crate::Resettable for CfgSpec {}
    }
    #[doc = "SCR (rw) register accessor: I2C State_Control\n\nYou can [`read`](crate::Reg::read) this register and get [`scr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@scr`] module"]
    #[doc(alias = "SCR")]
    pub type Scr = crate::Reg<scr::ScrSpec>;
    #[doc = "I2C State_Control"]
    pub mod scr {
        #[doc = "Register `SCR` reader"]
        pub type R = crate::R<ScrSpec>;
        #[doc = "Register `SCR` writer"]
        pub type W = crate::W<ScrSpec>;
        #[doc = "Field `Done` reader - transmit done.current transmit done, set this bit to 1.write 0 to clear"]
        pub type DoneR = crate::BitReader;
        #[doc = "Field `RX_ACK` reader - send mode, sent done, receive ack/nack. send done. receive ack,this bit is set to 1; nack, this bit is set to 0.write 0 to clear"]
        pub type RxAckR = crate::BitReader;
        #[doc = "Field `RX_ACK` writer - send mode, sent done, receive ack/nack. send done. receive ack,this bit is set to 1; nack, this bit is set to 0.write 0 to clear"]
        pub type RxAckW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "send/receive mode select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DataDir {
            #[doc = "0: receive mode"]
            Rx = 0,
            #[doc = "1: send mode"]
            Tx = 1,
        }
        impl From<DataDir> for bool {
            #[inline(always)]
            fn from(variant: DataDir) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DATA_DIR` reader - send/receive mode select"]
        pub type DataDirR = crate::BitReader<DataDir>;
        impl DataDirR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DataDir {
                match self.bits {
                    false => DataDir::Rx,
                    true => DataDir::Tx,
                }
            }
            #[doc = "receive mode"]
            #[inline(always)]
            pub fn is_rx(&self) -> bool {
                *self == DataDir::Rx
            }
            #[doc = "send mode"]
            #[inline(always)]
            pub fn is_tx(&self) -> bool {
                *self == DataDir::Tx
            }
        }
        #[doc = "Field `DATA_DIR` writer - send/receive mode select"]
        pub type DataDirW<'a, REG> = crate::BitWriter<'a, REG, DataDir>;
        impl<'a, REG> DataDirW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "receive mode"]
            #[inline(always)]
            pub fn rx(self) -> &'a mut crate::W<REG> {
                self.variant(DataDir::Rx)
            }
            #[doc = "send mode"]
            #[inline(always)]
            pub fn tx(self) -> &'a mut crate::W<REG> {
                self.variant(DataDir::Tx)
            }
        }
        #[doc = "Field `ADDR_DATA` reader - addr/data.receive is address data, set to 1; data set to 0. write 0 to clear"]
        pub type AddrDataR = crate::BitReader;
        #[doc = "Field `ADDR_DATA` writer - addr/data.receive is address data, set to 1; data set to 0. write 0 to clear"]
        pub type AddrDataW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BYTE_CMPLT` reader - receive mode, receive done, send ack/nack.receive done, this bit is set to 1 to send ack;set to 0 to send nack."]
        pub type ByteCmpltR = crate::BitReader;
        #[doc = "Field `BYTE_CMPLT` writer - receive mode, receive done, send ack/nack.receive done, this bit is set to 1 to send ack;set to 0 to send nack."]
        pub type ByteCmpltW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STOP_EVT` reader - i2c stop event happened.read out 1 means stop event happened, write 0 to clear"]
        pub type StopEvtR = crate::BitReader;
        #[doc = "Field `STOP_EVT` writer - i2c stop event happened.read out 1 means stop event happened, write 0 to clear"]
        pub type StopEvtW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LOST_ARB` reader - i2c master mode, lost control of bus.i2c master mode, lost control of bus,set this bit to 1.write 0 to clear"]
        pub type LostArbR = crate::BitReader;
        #[doc = "Field `STT_ERR` reader - i2c master mode, check out error start/stop.read out 1 means error start/stop happened, write 0 to clear"]
        pub type SttErrR = crate::BitReader;
        #[doc = "Field `STT_ERR` writer - i2c master mode, check out error start/stop.read out 1 means error start/stop happened, write 0 to clear"]
        pub type SttErrW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - transmit done.current transmit done, set this bit to 1.write 0 to clear"]
            #[inline(always)]
            pub fn done(&self) -> DoneR {
                DoneR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - send mode, sent done, receive ack/nack. send done. receive ack,this bit is set to 1; nack, this bit is set to 0.write 0 to clear"]
            #[inline(always)]
            pub fn rx_ack(&self) -> RxAckR {
                RxAckR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - send/receive mode select"]
            #[inline(always)]
            pub fn data_dir(&self) -> DataDirR {
                DataDirR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - addr/data.receive is address data, set to 1; data set to 0. write 0 to clear"]
            #[inline(always)]
            pub fn addr_data(&self) -> AddrDataR {
                AddrDataR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - receive mode, receive done, send ack/nack.receive done, this bit is set to 1 to send ack;set to 0 to send nack."]
            #[inline(always)]
            pub fn byte_cmplt(&self) -> ByteCmpltR {
                ByteCmpltR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - i2c stop event happened.read out 1 means stop event happened, write 0 to clear"]
            #[inline(always)]
            pub fn stop_evt(&self) -> StopEvtR {
                StopEvtR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - i2c master mode, lost control of bus.i2c master mode, lost control of bus,set this bit to 1.write 0 to clear"]
            #[inline(always)]
            pub fn lost_arb(&self) -> LostArbR {
                LostArbR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - i2c master mode, check out error start/stop.read out 1 means error start/stop happened, write 0 to clear"]
            #[inline(always)]
            pub fn stt_err(&self) -> SttErrR {
                SttErrR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - send mode, sent done, receive ack/nack. send done. receive ack,this bit is set to 1; nack, this bit is set to 0.write 0 to clear"]
            #[inline(always)]
            pub fn rx_ack(&mut self) -> RxAckW<ScrSpec> {
                RxAckW::new(self, 1)
            }
            #[doc = "Bit 2 - send/receive mode select"]
            #[inline(always)]
            pub fn data_dir(&mut self) -> DataDirW<ScrSpec> {
                DataDirW::new(self, 2)
            }
            #[doc = "Bit 3 - addr/data.receive is address data, set to 1; data set to 0. write 0 to clear"]
            #[inline(always)]
            pub fn addr_data(&mut self) -> AddrDataW<ScrSpec> {
                AddrDataW::new(self, 3)
            }
            #[doc = "Bit 4 - receive mode, receive done, send ack/nack.receive done, this bit is set to 1 to send ack;set to 0 to send nack."]
            #[inline(always)]
            pub fn byte_cmplt(&mut self) -> ByteCmpltW<ScrSpec> {
                ByteCmpltW::new(self, 4)
            }
            #[doc = "Bit 5 - i2c stop event happened.read out 1 means stop event happened, write 0 to clear"]
            #[inline(always)]
            pub fn stop_evt(&mut self) -> StopEvtW<ScrSpec> {
                StopEvtW::new(self, 5)
            }
            #[doc = "Bit 7 - i2c master mode, check out error start/stop.read out 1 means error start/stop happened, write 0 to clear"]
            #[inline(always)]
            pub fn stt_err(&mut self) -> SttErrW<ScrSpec> {
                SttErrW::new(self, 7)
            }
        }
        #[doc = "I2C State_Control\n\nYou can [`read`](crate::Reg::read) this register and get [`scr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ScrSpec;
        impl crate::RegisterSpec for ScrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`scr::R`](R) reader structure"]
        impl crate::Readable for ScrSpec {}
        #[doc = "`write(|w| ..)` method takes [`scr::W`](W) writer structure"]
        impl crate::Writable for ScrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SCR to value 0"]
        impl crate::Resettable for ScrSpec {}
    }
    #[doc = "DATA (rw) register accessor: I2C Data Regsiter\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@data`] module"]
    #[doc(alias = "DATA")]
    pub type Data = crate::Reg<data::DataSpec>;
    #[doc = "I2C Data Regsiter"]
    pub mod data {
        #[doc = "Register `DATA` reader"]
        pub type R = crate::R<DataSpec>;
        #[doc = "Register `DATA` writer"]
        pub type W = crate::W<DataSpec>;
        #[doc = "Field `DATA` reader - i2c data.send mode, write; receive mode, read"]
        pub type DataR = crate::FieldReader;
        #[doc = "Field `DATA` writer - i2c data.send mode, write; receive mode, read"]
        pub type DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - i2c data.send mode, write; receive mode, read"]
            #[inline(always)]
            pub fn data(&self) -> DataR {
                DataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - i2c data.send mode, write; receive mode, read"]
            #[inline(always)]
            pub fn data(&mut self) -> DataW<DataSpec> {
                DataW::new(self, 0)
            }
        }
        #[doc = "I2C Data Regsiter\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DataSpec;
        impl crate::RegisterSpec for DataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`data::R`](R) reader structure"]
        impl crate::Readable for DataSpec {}
        #[doc = "`write(|w| ..)` method takes [`data::W`](W) writer structure"]
        impl crate::Writable for DataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DATA to value 0"]
        impl crate::Resettable for DataSpec {}
    }
    #[doc = "MSCR (rw) register accessor: I2C Master State_Control\n\nYou can [`read`](crate::Reg::read) this register and get [`mscr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mscr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mscr`] module"]
    #[doc(alias = "MSCR")]
    pub type Mscr = crate::Reg<mscr::MscrSpec>;
    #[doc = "I2C Master State_Control"]
    pub mod mscr {
        #[doc = "Register `MSCR` reader"]
        pub type R = crate::R<MscrSpec>;
        #[doc = "Register `MSCR` writer"]
        pub type W = crate::W<MscrSpec>;
        #[doc = "Field `START` reader - i2c generates start signal.write 1 to generates start signal, self clear..read out current state"]
        pub type StartR = crate::BitReader;
        #[doc = "Field `START` writer - i2c generates start signal.write 1 to generates start signal, self clear..read out current state"]
        pub type StartW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RESTART` reader - i2c generates restart signal.write 1 to generates restart signal, self clear.read out current state"]
        pub type RestartR = crate::BitReader;
        #[doc = "Field `RESTART` writer - i2c generates restart signal.write 1 to generates restart signal, self clear.read out current state"]
        pub type RestartW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MST_CHECK` reader - i2c device master mode feedback.i2c sends start, set this bit to 1, sends stop set this bit to 0."]
        pub type MstCheckR = crate::BitReader;
        #[doc = "Field `BUSY` reader - i2c busy/idle.bust start, set to 1; bus stop, set to 0"]
        pub type BusyR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - i2c generates start signal.write 1 to generates start signal, self clear..read out current state"]
            #[inline(always)]
            pub fn start(&self) -> StartR {
                StartR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - i2c generates restart signal.write 1 to generates restart signal, self clear.read out current state"]
            #[inline(always)]
            pub fn restart(&self) -> RestartR {
                RestartR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - i2c device master mode feedback.i2c sends start, set this bit to 1, sends stop set this bit to 0."]
            #[inline(always)]
            pub fn mst_check(&self) -> MstCheckR {
                MstCheckR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - i2c busy/idle.bust start, set to 1; bus stop, set to 0"]
            #[inline(always)]
            pub fn busy(&self) -> BusyR {
                BusyR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - i2c generates start signal.write 1 to generates start signal, self clear..read out current state"]
            #[inline(always)]
            pub fn start(&mut self) -> StartW<MscrSpec> {
                StartW::new(self, 0)
            }
            #[doc = "Bit 1 - i2c generates restart signal.write 1 to generates restart signal, self clear.read out current state"]
            #[inline(always)]
            pub fn restart(&mut self) -> RestartW<MscrSpec> {
                RestartW::new(self, 1)
            }
        }
        #[doc = "I2C Master State_Control\n\nYou can [`read`](crate::Reg::read) this register and get [`mscr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mscr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct MscrSpec;
        impl crate::RegisterSpec for MscrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`mscr::R`](R) reader structure"]
        impl crate::Readable for MscrSpec {}
        #[doc = "`write(|w| ..)` method takes [`mscr::W`](W) writer structure"]
        impl crate::Writable for MscrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets MSCR to value 0"]
        impl crate::Resettable for MscrSpec {}
    }
    #[doc = "BCR (rw) register accessor: I2C Burst Control\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcr`] module"]
    #[doc(alias = "BCR")]
    pub type Bcr = crate::Reg<bcr::BcrSpec>;
    #[doc = "I2C Burst Control"]
    pub mod bcr {
        #[doc = "Register `BCR` reader"]
        pub type R = crate::R<BcrSpec>;
        #[doc = "Register `BCR` writer"]
        pub type W = crate::W<BcrSpec>;
        #[doc = "Slave DMA prefetch enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SlvDmaPref {
            #[doc = "0: disable slave prefetch"]
            Disabled = 0,
            #[doc = "1: enable slave prefetch"]
            Enabled = 1,
        }
        impl From<SlvDmaPref> for bool {
            #[inline(always)]
            fn from(variant: SlvDmaPref) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SLV_DMA_PREF` reader - Slave DMA prefetch enable"]
        pub type SlvDmaPrefR = crate::BitReader<SlvDmaPref>;
        impl SlvDmaPrefR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SlvDmaPref {
                match self.bits {
                    false => SlvDmaPref::Disabled,
                    true => SlvDmaPref::Enabled,
                }
            }
            #[doc = "disable slave prefetch"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SlvDmaPref::Disabled
            }
            #[doc = "enable slave prefetch"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SlvDmaPref::Enabled
            }
        }
        #[doc = "Field `SLV_DMA_PREF` writer - Slave DMA prefetch enable"]
        pub type SlvDmaPrefW<'a, REG> = crate::BitWriter<'a, REG, SlvDmaPref>;
        impl<'a, REG> SlvDmaPrefW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "disable slave prefetch"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(SlvDmaPref::Disabled)
            }
            #[doc = "enable slave prefetch"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(SlvDmaPref::Enabled)
            }
        }
        #[doc = "Burst Mode Control Bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BusrtEn {
            #[doc = "0: disable burst mode"]
            Disabled = 0,
            #[doc = "1: enable burst mode"]
            Enabled = 1,
        }
        impl From<BusrtEn> for bool {
            #[inline(always)]
            fn from(variant: BusrtEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BUSRT_EN` reader - Burst Mode Control Bit"]
        pub type BusrtEnR = crate::BitReader<BusrtEn>;
        impl BusrtEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BusrtEn {
                match self.bits {
                    false => BusrtEn::Disabled,
                    true => BusrtEn::Enabled,
                }
            }
            #[doc = "disable burst mode"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BusrtEn::Disabled
            }
            #[doc = "enable burst mode"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BusrtEn::Enabled
            }
        }
        #[doc = "Field `BUSRT_EN` writer - Burst Mode Control Bit"]
        pub type BusrtEnW<'a, REG> = crate::BitWriter<'a, REG, BusrtEn>;
        impl<'a, REG> BusrtEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "disable burst mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(BusrtEn::Disabled)
            }
            #[doc = "enable burst mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(BusrtEn::Enabled)
            }
        }
        #[doc = "address cmp by hardware, generate interrupt or not\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BurstAddrCmp {
            #[doc = "0: disable address compare by hardware in burst mode"]
            Disabled = 0,
            #[doc = "1: enable address compare by hardware in burst mode"]
            Enabled = 1,
        }
        impl From<BurstAddrCmp> for bool {
            #[inline(always)]
            fn from(variant: BurstAddrCmp) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BURST_ADDR_CMP` reader - address cmp by hardware, generate interrupt or not"]
        pub type BurstAddrCmpR = crate::BitReader<BurstAddrCmp>;
        impl BurstAddrCmpR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BurstAddrCmp {
                match self.bits {
                    false => BurstAddrCmp::Disabled,
                    true => BurstAddrCmp::Enabled,
                }
            }
            #[doc = "disable address compare by hardware in burst mode"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BurstAddrCmp::Disabled
            }
            #[doc = "enable address compare by hardware in burst mode"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BurstAddrCmp::Enabled
            }
        }
        #[doc = "Field `BURST_ADDR_CMP` writer - address cmp by hardware, generate interrupt or not"]
        pub type BurstAddrCmpW<'a, REG> = crate::BitWriter<'a, REG, BurstAddrCmp>;
        impl<'a, REG> BurstAddrCmpW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "disable address compare by hardware in burst mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(BurstAddrCmp::Disabled)
            }
            #[doc = "enable address compare by hardware in burst mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(BurstAddrCmp::Enabled)
            }
        }
        #[doc = "send mode, handle nack\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BurstNack {
            #[doc = "0: master is in send mode, return to stop. slave is in send mode, return to ilde"]
            Disabled = 0,
            #[doc = "1: generates nack interrupt, pulldown i2c clock bus."]
            Enabled = 1,
        }
        impl From<BurstNack> for bool {
            #[inline(always)]
            fn from(variant: BurstNack) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BURST_NACK` reader - send mode, handle nack"]
        pub type BurstNackR = crate::BitReader<BurstNack>;
        impl BurstNackR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BurstNack {
                match self.bits {
                    false => BurstNack::Disabled,
                    true => BurstNack::Enabled,
                }
            }
            #[doc = "master is in send mode, return to stop. slave is in send mode, return to ilde"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BurstNack::Disabled
            }
            #[doc = "generates nack interrupt, pulldown i2c clock bus."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BurstNack::Enabled
            }
        }
        #[doc = "Field `BURST_NACK` writer - send mode, handle nack"]
        pub type BurstNackW<'a, REG> = crate::BitWriter<'a, REG, BurstNack>;
        impl<'a, REG> BurstNackW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "master is in send mode, return to stop. slave is in send mode, return to ilde"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(BurstNack::Disabled)
            }
            #[doc = "generates nack interrupt, pulldown i2c clock bus."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(BurstNack::Enabled)
            }
        }
        impl R {
            #[doc = "Bit 4 - Slave DMA prefetch enable"]
            #[inline(always)]
            pub fn slv_dma_pref(&self) -> SlvDmaPrefR {
                SlvDmaPrefR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Burst Mode Control Bit"]
            #[inline(always)]
            pub fn busrt_en(&self) -> BusrtEnR {
                BusrtEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - address cmp by hardware, generate interrupt or not"]
            #[inline(always)]
            pub fn burst_addr_cmp(&self) -> BurstAddrCmpR {
                BurstAddrCmpR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - send mode, handle nack"]
            #[inline(always)]
            pub fn burst_nack(&self) -> BurstNackR {
                BurstNackR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 4 - Slave DMA prefetch enable"]
            #[inline(always)]
            pub fn slv_dma_pref(&mut self) -> SlvDmaPrefW<BcrSpec> {
                SlvDmaPrefW::new(self, 4)
            }
            #[doc = "Bit 5 - Burst Mode Control Bit"]
            #[inline(always)]
            pub fn busrt_en(&mut self) -> BusrtEnW<BcrSpec> {
                BusrtEnW::new(self, 5)
            }
            #[doc = "Bit 6 - address cmp by hardware, generate interrupt or not"]
            #[inline(always)]
            pub fn burst_addr_cmp(&mut self) -> BurstAddrCmpW<BcrSpec> {
                BurstAddrCmpW::new(self, 6)
            }
            #[doc = "Bit 7 - send mode, handle nack"]
            #[inline(always)]
            pub fn burst_nack(&mut self) -> BurstNackW<BcrSpec> {
                BurstNackW::new(self, 7)
            }
        }
        #[doc = "I2C Burst Control\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BcrSpec;
        impl crate::RegisterSpec for BcrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`bcr::R`](R) reader structure"]
        impl crate::Readable for BcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`bcr::W`](W) writer structure"]
        impl crate::Writable for BcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BCR to value 0"]
        impl crate::Resettable for BcrSpec {}
    }
    #[doc = "BSIZE (rw) register accessor: DMA Length\n\nYou can [`read`](crate::Reg::read) this register and get [`bsize::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsize::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsize`] module"]
    #[doc(alias = "BSIZE")]
    pub type Bsize = crate::Reg<bsize::BsizeSpec>;
    #[doc = "DMA Length"]
    pub mod bsize {
        #[doc = "Register `BSIZE` reader"]
        pub type R = crate::R<BsizeSpec>;
        #[doc = "Register `BSIZE` writer"]
        pub type W = crate::W<BsizeSpec>;
        #[doc = "Field `BURST_SIZE` reader - Burst Size"]
        pub type BurstSizeR = crate::FieldReader;
        #[doc = "Field `BURST_SIZE` writer - Burst Size"]
        pub type BurstSizeW<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl R {
            #[doc = "Bits 0:4 - Burst Size"]
            #[inline(always)]
            pub fn burst_size(&self) -> BurstSizeR {
                BurstSizeR::new(self.bits & 0x1f)
            }
        }
        impl W {
            #[doc = "Bits 0:4 - Burst Size"]
            #[inline(always)]
            pub fn burst_size(&mut self) -> BurstSizeW<BsizeSpec> {
                BurstSizeW::new(self, 0)
            }
        }
        #[doc = "DMA Length\n\nYou can [`read`](crate::Reg::read) this register and get [`bsize::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsize::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BsizeSpec;
        impl crate::RegisterSpec for BsizeSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`bsize::R`](R) reader structure"]
        impl crate::Readable for BsizeSpec {}
        #[doc = "`write(|w| ..)` method takes [`bsize::W`](W) writer structure"]
        impl crate::Writable for BsizeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BSIZE to value 0"]
        impl crate::Resettable for BsizeSpec {}
    }
}
#[doc = "CMP registers"]
pub type Cmp = crate::Periph<cmp::RegisterBlock, 0x4001_0200>;
impl core::fmt::Debug for Cmp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cmp").finish()
    }
}
#[doc = "CMP registers"]
pub mod cmp {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ie: Ie,
        _reserved1: [u8; 0x02],
        if_: If,
        _reserved2: [u8; 0x02],
        tclk: Tclk,
        _reserved3: [u8; 0x02],
        cfg: Cfg,
        _reserved4: [u8; 0x02],
        blcwin: Blcwin,
        _reserved5: [u8; 0x02],
        data: Data,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Comparator interrupt enable"]
        #[inline(always)]
        pub const fn ie(&self) -> &Ie {
            &self.ie
        }
        #[doc = "0x04 - Comparator interrupt flag"]
        #[inline(always)]
        pub const fn if_(&self) -> &If {
            &self.if_
        }
        #[doc = "0x08 - Comparator clock division control"]
        #[inline(always)]
        pub const fn tclk(&self) -> &Tclk {
            &self.tclk
        }
        #[doc = "0x0c - Comparator configuration"]
        #[inline(always)]
        pub const fn cfg(&self) -> &Cfg {
            &self.cfg
        }
        #[doc = "0x10 - Comparator black window control"]
        #[inline(always)]
        pub const fn blcwin(&self) -> &Blcwin {
            &self.blcwin
        }
        #[doc = "0x14 - Comparator data"]
        #[inline(always)]
        pub const fn data(&self) -> &Data {
            &self.data
        }
    }
    #[doc = "IE (rw) register accessor: Comparator interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie`] module"]
    #[doc(alias = "IE")]
    pub type Ie = crate::Reg<ie::IeSpec>;
    #[doc = "Comparator interrupt enable"]
    pub mod ie {
        #[doc = "Register `IE` reader"]
        pub type R = crate::R<IeSpec>;
        #[doc = "Register `IE` writer"]
        pub type W = crate::W<IeSpec>;
        #[doc = "Comparator 0 interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cmp0Ie {
            #[doc = "0: irq disabled"]
            Disabled = 0,
            #[doc = "1: irq enabled"]
            Enabled = 1,
        }
        impl From<Cmp0Ie> for bool {
            #[inline(always)]
            fn from(variant: Cmp0Ie) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP0_IE` reader - Comparator 0 interrupt enable"]
        pub type Cmp0IeR = crate::BitReader<Cmp0Ie>;
        impl Cmp0IeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp0Ie {
                match self.bits {
                    false => Cmp0Ie::Disabled,
                    true => Cmp0Ie::Enabled,
                }
            }
            #[doc = "irq disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Cmp0Ie::Disabled
            }
            #[doc = "irq enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Cmp0Ie::Enabled
            }
        }
        #[doc = "Field `CMP0_IE` writer - Comparator 0 interrupt enable"]
        pub type Cmp0IeW<'a, REG> = crate::BitWriter<'a, REG, Cmp0Ie>;
        impl<'a, REG> Cmp0IeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "irq disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Ie::Disabled)
            }
            #[doc = "irq enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Ie::Enabled)
            }
        }
        #[doc = "Comparator 1 interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cmp1Ie {
            #[doc = "0: irq disabled"]
            Disabled = 0,
            #[doc = "1: irq enabled"]
            Enabled = 1,
        }
        impl From<Cmp1Ie> for bool {
            #[inline(always)]
            fn from(variant: Cmp1Ie) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP1_IE` reader - Comparator 1 interrupt enable"]
        pub type Cmp1IeR = crate::BitReader<Cmp1Ie>;
        impl Cmp1IeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp1Ie {
                match self.bits {
                    false => Cmp1Ie::Disabled,
                    true => Cmp1Ie::Enabled,
                }
            }
            #[doc = "irq disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Cmp1Ie::Disabled
            }
            #[doc = "irq enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Cmp1Ie::Enabled
            }
        }
        #[doc = "Field `CMP1_IE` writer - Comparator 1 interrupt enable"]
        pub type Cmp1IeW<'a, REG> = crate::BitWriter<'a, REG, Cmp1Ie>;
        impl<'a, REG> Cmp1IeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "irq disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Ie::Disabled)
            }
            #[doc = "irq enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Ie::Enabled)
            }
        }
        #[doc = "Comparator 0 DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cmp0Re {
            #[doc = "0: Request disabled"]
            Disabled = 0,
            #[doc = "1: Request enabled"]
            Enabled = 1,
        }
        impl From<Cmp0Re> for bool {
            #[inline(always)]
            fn from(variant: Cmp0Re) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP0_RE` reader - Comparator 0 DMA request enable"]
        pub type Cmp0ReR = crate::BitReader<Cmp0Re>;
        impl Cmp0ReR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp0Re {
                match self.bits {
                    false => Cmp0Re::Disabled,
                    true => Cmp0Re::Enabled,
                }
            }
            #[doc = "Request disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Cmp0Re::Disabled
            }
            #[doc = "Request enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Cmp0Re::Enabled
            }
        }
        #[doc = "Field `CMP0_RE` writer - Comparator 0 DMA request enable"]
        pub type Cmp0ReW<'a, REG> = crate::BitWriter<'a, REG, Cmp0Re>;
        impl<'a, REG> Cmp0ReW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Re::Disabled)
            }
            #[doc = "Request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0Re::Enabled)
            }
        }
        #[doc = "Comparator 1 DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cmp1Re {
            #[doc = "0: Request disabled"]
            Disabled = 0,
            #[doc = "1: Request enabled"]
            Enabled = 1,
        }
        impl From<Cmp1Re> for bool {
            #[inline(always)]
            fn from(variant: Cmp1Re) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP1_RE` reader - Comparator 1 DMA request enable"]
        pub type Cmp1ReR = crate::BitReader<Cmp1Re>;
        impl Cmp1ReR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp1Re {
                match self.bits {
                    false => Cmp1Re::Disabled,
                    true => Cmp1Re::Enabled,
                }
            }
            #[doc = "Request disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Cmp1Re::Disabled
            }
            #[doc = "Request enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Cmp1Re::Enabled
            }
        }
        #[doc = "Field `CMP1_RE` writer - Comparator 1 DMA request enable"]
        pub type Cmp1ReW<'a, REG> = crate::BitWriter<'a, REG, Cmp1Re>;
        impl<'a, REG> Cmp1ReW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Re::Disabled)
            }
            #[doc = "Request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Re::Enabled)
            }
        }
        impl R {
            #[doc = "Bit 0 - Comparator 0 interrupt enable"]
            #[inline(always)]
            pub fn cmp0_ie(&self) -> Cmp0IeR {
                Cmp0IeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Comparator 1 interrupt enable"]
            #[inline(always)]
            pub fn cmp1_ie(&self) -> Cmp1IeR {
                Cmp1IeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Comparator 0 DMA request enable"]
            #[inline(always)]
            pub fn cmp0_re(&self) -> Cmp0ReR {
                Cmp0ReR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Comparator 1 DMA request enable"]
            #[inline(always)]
            pub fn cmp1_re(&self) -> Cmp1ReR {
                Cmp1ReR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Comparator 0 interrupt enable"]
            #[inline(always)]
            pub fn cmp0_ie(&mut self) -> Cmp0IeW<IeSpec> {
                Cmp0IeW::new(self, 0)
            }
            #[doc = "Bit 1 - Comparator 1 interrupt enable"]
            #[inline(always)]
            pub fn cmp1_ie(&mut self) -> Cmp1IeW<IeSpec> {
                Cmp1IeW::new(self, 1)
            }
            #[doc = "Bit 2 - Comparator 0 DMA request enable"]
            #[inline(always)]
            pub fn cmp0_re(&mut self) -> Cmp0ReW<IeSpec> {
                Cmp0ReW::new(self, 2)
            }
            #[doc = "Bit 3 - Comparator 1 DMA request enable"]
            #[inline(always)]
            pub fn cmp1_re(&mut self) -> Cmp1ReW<IeSpec> {
                Cmp1ReW::new(self, 3)
            }
        }
        #[doc = "Comparator interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IeSpec;
        impl crate::RegisterSpec for IeSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`ie::R`](R) reader structure"]
        impl crate::Readable for IeSpec {}
        #[doc = "`write(|w| ..)` method takes [`ie::W`](W) writer structure"]
        impl crate::Writable for IeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE to value 0"]
        impl crate::Resettable for IeSpec {}
    }
    #[doc = "IF (rw) register accessor: Comparator interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@if_`] module"]
    #[doc(alias = "IF")]
    pub type If = crate::Reg<if_::IfSpec>;
    #[doc = "Comparator interrupt flag"]
    pub mod if_ {
        #[doc = "Register `IF` reader"]
        pub type R = crate::R<IfSpec>;
        #[doc = "Register `IF` writer"]
        pub type W = crate::W<IfSpec>;
        #[doc = "Field `CMP0_IF` reader - Comparator 0 interrupt flag, write 1 to clear"]
        pub type Cmp0IfR = crate::BitReader;
        #[doc = "Field `CMP0_IF` writer - Comparator 0 interrupt flag, write 1 to clear"]
        pub type Cmp0IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP1_IF` reader - Comparator 1 interrupt flag, write 1 to clear"]
        pub type Cmp1IfR = crate::BitReader;
        #[doc = "Field `CMP1_IF` writer - Comparator 1 interrupt flag, write 1 to clear"]
        pub type Cmp1IfW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Comparator 0 interrupt flag, write 1 to clear"]
            #[inline(always)]
            pub fn cmp0_if(&self) -> Cmp0IfR {
                Cmp0IfR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Comparator 1 interrupt flag, write 1 to clear"]
            #[inline(always)]
            pub fn cmp1_if(&self) -> Cmp1IfR {
                Cmp1IfR::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Comparator 0 interrupt flag, write 1 to clear"]
            #[inline(always)]
            pub fn cmp0_if(&mut self) -> Cmp0IfW<IfSpec> {
                Cmp0IfW::new(self, 0)
            }
            #[doc = "Bit 1 - Comparator 1 interrupt flag, write 1 to clear"]
            #[inline(always)]
            pub fn cmp1_if(&mut self) -> Cmp1IfW<IfSpec> {
                Cmp1IfW::new(self, 1)
            }
        }
        #[doc = "Comparator interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IfSpec;
        impl crate::RegisterSpec for IfSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`if_::R`](R) reader structure"]
        impl crate::Readable for IfSpec {}
        #[doc = "`write(|w| ..)` method takes [`if_::W`](W) writer structure"]
        impl crate::Writable for IfSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IF to value 0"]
        impl crate::Resettable for IfSpec {}
    }
    #[doc = "TCLK (rw) register accessor: Comparator clock division control\n\nYou can [`read`](crate::Reg::read) this register and get [`tclk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tclk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tclk`] module"]
    #[doc(alias = "TCLK")]
    pub type Tclk = crate::Reg<tclk::TclkSpec>;
    #[doc = "Comparator clock division control"]
    pub mod tclk {
        #[doc = "Register `TCLK` reader"]
        pub type R = crate::R<TclkSpec>;
        #[doc = "Register `TCLK` writer"]
        pub type W = crate::W<TclkSpec>;
        #[doc = "Comparator 1/0 filter clock divided by 2^n\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FilClk10Div2 {
            #[doc = "0: no division"]
            _1div = 0,
            #[doc = "1: 1/2 division"]
            _2div = 1,
            #[doc = "2: 1/4 division"]
            _4div = 2,
            #[doc = "3: 1/8 division"]
            _8div = 3,
            #[doc = "4: 1/16 division"]
            _16div = 4,
            #[doc = "5: 1/32 division"]
            _32div = 5,
            #[doc = "6: 1/64 division"]
            _64div = 6,
            #[doc = "7: 1/128 division"]
            _128div = 7,
        }
        impl From<FilClk10Div2> for u8 {
            #[inline(always)]
            fn from(variant: FilClk10Div2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FilClk10Div2 {
            type Ux = u8;
        }
        impl crate::IsEnum for FilClk10Div2 {}
        #[doc = "Field `FIL_CLK10_DIV2` reader - Comparator 1/0 filter clock divided by 2^n"]
        pub type FilClk10Div2R = crate::FieldReader<FilClk10Div2>;
        impl FilClk10Div2R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FilClk10Div2 {
                match self.bits {
                    0 => FilClk10Div2::_1div,
                    1 => FilClk10Div2::_2div,
                    2 => FilClk10Div2::_4div,
                    3 => FilClk10Div2::_8div,
                    4 => FilClk10Div2::_16div,
                    5 => FilClk10Div2::_32div,
                    6 => FilClk10Div2::_64div,
                    7 => FilClk10Div2::_128div,
                    _ => unreachable!(),
                }
            }
            #[doc = "no division"]
            #[inline(always)]
            pub fn is_1div(&self) -> bool {
                *self == FilClk10Div2::_1div
            }
            #[doc = "1/2 division"]
            #[inline(always)]
            pub fn is_2div(&self) -> bool {
                *self == FilClk10Div2::_2div
            }
            #[doc = "1/4 division"]
            #[inline(always)]
            pub fn is_4div(&self) -> bool {
                *self == FilClk10Div2::_4div
            }
            #[doc = "1/8 division"]
            #[inline(always)]
            pub fn is_8div(&self) -> bool {
                *self == FilClk10Div2::_8div
            }
            #[doc = "1/16 division"]
            #[inline(always)]
            pub fn is_16div(&self) -> bool {
                *self == FilClk10Div2::_16div
            }
            #[doc = "1/32 division"]
            #[inline(always)]
            pub fn is_32div(&self) -> bool {
                *self == FilClk10Div2::_32div
            }
            #[doc = "1/64 division"]
            #[inline(always)]
            pub fn is_64div(&self) -> bool {
                *self == FilClk10Div2::_64div
            }
            #[doc = "1/128 division"]
            #[inline(always)]
            pub fn is_128div(&self) -> bool {
                *self == FilClk10Div2::_128div
            }
        }
        #[doc = "Field `FIL_CLK10_DIV2` writer - Comparator 1/0 filter clock divided by 2^n"]
        pub type FilClk10Div2W<'a, REG> = crate::FieldWriter<'a, REG, 3, FilClk10Div2, crate::Safe>;
        impl<'a, REG> FilClk10Div2W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "no division"]
            #[inline(always)]
            pub fn _1div(self) -> &'a mut crate::W<REG> {
                self.variant(FilClk10Div2::_1div)
            }
            #[doc = "1/2 division"]
            #[inline(always)]
            pub fn _2div(self) -> &'a mut crate::W<REG> {
                self.variant(FilClk10Div2::_2div)
            }
            #[doc = "1/4 division"]
            #[inline(always)]
            pub fn _4div(self) -> &'a mut crate::W<REG> {
                self.variant(FilClk10Div2::_4div)
            }
            #[doc = "1/8 division"]
            #[inline(always)]
            pub fn _8div(self) -> &'a mut crate::W<REG> {
                self.variant(FilClk10Div2::_8div)
            }
            #[doc = "1/16 division"]
            #[inline(always)]
            pub fn _16div(self) -> &'a mut crate::W<REG> {
                self.variant(FilClk10Div2::_16div)
            }
            #[doc = "1/32 division"]
            #[inline(always)]
            pub fn _32div(self) -> &'a mut crate::W<REG> {
                self.variant(FilClk10Div2::_32div)
            }
            #[doc = "1/64 division"]
            #[inline(always)]
            pub fn _64div(self) -> &'a mut crate::W<REG> {
                self.variant(FilClk10Div2::_64div)
            }
            #[doc = "1/128 division"]
            #[inline(always)]
            pub fn _128div(self) -> &'a mut crate::W<REG> {
                self.variant(FilClk10Div2::_128div)
            }
        }
        #[doc = "Field `CLK10_EN` reader - filter clock enable"]
        pub type Clk10EnR = crate::BitReader;
        #[doc = "Field `CLK10_EN` writer - filter clock enable"]
        pub type Clk10EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FIL_CLK10_DIV16` reader - Comparator 1/0 filter clock divided by 1~16"]
        pub type FilClk10Div16R = crate::FieldReader;
        #[doc = "Field `FIL_CLK10_DIV16` writer - Comparator 1/0 filter clock divided by 1~16"]
        pub type FilClk10Div16W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:2 - Comparator 1/0 filter clock divided by 2^n"]
            #[inline(always)]
            pub fn fil_clk10_div2(&self) -> FilClk10Div2R {
                FilClk10Div2R::new((self.bits & 7) as u8)
            }
            #[doc = "Bit 3 - filter clock enable"]
            #[inline(always)]
            pub fn clk10_en(&self) -> Clk10EnR {
                Clk10EnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:7 - Comparator 1/0 filter clock divided by 1~16"]
            #[inline(always)]
            pub fn fil_clk10_div16(&self) -> FilClk10Div16R {
                FilClk10Div16R::new(((self.bits >> 4) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Comparator 1/0 filter clock divided by 2^n"]
            #[inline(always)]
            pub fn fil_clk10_div2(&mut self) -> FilClk10Div2W<TclkSpec> {
                FilClk10Div2W::new(self, 0)
            }
            #[doc = "Bit 3 - filter clock enable"]
            #[inline(always)]
            pub fn clk10_en(&mut self) -> Clk10EnW<TclkSpec> {
                Clk10EnW::new(self, 3)
            }
            #[doc = "Bits 4:7 - Comparator 1/0 filter clock divided by 1~16"]
            #[inline(always)]
            pub fn fil_clk10_div16(&mut self) -> FilClk10Div16W<TclkSpec> {
                FilClk10Div16W::new(self, 4)
            }
        }
        #[doc = "Comparator clock division control\n\nYou can [`read`](crate::Reg::read) this register and get [`tclk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tclk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TclkSpec;
        impl crate::RegisterSpec for TclkSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`tclk::R`](R) reader structure"]
        impl crate::Readable for TclkSpec {}
        #[doc = "`write(|w| ..)` method takes [`tclk::W`](W) writer structure"]
        impl crate::Writable for TclkSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TCLK to value 0"]
        impl crate::Resettable for TclkSpec {}
    }
    #[doc = "CFG (rw) register accessor: Comparator configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"]
    #[doc(alias = "CFG")]
    pub type Cfg = crate::Reg<cfg::CfgSpec>;
    #[doc = "Comparator configuration"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CfgSpec>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CfgSpec>;
        #[doc = "Field `CMP0_POL` reader - Comparator 0 polarity"]
        pub type Cmp0PolR = crate::BitReader;
        #[doc = "Field `CMP0_POL` writer - Comparator 0 polarity"]
        pub type Cmp0PolW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP0_IN_EN` reader - Comparator 0 input enable"]
        pub type Cmp0InEnR = crate::BitReader;
        #[doc = "Field `CMP0_IN_EN` writer - Comparator 0 input enable"]
        pub type Cmp0InEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Comparator 0 irq trigger mechanism\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cmp0IrqTrig {
            #[doc = "0: Level trigger"]
            LevelTrig = 0,
            #[doc = "1: Edge trigger"]
            EdgeTrig = 1,
        }
        impl From<Cmp0IrqTrig> for bool {
            #[inline(always)]
            fn from(variant: Cmp0IrqTrig) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP0_IRQ_TRIG` reader - Comparator 0 irq trigger mechanism"]
        pub type Cmp0IrqTrigR = crate::BitReader<Cmp0IrqTrig>;
        impl Cmp0IrqTrigR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp0IrqTrig {
                match self.bits {
                    false => Cmp0IrqTrig::LevelTrig,
                    true => Cmp0IrqTrig::EdgeTrig,
                }
            }
            #[doc = "Level trigger"]
            #[inline(always)]
            pub fn is_level_trig(&self) -> bool {
                *self == Cmp0IrqTrig::LevelTrig
            }
            #[doc = "Edge trigger"]
            #[inline(always)]
            pub fn is_edge_trig(&self) -> bool {
                *self == Cmp0IrqTrig::EdgeTrig
            }
        }
        #[doc = "Field `CMP0_IRQ_TRIG` writer - Comparator 0 irq trigger mechanism"]
        pub type Cmp0IrqTrigW<'a, REG> = crate::BitWriter<'a, REG, Cmp0IrqTrig>;
        impl<'a, REG> Cmp0IrqTrigW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Level trigger"]
            #[inline(always)]
            pub fn level_trig(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0IrqTrig::LevelTrig)
            }
            #[doc = "Edge trigger"]
            #[inline(always)]
            pub fn edge_trig(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp0IrqTrig::EdgeTrig)
            }
        }
        #[doc = "Field `CMP0_W_PWM_POL` reader - PWM signal polarity when used as Comparator 0 opening window contorl signal"]
        pub type Cmp0WPwmPolR = crate::BitReader;
        #[doc = "Field `CMP0_W_PWM_POL` writer - PWM signal polarity when used as Comparator 0 opening window contorl signal"]
        pub type Cmp0WPwmPolW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Comparator 1 polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cmp1Pol {
            #[doc = "0: high level effective"]
            High = 0,
            #[doc = "1: low level effective"]
            Low = 1,
        }
        impl From<Cmp1Pol> for bool {
            #[inline(always)]
            fn from(variant: Cmp1Pol) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP1_POL` reader - Comparator 1 polarity"]
        pub type Cmp1PolR = crate::BitReader<Cmp1Pol>;
        impl Cmp1PolR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp1Pol {
                match self.bits {
                    false => Cmp1Pol::High,
                    true => Cmp1Pol::Low,
                }
            }
            #[doc = "high level effective"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == Cmp1Pol::High
            }
            #[doc = "low level effective"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == Cmp1Pol::Low
            }
        }
        #[doc = "Field `CMP1_POL` writer - Comparator 1 polarity"]
        pub type Cmp1PolW<'a, REG> = crate::BitWriter<'a, REG, Cmp1Pol>;
        impl<'a, REG> Cmp1PolW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "high level effective"]
            #[inline(always)]
            pub fn high(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Pol::High)
            }
            #[doc = "low level effective"]
            #[inline(always)]
            pub fn low(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1Pol::Low)
            }
        }
        #[doc = "Field `CMP1_IN_EN` reader - Comparator 1 input enable"]
        pub type Cmp1InEnR = crate::BitReader;
        #[doc = "Field `CMP1_IN_EN` writer - Comparator 1 input enable"]
        pub type Cmp1InEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Comparator 1 irq trigger mechanism\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cmp1IrqTrig {
            #[doc = "0: Level trigger"]
            LevelTrig = 0,
            #[doc = "1: Edge trigger"]
            EdgeTrig = 1,
        }
        impl From<Cmp1IrqTrig> for bool {
            #[inline(always)]
            fn from(variant: Cmp1IrqTrig) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMP1_IRQ_TRIG` reader - Comparator 1 irq trigger mechanism"]
        pub type Cmp1IrqTrigR = crate::BitReader<Cmp1IrqTrig>;
        impl Cmp1IrqTrigR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmp1IrqTrig {
                match self.bits {
                    false => Cmp1IrqTrig::LevelTrig,
                    true => Cmp1IrqTrig::EdgeTrig,
                }
            }
            #[doc = "Level trigger"]
            #[inline(always)]
            pub fn is_level_trig(&self) -> bool {
                *self == Cmp1IrqTrig::LevelTrig
            }
            #[doc = "Edge trigger"]
            #[inline(always)]
            pub fn is_edge_trig(&self) -> bool {
                *self == Cmp1IrqTrig::EdgeTrig
            }
        }
        #[doc = "Field `CMP1_IRQ_TRIG` writer - Comparator 1 irq trigger mechanism"]
        pub type Cmp1IrqTrigW<'a, REG> = crate::BitWriter<'a, REG, Cmp1IrqTrig>;
        impl<'a, REG> Cmp1IrqTrigW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Level trigger"]
            #[inline(always)]
            pub fn level_trig(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1IrqTrig::LevelTrig)
            }
            #[doc = "Edge trigger"]
            #[inline(always)]
            pub fn edge_trig(self) -> &'a mut crate::W<REG> {
                self.variant(Cmp1IrqTrig::EdgeTrig)
            }
        }
        #[doc = "Field `CMP1_W_PWM_POL` reader - PWM signal polarity when used as Comparator 1 opening window contorl signal"]
        pub type Cmp1WPwmPolR = crate::BitReader;
        #[doc = "Field `CMP1_W_PWM_POL` writer - PWM signal polarity when used as Comparator 1 opening window contorl signal"]
        pub type Cmp1WPwmPolW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Comparator 0 polarity"]
            #[inline(always)]
            pub fn cmp0_pol(&self) -> Cmp0PolR {
                Cmp0PolR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Comparator 0 input enable"]
            #[inline(always)]
            pub fn cmp0_in_en(&self) -> Cmp0InEnR {
                Cmp0InEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Comparator 0 irq trigger mechanism"]
            #[inline(always)]
            pub fn cmp0_irq_trig(&self) -> Cmp0IrqTrigR {
                Cmp0IrqTrigR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - PWM signal polarity when used as Comparator 0 opening window contorl signal"]
            #[inline(always)]
            pub fn cmp0_w_pwm_pol(&self) -> Cmp0WPwmPolR {
                Cmp0WPwmPolR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Comparator 1 polarity"]
            #[inline(always)]
            pub fn cmp1_pol(&self) -> Cmp1PolR {
                Cmp1PolR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Comparator 1 input enable"]
            #[inline(always)]
            pub fn cmp1_in_en(&self) -> Cmp1InEnR {
                Cmp1InEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Comparator 1 irq trigger mechanism"]
            #[inline(always)]
            pub fn cmp1_irq_trig(&self) -> Cmp1IrqTrigR {
                Cmp1IrqTrigR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - PWM signal polarity when used as Comparator 1 opening window contorl signal"]
            #[inline(always)]
            pub fn cmp1_w_pwm_pol(&self) -> Cmp1WPwmPolR {
                Cmp1WPwmPolR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Comparator 0 polarity"]
            #[inline(always)]
            pub fn cmp0_pol(&mut self) -> Cmp0PolW<CfgSpec> {
                Cmp0PolW::new(self, 0)
            }
            #[doc = "Bit 1 - Comparator 0 input enable"]
            #[inline(always)]
            pub fn cmp0_in_en(&mut self) -> Cmp0InEnW<CfgSpec> {
                Cmp0InEnW::new(self, 1)
            }
            #[doc = "Bit 2 - Comparator 0 irq trigger mechanism"]
            #[inline(always)]
            pub fn cmp0_irq_trig(&mut self) -> Cmp0IrqTrigW<CfgSpec> {
                Cmp0IrqTrigW::new(self, 2)
            }
            #[doc = "Bit 3 - PWM signal polarity when used as Comparator 0 opening window contorl signal"]
            #[inline(always)]
            pub fn cmp0_w_pwm_pol(&mut self) -> Cmp0WPwmPolW<CfgSpec> {
                Cmp0WPwmPolW::new(self, 3)
            }
            #[doc = "Bit 4 - Comparator 1 polarity"]
            #[inline(always)]
            pub fn cmp1_pol(&mut self) -> Cmp1PolW<CfgSpec> {
                Cmp1PolW::new(self, 4)
            }
            #[doc = "Bit 5 - Comparator 1 input enable"]
            #[inline(always)]
            pub fn cmp1_in_en(&mut self) -> Cmp1InEnW<CfgSpec> {
                Cmp1InEnW::new(self, 5)
            }
            #[doc = "Bit 6 - Comparator 1 irq trigger mechanism"]
            #[inline(always)]
            pub fn cmp1_irq_trig(&mut self) -> Cmp1IrqTrigW<CfgSpec> {
                Cmp1IrqTrigW::new(self, 6)
            }
            #[doc = "Bit 7 - PWM signal polarity when used as Comparator 1 opening window contorl signal"]
            #[inline(always)]
            pub fn cmp1_w_pwm_pol(&mut self) -> Cmp1WPwmPolW<CfgSpec> {
                Cmp1WPwmPolW::new(self, 7)
            }
        }
        #[doc = "Comparator configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgSpec;
        impl crate::RegisterSpec for CfgSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFG to value 0"]
        impl crate::Resettable for CfgSpec {}
    }
    #[doc = "BLCWIN (rw) register accessor: Comparator black window control\n\nYou can [`read`](crate::Reg::read) this register and get [`blcwin::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`blcwin::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@blcwin`] module"]
    #[doc(alias = "BLCWIN")]
    pub type Blcwin = crate::Reg<blcwin::BlcwinSpec>;
    #[doc = "Comparator black window control"]
    pub mod blcwin {
        #[doc = "Register `BLCWIN` reader"]
        pub type R = crate::R<BlcwinSpec>;
        #[doc = "Register `BLCWIN` writer"]
        pub type W = crate::W<BlcwinSpec>;
        #[doc = "Field `CMP0_CHN0P_WIN_EN` reader - Comparator 0 black window controled by CHN0P enable"]
        pub type Cmp0Chn0pWinEnR = crate::BitReader;
        #[doc = "Field `CMP0_CHN0P_WIN_EN` writer - Comparator 0 black window controled by CHN0P enable"]
        pub type Cmp0Chn0pWinEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP0_CHN1P_WIN_EN` reader - Comparator 0 black window controled by CHN1P enable"]
        pub type Cmp0Chn1pWinEnR = crate::BitReader;
        #[doc = "Field `CMP0_CHN1P_WIN_EN` writer - Comparator 0 black window controled by CHN1P enable"]
        pub type Cmp0Chn1pWinEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP0_CHN2P_WIN_EN` reader - Comparator 0 black window controled by CHN2P enable"]
        pub type Cmp0Chn2pWinEnR = crate::BitReader;
        #[doc = "Field `CMP0_CHN2P_WIN_EN` writer - Comparator 0 black window controled by CHN2P enable"]
        pub type Cmp0Chn2pWinEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP0_CHN3P_WIN_EN` reader - Comparator 0 black window controled by CHN3P enable"]
        pub type Cmp0Chn3pWinEnR = crate::BitReader;
        #[doc = "Field `CMP0_CHN3P_WIN_EN` writer - Comparator 0 black window controled by CHN3P enable"]
        pub type Cmp0Chn3pWinEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP1_CHN0P_WIN_EN` reader - Comparator 1 black window controled by CHN0P enable"]
        pub type Cmp1Chn0pWinEnR = crate::BitReader;
        #[doc = "Field `CMP1_CHN0P_WIN_EN` writer - Comparator 1 black window controled by CHN0P enable"]
        pub type Cmp1Chn0pWinEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP1_CHN1P_WIN_EN` reader - Comparator 1 black window controled by CHN1P enable"]
        pub type Cmp1Chn1pWinEnR = crate::BitReader;
        #[doc = "Field `CMP1_CHN1P_WIN_EN` writer - Comparator 1 black window controled by CHN1P enable"]
        pub type Cmp1Chn1pWinEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP1_CHN2P_WIN_EN` reader - Comparator 1 black window controled by CHN2P enable"]
        pub type Cmp1Chn2pWinEnR = crate::BitReader;
        #[doc = "Field `CMP1_CHN2P_WIN_EN` writer - Comparator 1 black window controled by CHN2P enable"]
        pub type Cmp1Chn2pWinEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP1_CHN3P_WIN_EN` reader - Comparator 1 black window controled by CHN3P enable"]
        pub type Cmp1Chn3pWinEnR = crate::BitReader;
        #[doc = "Field `CMP1_CHN3P_WIN_EN` writer - Comparator 1 black window controled by CHN3P enable"]
        pub type Cmp1Chn3pWinEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Comparator 0 black window controled by CHN0P enable"]
            #[inline(always)]
            pub fn cmp0_chn0p_win_en(&self) -> Cmp0Chn0pWinEnR {
                Cmp0Chn0pWinEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Comparator 0 black window controled by CHN1P enable"]
            #[inline(always)]
            pub fn cmp0_chn1p_win_en(&self) -> Cmp0Chn1pWinEnR {
                Cmp0Chn1pWinEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Comparator 0 black window controled by CHN2P enable"]
            #[inline(always)]
            pub fn cmp0_chn2p_win_en(&self) -> Cmp0Chn2pWinEnR {
                Cmp0Chn2pWinEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Comparator 0 black window controled by CHN3P enable"]
            #[inline(always)]
            pub fn cmp0_chn3p_win_en(&self) -> Cmp0Chn3pWinEnR {
                Cmp0Chn3pWinEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Comparator 1 black window controled by CHN0P enable"]
            #[inline(always)]
            pub fn cmp1_chn0p_win_en(&self) -> Cmp1Chn0pWinEnR {
                Cmp1Chn0pWinEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Comparator 1 black window controled by CHN1P enable"]
            #[inline(always)]
            pub fn cmp1_chn1p_win_en(&self) -> Cmp1Chn1pWinEnR {
                Cmp1Chn1pWinEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Comparator 1 black window controled by CHN2P enable"]
            #[inline(always)]
            pub fn cmp1_chn2p_win_en(&self) -> Cmp1Chn2pWinEnR {
                Cmp1Chn2pWinEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Comparator 1 black window controled by CHN3P enable"]
            #[inline(always)]
            pub fn cmp1_chn3p_win_en(&self) -> Cmp1Chn3pWinEnR {
                Cmp1Chn3pWinEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Comparator 0 black window controled by CHN0P enable"]
            #[inline(always)]
            pub fn cmp0_chn0p_win_en(&mut self) -> Cmp0Chn0pWinEnW<BlcwinSpec> {
                Cmp0Chn0pWinEnW::new(self, 0)
            }
            #[doc = "Bit 1 - Comparator 0 black window controled by CHN1P enable"]
            #[inline(always)]
            pub fn cmp0_chn1p_win_en(&mut self) -> Cmp0Chn1pWinEnW<BlcwinSpec> {
                Cmp0Chn1pWinEnW::new(self, 1)
            }
            #[doc = "Bit 2 - Comparator 0 black window controled by CHN2P enable"]
            #[inline(always)]
            pub fn cmp0_chn2p_win_en(&mut self) -> Cmp0Chn2pWinEnW<BlcwinSpec> {
                Cmp0Chn2pWinEnW::new(self, 2)
            }
            #[doc = "Bit 3 - Comparator 0 black window controled by CHN3P enable"]
            #[inline(always)]
            pub fn cmp0_chn3p_win_en(&mut self) -> Cmp0Chn3pWinEnW<BlcwinSpec> {
                Cmp0Chn3pWinEnW::new(self, 3)
            }
            #[doc = "Bit 4 - Comparator 1 black window controled by CHN0P enable"]
            #[inline(always)]
            pub fn cmp1_chn0p_win_en(&mut self) -> Cmp1Chn0pWinEnW<BlcwinSpec> {
                Cmp1Chn0pWinEnW::new(self, 4)
            }
            #[doc = "Bit 5 - Comparator 1 black window controled by CHN1P enable"]
            #[inline(always)]
            pub fn cmp1_chn1p_win_en(&mut self) -> Cmp1Chn1pWinEnW<BlcwinSpec> {
                Cmp1Chn1pWinEnW::new(self, 5)
            }
            #[doc = "Bit 6 - Comparator 1 black window controled by CHN2P enable"]
            #[inline(always)]
            pub fn cmp1_chn2p_win_en(&mut self) -> Cmp1Chn2pWinEnW<BlcwinSpec> {
                Cmp1Chn2pWinEnW::new(self, 6)
            }
            #[doc = "Bit 7 - Comparator 1 black window controled by CHN3P enable"]
            #[inline(always)]
            pub fn cmp1_chn3p_win_en(&mut self) -> Cmp1Chn3pWinEnW<BlcwinSpec> {
                Cmp1Chn3pWinEnW::new(self, 7)
            }
        }
        #[doc = "Comparator black window control\n\nYou can [`read`](crate::Reg::read) this register and get [`blcwin::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`blcwin::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BlcwinSpec;
        impl crate::RegisterSpec for BlcwinSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`blcwin::R`](R) reader structure"]
        impl crate::Readable for BlcwinSpec {}
        #[doc = "`write(|w| ..)` method takes [`blcwin::W`](W) writer structure"]
        impl crate::Writable for BlcwinSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BLCWIN to value 0"]
        impl crate::Resettable for BlcwinSpec {}
    }
    #[doc = "DATA (r) register accessor: Comparator data\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@data`] module"]
    #[doc(alias = "DATA")]
    pub type Data = crate::Reg<data::DataSpec>;
    #[doc = "Comparator data"]
    pub mod data {
        #[doc = "Register `DATA` reader"]
        pub type R = crate::R<DataSpec>;
        #[doc = "Field `CMP0_RAW_DATA` reader - Comparator 0 raw data"]
        pub type Cmp0RawDataR = crate::BitReader;
        #[doc = "Field `CMP1_RAW_DATA` reader - Comparator 1 raw data"]
        pub type Cmp1RawDataR = crate::BitReader;
        #[doc = "Field `CMP0_FLT_DATA` reader - Comparator 0 data after filter"]
        pub type Cmp0FltDataR = crate::BitReader;
        #[doc = "Field `CMP1_FLT_DATA` reader - Comparator 1 data after filter"]
        pub type Cmp1FltDataR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Comparator 0 raw data"]
            #[inline(always)]
            pub fn cmp0_raw_data(&self) -> Cmp0RawDataR {
                Cmp0RawDataR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Comparator 1 raw data"]
            #[inline(always)]
            pub fn cmp1_raw_data(&self) -> Cmp1RawDataR {
                Cmp1RawDataR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 8 - Comparator 0 data after filter"]
            #[inline(always)]
            pub fn cmp0_flt_data(&self) -> Cmp0FltDataR {
                Cmp0FltDataR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Comparator 1 data after filter"]
            #[inline(always)]
            pub fn cmp1_flt_data(&self) -> Cmp1FltDataR {
                Cmp1FltDataR::new(((self.bits >> 9) & 1) != 0)
            }
        }
        #[doc = "Comparator data\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DataSpec;
        impl crate::RegisterSpec for DataSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`data::R`](R) reader structure"]
        impl crate::Readable for DataSpec {}
        #[doc = "`reset()` method sets DATA to value 0"]
        impl crate::Resettable for DataSpec {}
    }
}
#[doc = "HALL registers"]
pub type Hall = crate::Periph<hall::RegisterBlock, 0x4001_0300>;
impl core::fmt::Debug for Hall {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hall").finish()
    }
}
#[doc = "HALL registers"]
pub mod hall {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        cfg: Cfg,
        info: Info,
        width: Width,
        th: Th,
        cnt: Cnt,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Hall Configuration Register"]
        #[inline(always)]
        pub const fn cfg(&self) -> &Cfg {
            &self.cfg
        }
        #[doc = "0x04 - Hall Information register"]
        #[inline(always)]
        pub const fn info(&self) -> &Info {
            &self.info
        }
        #[doc = "0x08 - Hall Width Register"]
        #[inline(always)]
        pub const fn width(&self) -> &Width {
            &self.width
        }
        #[doc = "0x0c - Hall Threshold Register"]
        #[inline(always)]
        pub const fn th(&self) -> &Th {
            &self.th
        }
        #[doc = "0x10 - Hall Counter Register"]
        #[inline(always)]
        pub const fn cnt(&self) -> &Cnt {
            &self.cnt
        }
    }
    #[doc = "CFG (rw) register accessor: Hall Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"]
    #[doc(alias = "CFG")]
    pub type Cfg = crate::Reg<cfg::CfgSpec>;
    #[doc = "Hall Configuration Register"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CfgSpec>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CfgSpec>;
        #[doc = "Field `FIL_LEN` reader - hall signal second filter:filter length control bits. Filter length from 1 to 32768"]
        pub type FilLenR = crate::FieldReader<u16>;
        #[doc = "Field `FIL_LEN` writer - hall signal second filter:filter length control bits. Filter length from 1 to 32768"]
        pub type FilLenW<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        #[doc = "hall clock frequency divider\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ClkDiv {
            #[doc = "0: Divide 1"]
            Div1 = 0,
            #[doc = "1: Divide 2"]
            Div2 = 1,
            #[doc = "2: Divide 4"]
            Div4 = 2,
            #[doc = "3: Divide 8"]
            Div8 = 3,
        }
        impl From<ClkDiv> for u8 {
            #[inline(always)]
            fn from(variant: ClkDiv) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ClkDiv {
            type Ux = u8;
        }
        impl crate::IsEnum for ClkDiv {}
        #[doc = "Field `CLK_DIV` reader - hall clock frequency divider"]
        pub type ClkDivR = crate::FieldReader<ClkDiv>;
        impl ClkDivR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ClkDiv {
                match self.bits {
                    0 => ClkDiv::Div1,
                    1 => ClkDiv::Div2,
                    2 => ClkDiv::Div4,
                    3 => ClkDiv::Div8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Divide 1"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == ClkDiv::Div1
            }
            #[doc = "Divide 2"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ClkDiv::Div2
            }
            #[doc = "Divide 4"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ClkDiv::Div4
            }
            #[doc = "Divide 8"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ClkDiv::Div8
            }
        }
        #[doc = "Field `CLK_DIV` writer - hall clock frequency divider"]
        pub type ClkDivW<'a, REG> = crate::FieldWriter<'a, REG, 2, ClkDiv, crate::Safe>;
        impl<'a, REG> ClkDivW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Divide 1"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div1)
            }
            #[doc = "Divide 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div2)
            }
            #[doc = "Divide 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div4)
            }
            #[doc = "Divide 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div8)
            }
        }
        #[doc = "hall signal first filter:7_5 filter control bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Fil75 {
            #[doc = "0: hall signal 7_5 filter is disabled"]
            Disabled = 0,
            #[doc = "1: hall signal 7_5 filter is enabled"]
            Enabled = 1,
        }
        impl From<Fil75> for bool {
            #[inline(always)]
            fn from(variant: Fil75) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FIL_75` reader - hall signal first filter:7_5 filter control bit"]
        pub type Fil75R = crate::BitReader<Fil75>;
        impl Fil75R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Fil75 {
                match self.bits {
                    false => Fil75::Disabled,
                    true => Fil75::Enabled,
                }
            }
            #[doc = "hall signal 7_5 filter is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Fil75::Disabled
            }
            #[doc = "hall signal 7_5 filter is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Fil75::Enabled
            }
        }
        #[doc = "Field `FIL_75` writer - hall signal first filter:7_5 filter control bit"]
        pub type Fil75W<'a, REG> = crate::BitWriter<'a, REG, Fil75>;
        impl<'a, REG> Fil75W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "hall signal 7_5 filter is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Fil75::Disabled)
            }
            #[doc = "hall signal 7_5 filter is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Fil75::Enabled)
            }
        }
        #[doc = "hall enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HallEn {
            #[doc = "0: hall module is disabled"]
            Disabled = 0,
            #[doc = "1: hall module is enabled"]
            Enabled = 1,
        }
        impl From<HallEn> for bool {
            #[inline(always)]
            fn from(variant: HallEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `HALL_EN` reader - hall enable"]
        pub type HallEnR = crate::BitReader<HallEn>;
        impl HallEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> HallEn {
                match self.bits {
                    false => HallEn::Disabled,
                    true => HallEn::Enabled,
                }
            }
            #[doc = "hall module is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == HallEn::Disabled
            }
            #[doc = "hall module is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == HallEn::Enabled
            }
        }
        #[doc = "Field `HALL_EN` writer - hall enable"]
        pub type HallEnW<'a, REG> = crate::BitWriter<'a, REG, HallEn>;
        impl<'a, REG> HallEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "hall module is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(HallEn::Disabled)
            }
            #[doc = "hall module is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(HallEn::Enabled)
            }
        }
        #[doc = "hall signal change DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ChgRe {
            #[doc = "0: hall signal change DMA request is disabled"]
            Disabled = 0,
            #[doc = "1: hall signal change DMA request is enabled"]
            Enabled = 1,
        }
        impl From<ChgRe> for bool {
            #[inline(always)]
            fn from(variant: ChgRe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CHG_RE` reader - hall signal change DMA request enable"]
        pub type ChgReR = crate::BitReader<ChgRe>;
        impl ChgReR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ChgRe {
                match self.bits {
                    false => ChgRe::Disabled,
                    true => ChgRe::Enabled,
                }
            }
            #[doc = "hall signal change DMA request is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ChgRe::Disabled
            }
            #[doc = "hall signal change DMA request is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ChgRe::Enabled
            }
        }
        #[doc = "Field `CHG_RE` writer - hall signal change DMA request enable"]
        pub type ChgReW<'a, REG> = crate::BitWriter<'a, REG, ChgRe>;
        impl<'a, REG> ChgReW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "hall signal change DMA request is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(ChgRe::Disabled)
            }
            #[doc = "hall signal change DMA request is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(ChgRe::Enabled)
            }
        }
        #[doc = "counter overflow DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OvRe {
            #[doc = "0: counter overflow DMA request is disabled"]
            Disabled = 0,
            #[doc = "1: counter overflow interrupt is enabled"]
            Enabled = 1,
        }
        impl From<OvRe> for bool {
            #[inline(always)]
            fn from(variant: OvRe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OV_RE` reader - counter overflow DMA request enable"]
        pub type OvReR = crate::BitReader<OvRe>;
        impl OvReR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OvRe {
                match self.bits {
                    false => OvRe::Disabled,
                    true => OvRe::Enabled,
                }
            }
            #[doc = "counter overflow DMA request is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OvRe::Disabled
            }
            #[doc = "counter overflow interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OvRe::Enabled
            }
        }
        #[doc = "Field `OV_RE` writer - counter overflow DMA request enable"]
        pub type OvReW<'a, REG> = crate::BitWriter<'a, REG, OvRe>;
        impl<'a, REG> OvReW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "counter overflow DMA request is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(OvRe::Disabled)
            }
            #[doc = "counter overflow interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(OvRe::Enabled)
            }
        }
        #[doc = "hall signal change interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ChgIe {
            #[doc = "0: hall signal change interrupt is disabled"]
            Disabled = 0,
            #[doc = "1: hall signal change interrupt is enabled"]
            Enabled = 1,
        }
        impl From<ChgIe> for bool {
            #[inline(always)]
            fn from(variant: ChgIe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CHG_IE` reader - hall signal change interrupt enable"]
        pub type ChgIeR = crate::BitReader<ChgIe>;
        impl ChgIeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ChgIe {
                match self.bits {
                    false => ChgIe::Disabled,
                    true => ChgIe::Enabled,
                }
            }
            #[doc = "hall signal change interrupt is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ChgIe::Disabled
            }
            #[doc = "hall signal change interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ChgIe::Enabled
            }
        }
        #[doc = "Field `CHG_IE` writer - hall signal change interrupt enable"]
        pub type ChgIeW<'a, REG> = crate::BitWriter<'a, REG, ChgIe>;
        impl<'a, REG> ChgIeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "hall signal change interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(ChgIe::Disabled)
            }
            #[doc = "hall signal change interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(ChgIe::Enabled)
            }
        }
        #[doc = "counter overflow interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OvIe {
            #[doc = "0: counter overflow interrupt is disabled"]
            Disabled = 0,
            #[doc = "1: counter overflow interrupt is enabled"]
            Enabled = 1,
        }
        impl From<OvIe> for bool {
            #[inline(always)]
            fn from(variant: OvIe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OV_IE` reader - counter overflow interrupt enable"]
        pub type OvIeR = crate::BitReader<OvIe>;
        impl OvIeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OvIe {
                match self.bits {
                    false => OvIe::Disabled,
                    true => OvIe::Enabled,
                }
            }
            #[doc = "counter overflow interrupt is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OvIe::Disabled
            }
            #[doc = "counter overflow interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OvIe::Enabled
            }
        }
        #[doc = "Field `OV_IE` writer - counter overflow interrupt enable"]
        pub type OvIeW<'a, REG> = crate::BitWriter<'a, REG, OvIe>;
        impl<'a, REG> OvIeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "counter overflow interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(OvIe::Disabled)
            }
            #[doc = "counter overflow interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(OvIe::Enabled)
            }
        }
        #[doc = "Software to trigger hall irq enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SwIe {
            #[doc = "0: software trigger interrupt is disabled"]
            Disabled = 0,
            #[doc = "1: software trigger interrupt is enabled"]
            Enabled = 1,
        }
        impl From<SwIe> for bool {
            #[inline(always)]
            fn from(variant: SwIe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SW_IE` reader - Software to trigger hall irq enable"]
        pub type SwIeR = crate::BitReader<SwIe>;
        impl SwIeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SwIe {
                match self.bits {
                    false => SwIe::Disabled,
                    true => SwIe::Enabled,
                }
            }
            #[doc = "software trigger interrupt is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SwIe::Disabled
            }
            #[doc = "software trigger interrupt is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SwIe::Enabled
            }
        }
        #[doc = "Field `SW_IE` writer - Software to trigger hall irq enable"]
        pub type SwIeW<'a, REG> = crate::BitWriter<'a, REG, SwIe>;
        impl<'a, REG> SwIeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "software trigger interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(SwIe::Disabled)
            }
            #[doc = "software trigger interrupt is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(SwIe::Enabled)
            }
        }
        impl R {
            #[doc = "Bits 0:14 - hall signal second filter:filter length control bits. Filter length from 1 to 32768"]
            #[inline(always)]
            pub fn fil_len(&self) -> FilLenR {
                FilLenR::new((self.bits & 0x7fff) as u16)
            }
            #[doc = "Bits 16:17 - hall clock frequency divider"]
            #[inline(always)]
            pub fn clk_div(&self) -> ClkDivR {
                ClkDivR::new(((self.bits >> 16) & 3) as u8)
            }
            #[doc = "Bit 20 - hall signal first filter:7_5 filter control bit"]
            #[inline(always)]
            pub fn fil_75(&self) -> Fil75R {
                Fil75R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 24 - hall enable"]
            #[inline(always)]
            pub fn hall_en(&self) -> HallEnR {
                HallEnR::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - hall signal change DMA request enable"]
            #[inline(always)]
            pub fn chg_re(&self) -> ChgReR {
                ChgReR::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - counter overflow DMA request enable"]
            #[inline(always)]
            pub fn ov_re(&self) -> OvReR {
                OvReR::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 28 - hall signal change interrupt enable"]
            #[inline(always)]
            pub fn chg_ie(&self) -> ChgIeR {
                ChgIeR::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - counter overflow interrupt enable"]
            #[inline(always)]
            pub fn ov_ie(&self) -> OvIeR {
                OvIeR::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Software to trigger hall irq enable"]
            #[inline(always)]
            pub fn sw_ie(&self) -> SwIeR {
                SwIeR::new(((self.bits >> 30) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:14 - hall signal second filter:filter length control bits. Filter length from 1 to 32768"]
            #[inline(always)]
            pub fn fil_len(&mut self) -> FilLenW<CfgSpec> {
                FilLenW::new(self, 0)
            }
            #[doc = "Bits 16:17 - hall clock frequency divider"]
            #[inline(always)]
            pub fn clk_div(&mut self) -> ClkDivW<CfgSpec> {
                ClkDivW::new(self, 16)
            }
            #[doc = "Bit 20 - hall signal first filter:7_5 filter control bit"]
            #[inline(always)]
            pub fn fil_75(&mut self) -> Fil75W<CfgSpec> {
                Fil75W::new(self, 20)
            }
            #[doc = "Bit 24 - hall enable"]
            #[inline(always)]
            pub fn hall_en(&mut self) -> HallEnW<CfgSpec> {
                HallEnW::new(self, 24)
            }
            #[doc = "Bit 25 - hall signal change DMA request enable"]
            #[inline(always)]
            pub fn chg_re(&mut self) -> ChgReW<CfgSpec> {
                ChgReW::new(self, 25)
            }
            #[doc = "Bit 26 - counter overflow DMA request enable"]
            #[inline(always)]
            pub fn ov_re(&mut self) -> OvReW<CfgSpec> {
                OvReW::new(self, 26)
            }
            #[doc = "Bit 28 - hall signal change interrupt enable"]
            #[inline(always)]
            pub fn chg_ie(&mut self) -> ChgIeW<CfgSpec> {
                ChgIeW::new(self, 28)
            }
            #[doc = "Bit 29 - counter overflow interrupt enable"]
            #[inline(always)]
            pub fn ov_ie(&mut self) -> OvIeW<CfgSpec> {
                OvIeW::new(self, 29)
            }
            #[doc = "Bit 30 - Software to trigger hall irq enable"]
            #[inline(always)]
            pub fn sw_ie(&mut self) -> SwIeW<CfgSpec> {
                SwIeW::new(self, 30)
            }
        }
        #[doc = "Hall Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgSpec;
        impl crate::RegisterSpec for CfgSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFG to value 0"]
        impl crate::Resettable for CfgSpec {}
    }
    #[doc = "INFO (rw) register accessor: Hall Information register\n\nYou can [`read`](crate::Reg::read) this register and get [`info::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`info::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@info`] module"]
    #[doc(alias = "INFO")]
    pub type Info = crate::Reg<info::InfoSpec>;
    #[doc = "Hall Information register"]
    pub mod info {
        #[doc = "Register `INFO` reader"]
        pub type R = crate::R<InfoSpec>;
        #[doc = "Register `INFO` writer"]
        pub type W = crate::W<InfoSpec>;
        #[doc = "Field `FLT_DATA` reader - hall signal data with filtered"]
        pub type FltDataR = crate::FieldReader;
        #[doc = "Field `RAW_DATA` reader - hall signal data without filtered"]
        pub type RawDataR = crate::FieldReader;
        #[doc = "hall signal change event\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ChgIf {
            #[doc = "0: read 0 means hall signal change event not happened, write 0 is useless"]
            Nchg = 0,
            #[doc = "1: read 1 means hall signal change event happened, write 1 to clear"]
            Chg = 1,
        }
        impl From<ChgIf> for bool {
            #[inline(always)]
            fn from(variant: ChgIf) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CHG_IF` reader - hall signal change event"]
        pub type ChgIfR = crate::BitReader<ChgIf>;
        impl ChgIfR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ChgIf {
                match self.bits {
                    false => ChgIf::Nchg,
                    true => ChgIf::Chg,
                }
            }
            #[doc = "read 0 means hall signal change event not happened, write 0 is useless"]
            #[inline(always)]
            pub fn is_nchg(&self) -> bool {
                *self == ChgIf::Nchg
            }
            #[doc = "read 1 means hall signal change event happened, write 1 to clear"]
            #[inline(always)]
            pub fn is_chg(&self) -> bool {
                *self == ChgIf::Chg
            }
        }
        #[doc = "Field `CHG_IF` writer - hall signal change event"]
        pub type ChgIfW<'a, REG> = crate::BitWriter<'a, REG, ChgIf>;
        impl<'a, REG> ChgIfW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "read 0 means hall signal change event not happened, write 0 is useless"]
            #[inline(always)]
            pub fn nchg(self) -> &'a mut crate::W<REG> {
                self.variant(ChgIf::Nchg)
            }
            #[doc = "read 1 means hall signal change event happened, write 1 to clear"]
            #[inline(always)]
            pub fn chg(self) -> &'a mut crate::W<REG> {
                self.variant(ChgIf::Chg)
            }
        }
        #[doc = "overflow counter event\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OvIf {
            #[doc = "0: read 0 means overflow counter event not happened, write 0 is useless"]
            Nov = 0,
            #[doc = "1: read 1 means overflow counter event happened, write 1 to clear"]
            Ov = 1,
        }
        impl From<OvIf> for bool {
            #[inline(always)]
            fn from(variant: OvIf) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OV_IF` reader - overflow counter event"]
        pub type OvIfR = crate::BitReader<OvIf>;
        impl OvIfR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OvIf {
                match self.bits {
                    false => OvIf::Nov,
                    true => OvIf::Ov,
                }
            }
            #[doc = "read 0 means overflow counter event not happened, write 0 is useless"]
            #[inline(always)]
            pub fn is_nov(&self) -> bool {
                *self == OvIf::Nov
            }
            #[doc = "read 1 means overflow counter event happened, write 1 to clear"]
            #[inline(always)]
            pub fn is_ov(&self) -> bool {
                *self == OvIf::Ov
            }
        }
        #[doc = "Field `OV_IF` writer - overflow counter event"]
        pub type OvIfW<'a, REG> = crate::BitWriter<'a, REG, OvIf>;
        impl<'a, REG> OvIfW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "read 0 means overflow counter event not happened, write 0 is useless"]
            #[inline(always)]
            pub fn nov(self) -> &'a mut crate::W<REG> {
                self.variant(OvIf::Nov)
            }
            #[doc = "read 1 means overflow counter event happened, write 1 to clear"]
            #[inline(always)]
            pub fn ov(self) -> &'a mut crate::W<REG> {
                self.variant(OvIf::Ov)
            }
        }
        #[doc = "Field `SW_IF` writer - software to trigger hall irq"]
        pub type SwIfW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:2 - hall signal data with filtered"]
            #[inline(always)]
            pub fn flt_data(&self) -> FltDataR {
                FltDataR::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 8:10 - hall signal data without filtered"]
            #[inline(always)]
            pub fn raw_data(&self) -> RawDataR {
                RawDataR::new(((self.bits >> 8) & 7) as u8)
            }
            #[doc = "Bit 16 - hall signal change event"]
            #[inline(always)]
            pub fn chg_if(&self) -> ChgIfR {
                ChgIfR::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - overflow counter event"]
            #[inline(always)]
            pub fn ov_if(&self) -> OvIfR {
                OvIfR::new(((self.bits >> 17) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 16 - hall signal change event"]
            #[inline(always)]
            pub fn chg_if(&mut self) -> ChgIfW<InfoSpec> {
                ChgIfW::new(self, 16)
            }
            #[doc = "Bit 17 - overflow counter event"]
            #[inline(always)]
            pub fn ov_if(&mut self) -> OvIfW<InfoSpec> {
                OvIfW::new(self, 17)
            }
            #[doc = "Bit 18 - software to trigger hall irq"]
            #[inline(always)]
            pub fn sw_if(&mut self) -> SwIfW<InfoSpec> {
                SwIfW::new(self, 18)
            }
        }
        #[doc = "Hall Information register\n\nYou can [`read`](crate::Reg::read) this register and get [`info::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`info::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct InfoSpec;
        impl crate::RegisterSpec for InfoSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`info::R`](R) reader structure"]
        impl crate::Readable for InfoSpec {}
        #[doc = "`write(|w| ..)` method takes [`info::W`](W) writer structure"]
        impl crate::Writable for InfoSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INFO to value 0"]
        impl crate::Resettable for InfoSpec {}
    }
    #[doc = "WIDTH (r) register accessor: Hall Width Register\n\nYou can [`read`](crate::Reg::read) this register and get [`width::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@width`] module"]
    #[doc(alias = "WIDTH")]
    pub type Width = crate::Reg<width::WidthSpec>;
    #[doc = "Hall Width Register"]
    pub mod width {
        #[doc = "Register `WIDTH` reader"]
        pub type R = crate::R<WidthSpec>;
        #[doc = "Field `CAP_CNT` reader - hall signal change event happened,captured hall counter value by hardware"]
        pub type CapCntR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:23 - hall signal change event happened,captured hall counter value by hardware"]
            #[inline(always)]
            pub fn cap_cnt(&self) -> CapCntR {
                CapCntR::new(self.bits & 0x00ff_ffff)
            }
        }
        #[doc = "Hall Width Register\n\nYou can [`read`](crate::Reg::read) this register and get [`width::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct WidthSpec;
        impl crate::RegisterSpec for WidthSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`width::R`](R) reader structure"]
        impl crate::Readable for WidthSpec {}
        #[doc = "`reset()` method sets WIDTH to value 0"]
        impl crate::Resettable for WidthSpec {}
    }
    #[doc = "TH (rw) register accessor: Hall Threshold Register\n\nYou can [`read`](crate::Reg::read) this register and get [`th::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th`] module"]
    #[doc(alias = "TH")]
    pub type Th = crate::Reg<th::ThSpec>;
    #[doc = "Hall Threshold Register"]
    pub mod th {
        #[doc = "Register `TH` reader"]
        pub type R = crate::R<ThSpec>;
        #[doc = "Register `TH` writer"]
        pub type W = crate::W<ThSpec>;
        #[doc = "Field `TH` reader - overflow event target value"]
        pub type ThR = crate::FieldReader<u32>;
        #[doc = "Field `TH` writer - overflow event target value"]
        pub type ThW<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            #[doc = "Bits 0:23 - overflow event target value"]
            #[inline(always)]
            pub fn th(&self) -> ThR {
                ThR::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 0:23 - overflow event target value"]
            #[inline(always)]
            pub fn th(&mut self) -> ThW<ThSpec> {
                ThW::new(self, 0)
            }
        }
        #[doc = "Hall Threshold Register\n\nYou can [`read`](crate::Reg::read) this register and get [`th::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ThSpec;
        impl crate::RegisterSpec for ThSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th::R`](R) reader structure"]
        impl crate::Readable for ThSpec {}
        #[doc = "`write(|w| ..)` method takes [`th::W`](W) writer structure"]
        impl crate::Writable for ThSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH to value 0"]
        impl crate::Resettable for ThSpec {}
    }
    #[doc = "CNT (rw) register accessor: Hall Counter Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
    #[doc(alias = "CNT")]
    pub type Cnt = crate::Reg<cnt::CntSpec>;
    #[doc = "Hall Counter Register"]
    pub mod cnt {
        #[doc = "Register `CNT` reader"]
        pub type R = crate::R<CntSpec>;
        #[doc = "Register `CNT` writer"]
        pub type W = crate::W<CntSpec>;
        #[doc = "Field `CNT` reader - hall counter value"]
        pub type CntR = crate::FieldReader<u32>;
        #[doc = "Field `CNT` writer - hall counter value"]
        pub type CntW<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            #[doc = "Bits 0:23 - hall counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CntR {
                CntR::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 0:23 - hall counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CntW<CntSpec> {
                CntW::new(self, 0)
            }
        }
        #[doc = "Hall Counter Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CntSpec;
        impl crate::RegisterSpec for CntSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt::R`](R) reader structure"]
        impl crate::Readable for CntSpec {}
        #[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"]
        impl crate::Writable for CntSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CNT to value 0"]
        impl crate::Resettable for CntSpec {}
    }
}
#[doc = "ADC registers"]
pub type Adc = crate::Periph<adc::RegisterBlock, 0x4001_0400>;
impl core::fmt::Debug for Adc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc").finish()
    }
}
#[doc = "ADC registers"]
pub mod adc {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        dat0: Dat0,
        dat1: Dat1,
        dat2: Dat2,
        dat3: Dat3,
        dat4: Dat4,
        dat5: Dat5,
        dat6: Dat6,
        dat7: Dat7,
        dat8: Dat8,
        dat9: Dat9,
        _reserved10: [u8; 0x08],
        lth: Lth,
        hth: Hth,
        gen_: Gen,
        _reserved13: [u8; 0x04],
        chn0: Chn0,
        chn1: Chn1,
        chn2: Chn2,
        _reserved16: [u8; 0x04],
        chnt: Chnt,
        cfg: Cfg,
        swt: Swt,
        _reserved19: [u8; 0x04],
        dc: Dc,
        amc: Amc,
        ie: Ie,
        if_: If,
    }
    impl RegisterBlock {
        #[doc = "0x00 - ADC data0"]
        #[inline(always)]
        pub const fn dat0(&self) -> &Dat0 {
            &self.dat0
        }
        #[doc = "0x04 - ADC data1"]
        #[inline(always)]
        pub const fn dat1(&self) -> &Dat1 {
            &self.dat1
        }
        #[doc = "0x08 - ADC data2"]
        #[inline(always)]
        pub const fn dat2(&self) -> &Dat2 {
            &self.dat2
        }
        #[doc = "0x0c - ADC data3"]
        #[inline(always)]
        pub const fn dat3(&self) -> &Dat3 {
            &self.dat3
        }
        #[doc = "0x10 - ADC data4"]
        #[inline(always)]
        pub const fn dat4(&self) -> &Dat4 {
            &self.dat4
        }
        #[doc = "0x14 - ADC data5"]
        #[inline(always)]
        pub const fn dat5(&self) -> &Dat5 {
            &self.dat5
        }
        #[doc = "0x18 - ADC data6"]
        #[inline(always)]
        pub const fn dat6(&self) -> &Dat6 {
            &self.dat6
        }
        #[doc = "0x1c - ADC data7"]
        #[inline(always)]
        pub const fn dat7(&self) -> &Dat7 {
            &self.dat7
        }
        #[doc = "0x20 - ADC data8"]
        #[inline(always)]
        pub const fn dat8(&self) -> &Dat8 {
            &self.dat8
        }
        #[doc = "0x24 - ADC data9"]
        #[inline(always)]
        pub const fn dat9(&self) -> &Dat9 {
            &self.dat9
        }
        #[doc = "0x30 - low threshold"]
        #[inline(always)]
        pub const fn lth(&self) -> &Lth {
            &self.lth
        }
        #[doc = "0x34 - high threshold"]
        #[inline(always)]
        pub const fn hth(&self) -> &Hth {
            &self.hth
        }
        #[doc = "0x38 - Data monitor enable"]
        #[inline(always)]
        pub const fn gen_(&self) -> &Gen {
            &self.gen_
        }
        #[doc = "0x40 - ADC data0/1/2/3 source"]
        #[inline(always)]
        pub const fn chn0(&self) -> &Chn0 {
            &self.chn0
        }
        #[doc = "0x44 - ADC data4/5/6/7 source"]
        #[inline(always)]
        pub const fn chn1(&self) -> &Chn1 {
            &self.chn1
        }
        #[doc = "0x48 - ADC data8/9 source"]
        #[inline(always)]
        pub const fn chn2(&self) -> &Chn2 {
            &self.chn2
        }
        #[doc = "0x50 - ADC channel numbers"]
        #[inline(always)]
        pub const fn chnt(&self) -> &Chnt {
            &self.chnt
        }
        #[doc = "0x54 - ADC configuration"]
        #[inline(always)]
        pub const fn cfg(&self) -> &Cfg {
            &self.cfg
        }
        #[doc = "0x58 - ADC software trigger"]
        #[inline(always)]
        pub const fn swt(&self) -> &Swt {
            &self.swt
        }
        #[doc = "0x60 - ADC DC offset of sample circuit A for low gain"]
        #[inline(always)]
        pub const fn dc(&self) -> &Dc {
            &self.dc
        }
        #[doc = "0x64 - ADC amplification calibration of sample circuit A for low gain"]
        #[inline(always)]
        pub const fn amc(&self) -> &Amc {
            &self.amc
        }
        #[doc = "0x68 - ADC interrupt enable"]
        #[inline(always)]
        pub const fn ie(&self) -> &Ie {
            &self.ie
        }
        #[doc = "0x6c - ADC interrupt flag"]
        #[inline(always)]
        pub const fn if_(&self) -> &If {
            &self.if_
        }
    }
    #[doc = "DAT0 (rw) register accessor: ADC data0\n\nYou can [`read`](crate::Reg::read) this register and get [`dat0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat0`] module"]
    #[doc(alias = "DAT0")]
    pub type Dat0 = crate::Reg<dat0::Dat0Spec>;
    #[doc = "ADC data0"]
    pub mod dat0 {
        #[doc = "Register `DAT0` reader"]
        pub type R = crate::R<Dat0Spec>;
        #[doc = "Register `DAT0` writer"]
        pub type W = crate::W<Dat0Spec>;
        #[doc = "Field `DAT0` reader - ADC 0th sample data"]
        pub type Dat0R = crate::FieldReader<u16>;
        #[doc = "Field `DAT0` writer - ADC 0th sample data"]
        pub type Dat0W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC 0th sample data"]
            #[inline(always)]
            pub fn dat0(&self) -> Dat0R {
                Dat0R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC 0th sample data"]
            #[inline(always)]
            pub fn dat0(&mut self) -> Dat0W<Dat0Spec> {
                Dat0W::new(self, 0)
            }
        }
        #[doc = "ADC data0\n\nYou can [`read`](crate::Reg::read) this register and get [`dat0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dat0Spec;
        impl crate::RegisterSpec for Dat0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat0::R`](R) reader structure"]
        impl crate::Readable for Dat0Spec {}
        #[doc = "`write(|w| ..)` method takes [`dat0::W`](W) writer structure"]
        impl crate::Writable for Dat0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DAT0 to value 0"]
        impl crate::Resettable for Dat0Spec {}
    }
    #[doc = "DAT1 (rw) register accessor: ADC data1\n\nYou can [`read`](crate::Reg::read) this register and get [`dat1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat1`] module"]
    #[doc(alias = "DAT1")]
    pub type Dat1 = crate::Reg<dat1::Dat1Spec>;
    #[doc = "ADC data1"]
    pub mod dat1 {
        #[doc = "Register `DAT1` reader"]
        pub type R = crate::R<Dat1Spec>;
        #[doc = "Register `DAT1` writer"]
        pub type W = crate::W<Dat1Spec>;
        #[doc = "Field `DAT1` reader - ADC 1st sample data"]
        pub type Dat1R = crate::FieldReader<u16>;
        #[doc = "Field `DAT1` writer - ADC 1st sample data"]
        pub type Dat1W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC 1st sample data"]
            #[inline(always)]
            pub fn dat1(&self) -> Dat1R {
                Dat1R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC 1st sample data"]
            #[inline(always)]
            pub fn dat1(&mut self) -> Dat1W<Dat1Spec> {
                Dat1W::new(self, 0)
            }
        }
        #[doc = "ADC data1\n\nYou can [`read`](crate::Reg::read) this register and get [`dat1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dat1Spec;
        impl crate::RegisterSpec for Dat1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat1::R`](R) reader structure"]
        impl crate::Readable for Dat1Spec {}
        #[doc = "`write(|w| ..)` method takes [`dat1::W`](W) writer structure"]
        impl crate::Writable for Dat1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DAT1 to value 0"]
        impl crate::Resettable for Dat1Spec {}
    }
    #[doc = "DAT2 (rw) register accessor: ADC data2\n\nYou can [`read`](crate::Reg::read) this register and get [`dat2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat2`] module"]
    #[doc(alias = "DAT2")]
    pub type Dat2 = crate::Reg<dat2::Dat2Spec>;
    #[doc = "ADC data2"]
    pub mod dat2 {
        #[doc = "Register `DAT2` reader"]
        pub type R = crate::R<Dat2Spec>;
        #[doc = "Register `DAT2` writer"]
        pub type W = crate::W<Dat2Spec>;
        #[doc = "Field `DAT2` reader - ADC 2nd sample data"]
        pub type Dat2R = crate::FieldReader<u16>;
        #[doc = "Field `DAT2` writer - ADC 2nd sample data"]
        pub type Dat2W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC 2nd sample data"]
            #[inline(always)]
            pub fn dat2(&self) -> Dat2R {
                Dat2R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC 2nd sample data"]
            #[inline(always)]
            pub fn dat2(&mut self) -> Dat2W<Dat2Spec> {
                Dat2W::new(self, 0)
            }
        }
        #[doc = "ADC data2\n\nYou can [`read`](crate::Reg::read) this register and get [`dat2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dat2Spec;
        impl crate::RegisterSpec for Dat2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat2::R`](R) reader structure"]
        impl crate::Readable for Dat2Spec {}
        #[doc = "`write(|w| ..)` method takes [`dat2::W`](W) writer structure"]
        impl crate::Writable for Dat2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DAT2 to value 0"]
        impl crate::Resettable for Dat2Spec {}
    }
    #[doc = "DAT3 (rw) register accessor: ADC data3\n\nYou can [`read`](crate::Reg::read) this register and get [`dat3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat3`] module"]
    #[doc(alias = "DAT3")]
    pub type Dat3 = crate::Reg<dat3::Dat3Spec>;
    #[doc = "ADC data3"]
    pub mod dat3 {
        #[doc = "Register `DAT3` reader"]
        pub type R = crate::R<Dat3Spec>;
        #[doc = "Register `DAT3` writer"]
        pub type W = crate::W<Dat3Spec>;
        #[doc = "Field `DAT3` reader - ADC 3rd sample data"]
        pub type Dat3R = crate::FieldReader<u16>;
        #[doc = "Field `DAT3` writer - ADC 3rd sample data"]
        pub type Dat3W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC 3rd sample data"]
            #[inline(always)]
            pub fn dat3(&self) -> Dat3R {
                Dat3R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC 3rd sample data"]
            #[inline(always)]
            pub fn dat3(&mut self) -> Dat3W<Dat3Spec> {
                Dat3W::new(self, 0)
            }
        }
        #[doc = "ADC data3\n\nYou can [`read`](crate::Reg::read) this register and get [`dat3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dat3Spec;
        impl crate::RegisterSpec for Dat3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat3::R`](R) reader structure"]
        impl crate::Readable for Dat3Spec {}
        #[doc = "`write(|w| ..)` method takes [`dat3::W`](W) writer structure"]
        impl crate::Writable for Dat3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DAT3 to value 0"]
        impl crate::Resettable for Dat3Spec {}
    }
    #[doc = "DAT4 (rw) register accessor: ADC data4\n\nYou can [`read`](crate::Reg::read) this register and get [`dat4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat4`] module"]
    #[doc(alias = "DAT4")]
    pub type Dat4 = crate::Reg<dat4::Dat4Spec>;
    #[doc = "ADC data4"]
    pub mod dat4 {
        #[doc = "Register `DAT4` reader"]
        pub type R = crate::R<Dat4Spec>;
        #[doc = "Register `DAT4` writer"]
        pub type W = crate::W<Dat4Spec>;
        #[doc = "Field `DAT4` reader - ADC 4th sample data"]
        pub type Dat4R = crate::FieldReader<u16>;
        #[doc = "Field `DAT4` writer - ADC 4th sample data"]
        pub type Dat4W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC 4th sample data"]
            #[inline(always)]
            pub fn dat4(&self) -> Dat4R {
                Dat4R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC 4th sample data"]
            #[inline(always)]
            pub fn dat4(&mut self) -> Dat4W<Dat4Spec> {
                Dat4W::new(self, 0)
            }
        }
        #[doc = "ADC data4\n\nYou can [`read`](crate::Reg::read) this register and get [`dat4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dat4Spec;
        impl crate::RegisterSpec for Dat4Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat4::R`](R) reader structure"]
        impl crate::Readable for Dat4Spec {}
        #[doc = "`write(|w| ..)` method takes [`dat4::W`](W) writer structure"]
        impl crate::Writable for Dat4Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DAT4 to value 0"]
        impl crate::Resettable for Dat4Spec {}
    }
    #[doc = "DAT5 (rw) register accessor: ADC data5\n\nYou can [`read`](crate::Reg::read) this register and get [`dat5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat5`] module"]
    #[doc(alias = "DAT5")]
    pub type Dat5 = crate::Reg<dat5::Dat5Spec>;
    #[doc = "ADC data5"]
    pub mod dat5 {
        #[doc = "Register `DAT5` reader"]
        pub type R = crate::R<Dat5Spec>;
        #[doc = "Register `DAT5` writer"]
        pub type W = crate::W<Dat5Spec>;
        #[doc = "Field `DAT5` reader - ADC 5th sample data"]
        pub type Dat5R = crate::FieldReader<u16>;
        #[doc = "Field `DAT5` writer - ADC 5th sample data"]
        pub type Dat5W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC 5th sample data"]
            #[inline(always)]
            pub fn dat5(&self) -> Dat5R {
                Dat5R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC 5th sample data"]
            #[inline(always)]
            pub fn dat5(&mut self) -> Dat5W<Dat5Spec> {
                Dat5W::new(self, 0)
            }
        }
        #[doc = "ADC data5\n\nYou can [`read`](crate::Reg::read) this register and get [`dat5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dat5Spec;
        impl crate::RegisterSpec for Dat5Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat5::R`](R) reader structure"]
        impl crate::Readable for Dat5Spec {}
        #[doc = "`write(|w| ..)` method takes [`dat5::W`](W) writer structure"]
        impl crate::Writable for Dat5Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DAT5 to value 0"]
        impl crate::Resettable for Dat5Spec {}
    }
    #[doc = "DAT6 (rw) register accessor: ADC data6\n\nYou can [`read`](crate::Reg::read) this register and get [`dat6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat6`] module"]
    #[doc(alias = "DAT6")]
    pub type Dat6 = crate::Reg<dat6::Dat6Spec>;
    #[doc = "ADC data6"]
    pub mod dat6 {
        #[doc = "Register `DAT6` reader"]
        pub type R = crate::R<Dat6Spec>;
        #[doc = "Register `DAT6` writer"]
        pub type W = crate::W<Dat6Spec>;
        #[doc = "Field `DAT6` reader - ADC 6th sample data"]
        pub type Dat6R = crate::FieldReader<u16>;
        #[doc = "Field `DAT6` writer - ADC 6th sample data"]
        pub type Dat6W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC 6th sample data"]
            #[inline(always)]
            pub fn dat6(&self) -> Dat6R {
                Dat6R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC 6th sample data"]
            #[inline(always)]
            pub fn dat6(&mut self) -> Dat6W<Dat6Spec> {
                Dat6W::new(self, 0)
            }
        }
        #[doc = "ADC data6\n\nYou can [`read`](crate::Reg::read) this register and get [`dat6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dat6Spec;
        impl crate::RegisterSpec for Dat6Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat6::R`](R) reader structure"]
        impl crate::Readable for Dat6Spec {}
        #[doc = "`write(|w| ..)` method takes [`dat6::W`](W) writer structure"]
        impl crate::Writable for Dat6Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DAT6 to value 0"]
        impl crate::Resettable for Dat6Spec {}
    }
    #[doc = "DAT7 (rw) register accessor: ADC data7\n\nYou can [`read`](crate::Reg::read) this register and get [`dat7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat7`] module"]
    #[doc(alias = "DAT7")]
    pub type Dat7 = crate::Reg<dat7::Dat7Spec>;
    #[doc = "ADC data7"]
    pub mod dat7 {
        #[doc = "Register `DAT7` reader"]
        pub type R = crate::R<Dat7Spec>;
        #[doc = "Register `DAT7` writer"]
        pub type W = crate::W<Dat7Spec>;
        #[doc = "Field `DAT7` reader - ADC 7th sample data"]
        pub type Dat7R = crate::FieldReader<u16>;
        #[doc = "Field `DAT7` writer - ADC 7th sample data"]
        pub type Dat7W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC 7th sample data"]
            #[inline(always)]
            pub fn dat7(&self) -> Dat7R {
                Dat7R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC 7th sample data"]
            #[inline(always)]
            pub fn dat7(&mut self) -> Dat7W<Dat7Spec> {
                Dat7W::new(self, 0)
            }
        }
        #[doc = "ADC data7\n\nYou can [`read`](crate::Reg::read) this register and get [`dat7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dat7Spec;
        impl crate::RegisterSpec for Dat7Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat7::R`](R) reader structure"]
        impl crate::Readable for Dat7Spec {}
        #[doc = "`write(|w| ..)` method takes [`dat7::W`](W) writer structure"]
        impl crate::Writable for Dat7Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DAT7 to value 0"]
        impl crate::Resettable for Dat7Spec {}
    }
    #[doc = "DAT8 (rw) register accessor: ADC data8\n\nYou can [`read`](crate::Reg::read) this register and get [`dat8::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat8::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat8`] module"]
    #[doc(alias = "DAT8")]
    pub type Dat8 = crate::Reg<dat8::Dat8Spec>;
    #[doc = "ADC data8"]
    pub mod dat8 {
        #[doc = "Register `DAT8` reader"]
        pub type R = crate::R<Dat8Spec>;
        #[doc = "Register `DAT8` writer"]
        pub type W = crate::W<Dat8Spec>;
        #[doc = "Field `DAT8` reader - ADC 8th sample data"]
        pub type Dat8R = crate::FieldReader<u16>;
        #[doc = "Field `DAT8` writer - ADC 8th sample data"]
        pub type Dat8W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC 8th sample data"]
            #[inline(always)]
            pub fn dat8(&self) -> Dat8R {
                Dat8R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC 8th sample data"]
            #[inline(always)]
            pub fn dat8(&mut self) -> Dat8W<Dat8Spec> {
                Dat8W::new(self, 0)
            }
        }
        #[doc = "ADC data8\n\nYou can [`read`](crate::Reg::read) this register and get [`dat8::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat8::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dat8Spec;
        impl crate::RegisterSpec for Dat8Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat8::R`](R) reader structure"]
        impl crate::Readable for Dat8Spec {}
        #[doc = "`write(|w| ..)` method takes [`dat8::W`](W) writer structure"]
        impl crate::Writable for Dat8Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DAT8 to value 0"]
        impl crate::Resettable for Dat8Spec {}
    }
    #[doc = "DAT9 (rw) register accessor: ADC data9\n\nYou can [`read`](crate::Reg::read) this register and get [`dat9::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat9::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat9`] module"]
    #[doc(alias = "DAT9")]
    pub type Dat9 = crate::Reg<dat9::Dat9Spec>;
    #[doc = "ADC data9"]
    pub mod dat9 {
        #[doc = "Register `DAT9` reader"]
        pub type R = crate::R<Dat9Spec>;
        #[doc = "Register `DAT9` writer"]
        pub type W = crate::W<Dat9Spec>;
        #[doc = "Field `DAT9` reader - ADC 9th sample data"]
        pub type Dat9R = crate::FieldReader<u16>;
        #[doc = "Field `DAT9` writer - ADC 9th sample data"]
        pub type Dat9W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC 9th sample data"]
            #[inline(always)]
            pub fn dat9(&self) -> Dat9R {
                Dat9R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC 9th sample data"]
            #[inline(always)]
            pub fn dat9(&mut self) -> Dat9W<Dat9Spec> {
                Dat9W::new(self, 0)
            }
        }
        #[doc = "ADC data9\n\nYou can [`read`](crate::Reg::read) this register and get [`dat9::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dat9::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dat9Spec;
        impl crate::RegisterSpec for Dat9Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat9::R`](R) reader structure"]
        impl crate::Readable for Dat9Spec {}
        #[doc = "`write(|w| ..)` method takes [`dat9::W`](W) writer structure"]
        impl crate::Writable for Dat9Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DAT9 to value 0"]
        impl crate::Resettable for Dat9Spec {}
    }
    #[doc = "LTH (rw) register accessor: low threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`lth::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lth::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lth`] module"]
    #[doc(alias = "LTH")]
    pub type Lth = crate::Reg<lth::LthSpec>;
    #[doc = "low threshold"]
    pub mod lth {
        #[doc = "Register `LTH` reader"]
        pub type R = crate::R<LthSpec>;
        #[doc = "Register `LTH` writer"]
        pub type W = crate::W<LthSpec>;
        #[doc = "Field `LTH` reader - Data low threshold"]
        pub type LthR = crate::FieldReader<u16>;
        #[doc = "Field `LTH` writer - Data low threshold"]
        pub type LthW<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            #[doc = "Bits 0:11 - Data low threshold"]
            #[inline(always)]
            pub fn lth(&self) -> LthR {
                LthR::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Data low threshold"]
            #[inline(always)]
            pub fn lth(&mut self) -> LthW<LthSpec> {
                LthW::new(self, 0)
            }
        }
        #[doc = "low threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`lth::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lth::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LthSpec;
        impl crate::RegisterSpec for LthSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lth::R`](R) reader structure"]
        impl crate::Readable for LthSpec {}
        #[doc = "`write(|w| ..)` method takes [`lth::W`](W) writer structure"]
        impl crate::Writable for LthSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets LTH to value 0"]
        impl crate::Resettable for LthSpec {}
    }
    #[doc = "HTH (rw) register accessor: high threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`hth::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hth::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hth`] module"]
    #[doc(alias = "HTH")]
    pub type Hth = crate::Reg<hth::HthSpec>;
    #[doc = "high threshold"]
    pub mod hth {
        #[doc = "Register `HTH` reader"]
        pub type R = crate::R<HthSpec>;
        #[doc = "Register `HTH` writer"]
        pub type W = crate::W<HthSpec>;
        #[doc = "Field `HTH` reader - Data high threshold"]
        pub type HthR = crate::FieldReader<u16>;
        #[doc = "Field `HTH` writer - Data high threshold"]
        pub type HthW<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            #[doc = "Bits 0:11 - Data high threshold"]
            #[inline(always)]
            pub fn hth(&self) -> HthR {
                HthR::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Data high threshold"]
            #[inline(always)]
            pub fn hth(&mut self) -> HthW<HthSpec> {
                HthW::new(self, 0)
            }
        }
        #[doc = "high threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`hth::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hth::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HthSpec;
        impl crate::RegisterSpec for HthSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`hth::R`](R) reader structure"]
        impl crate::Readable for HthSpec {}
        #[doc = "`write(|w| ..)` method takes [`hth::W`](W) writer structure"]
        impl crate::Writable for HthSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets HTH to value 0"]
        impl crate::Resettable for HthSpec {}
    }
    #[doc = "GEN (rw) register accessor: Data monitor enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gen_::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gen_::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gen_`] module"]
    #[doc(alias = "GEN")]
    pub type Gen = crate::Reg<gen_::GenSpec>;
    #[doc = "Data monitor enable"]
    pub mod gen_ {
        #[doc = "Register `GEN` reader"]
        pub type R = crate::R<GenSpec>;
        #[doc = "Register `GEN` writer"]
        pub type W = crate::W<GenSpec>;
        #[doc = "Field `DATA0_GEN` reader - Data0 monitor enable"]
        pub type Data0GenR = crate::BitReader;
        #[doc = "Field `DATA0_GEN` writer - Data0 monitor enable"]
        pub type Data0GenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DATA1_GEN` reader - Data1 monitor enable"]
        pub type Data1GenR = crate::BitReader;
        #[doc = "Field `DATA1_GEN` writer - Data1 monitor enable"]
        pub type Data1GenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DATA2_GEN` reader - Data2 monitor enable"]
        pub type Data2GenR = crate::BitReader;
        #[doc = "Field `DATA2_GEN` writer - Data2 monitor enable"]
        pub type Data2GenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DATA3_GEN` reader - Data3 monitor enable"]
        pub type Data3GenR = crate::BitReader;
        #[doc = "Field `DATA3_GEN` writer - Data3 monitor enable"]
        pub type Data3GenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DATA4_GEN` reader - Data4 monitor enable"]
        pub type Data4GenR = crate::BitReader;
        #[doc = "Field `DATA4_GEN` writer - Data4 monitor enable"]
        pub type Data4GenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DATA5_GEN` reader - Data5 monitor enable"]
        pub type Data5GenR = crate::BitReader;
        #[doc = "Field `DATA5_GEN` writer - Data5 monitor enable"]
        pub type Data5GenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DATA6_GEN` reader - Data6 monitor enable"]
        pub type Data6GenR = crate::BitReader;
        #[doc = "Field `DATA6_GEN` writer - Data6 monitor enable"]
        pub type Data6GenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DATA7_GEN` reader - Data7 monitor enable"]
        pub type Data7GenR = crate::BitReader;
        #[doc = "Field `DATA7_GEN` writer - Data7 monitor enable"]
        pub type Data7GenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DATA8_GEN` reader - Data8 monitor enable"]
        pub type Data8GenR = crate::BitReader;
        #[doc = "Field `DATA8_GEN` writer - Data8 monitor enable"]
        pub type Data8GenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DATA9_GEN` reader - Data9 monitor enable"]
        pub type Data9GenR = crate::BitReader;
        #[doc = "Field `DATA9_GEN` writer - Data9 monitor enable"]
        pub type Data9GenW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Data0 monitor enable"]
            #[inline(always)]
            pub fn data0_gen(&self) -> Data0GenR {
                Data0GenR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Data1 monitor enable"]
            #[inline(always)]
            pub fn data1_gen(&self) -> Data1GenR {
                Data1GenR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Data2 monitor enable"]
            #[inline(always)]
            pub fn data2_gen(&self) -> Data2GenR {
                Data2GenR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Data3 monitor enable"]
            #[inline(always)]
            pub fn data3_gen(&self) -> Data3GenR {
                Data3GenR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Data4 monitor enable"]
            #[inline(always)]
            pub fn data4_gen(&self) -> Data4GenR {
                Data4GenR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Data5 monitor enable"]
            #[inline(always)]
            pub fn data5_gen(&self) -> Data5GenR {
                Data5GenR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Data6 monitor enable"]
            #[inline(always)]
            pub fn data6_gen(&self) -> Data6GenR {
                Data6GenR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Data7 monitor enable"]
            #[inline(always)]
            pub fn data7_gen(&self) -> Data7GenR {
                Data7GenR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Data8 monitor enable"]
            #[inline(always)]
            pub fn data8_gen(&self) -> Data8GenR {
                Data8GenR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Data9 monitor enable"]
            #[inline(always)]
            pub fn data9_gen(&self) -> Data9GenR {
                Data9GenR::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Data0 monitor enable"]
            #[inline(always)]
            pub fn data0_gen(&mut self) -> Data0GenW<GenSpec> {
                Data0GenW::new(self, 0)
            }
            #[doc = "Bit 1 - Data1 monitor enable"]
            #[inline(always)]
            pub fn data1_gen(&mut self) -> Data1GenW<GenSpec> {
                Data1GenW::new(self, 1)
            }
            #[doc = "Bit 2 - Data2 monitor enable"]
            #[inline(always)]
            pub fn data2_gen(&mut self) -> Data2GenW<GenSpec> {
                Data2GenW::new(self, 2)
            }
            #[doc = "Bit 3 - Data3 monitor enable"]
            #[inline(always)]
            pub fn data3_gen(&mut self) -> Data3GenW<GenSpec> {
                Data3GenW::new(self, 3)
            }
            #[doc = "Bit 4 - Data4 monitor enable"]
            #[inline(always)]
            pub fn data4_gen(&mut self) -> Data4GenW<GenSpec> {
                Data4GenW::new(self, 4)
            }
            #[doc = "Bit 5 - Data5 monitor enable"]
            #[inline(always)]
            pub fn data5_gen(&mut self) -> Data5GenW<GenSpec> {
                Data5GenW::new(self, 5)
            }
            #[doc = "Bit 6 - Data6 monitor enable"]
            #[inline(always)]
            pub fn data6_gen(&mut self) -> Data6GenW<GenSpec> {
                Data6GenW::new(self, 6)
            }
            #[doc = "Bit 7 - Data7 monitor enable"]
            #[inline(always)]
            pub fn data7_gen(&mut self) -> Data7GenW<GenSpec> {
                Data7GenW::new(self, 7)
            }
            #[doc = "Bit 8 - Data8 monitor enable"]
            #[inline(always)]
            pub fn data8_gen(&mut self) -> Data8GenW<GenSpec> {
                Data8GenW::new(self, 8)
            }
            #[doc = "Bit 9 - Data9 monitor enable"]
            #[inline(always)]
            pub fn data9_gen(&mut self) -> Data9GenW<GenSpec> {
                Data9GenW::new(self, 9)
            }
        }
        #[doc = "Data monitor enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gen_::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gen_::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GenSpec;
        impl crate::RegisterSpec for GenSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gen_::R`](R) reader structure"]
        impl crate::Readable for GenSpec {}
        #[doc = "`write(|w| ..)` method takes [`gen_::W`](W) writer structure"]
        impl crate::Writable for GenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets GEN to value 0"]
        impl crate::Resettable for GenSpec {}
    }
    #[doc = "CHN0 (rw) register accessor: ADC data0/1/2/3 source\n\nYou can [`read`](crate::Reg::read) this register and get [`chn0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chn0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@chn0`] module"]
    #[doc(alias = "CHN0")]
    pub type Chn0 = crate::Reg<chn0::Chn0Spec>;
    #[doc = "ADC data0/1/2/3 source"]
    pub mod chn0 {
        #[doc = "Register `CHN0` reader"]
        pub type R = crate::R<Chn0Spec>;
        #[doc = "Register `CHN0` writer"]
        pub type W = crate::W<Chn0Spec>;
        #[doc = "Data0 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ds0 {
            #[doc = "0: OPA0_OUT"]
            Opa0Out = 0,
            #[doc = "1: ADC_CH1"]
            AdcCh1 = 1,
            #[doc = "2: ADC_CH2"]
            AdcCh2 = 2,
            #[doc = "3: ADC_CH3"]
            AdcCh3 = 3,
            #[doc = "4: ADC_CH4"]
            AdcCh4 = 4,
            #[doc = "5: ADC_CH5"]
            AdcCh5 = 5,
            #[doc = "6: ADC_CH6"]
            AdcCh6 = 6,
            #[doc = "7: ADC_CH7"]
            AdcCh7 = 7,
            #[doc = "8: ADC_CH8"]
            AdcCh8 = 8,
            #[doc = "9: ADC_CH9"]
            AdcCh9 = 9,
            #[doc = "10: ADC_CH10"]
            AdcCh10 = 10,
            #[doc = "11: TEMP"]
            Temp = 11,
            #[doc = "12: VSS"]
            Vss = 12,
        }
        impl From<Ds0> for u8 {
            #[inline(always)]
            fn from(variant: Ds0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ds0 {
            type Ux = u8;
        }
        impl crate::IsEnum for Ds0 {}
        #[doc = "Field `DS0` reader - Data0 source"]
        pub type Ds0R = crate::FieldReader<Ds0>;
        impl Ds0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Ds0> {
                match self.bits {
                    0 => Some(Ds0::Opa0Out),
                    1 => Some(Ds0::AdcCh1),
                    2 => Some(Ds0::AdcCh2),
                    3 => Some(Ds0::AdcCh3),
                    4 => Some(Ds0::AdcCh4),
                    5 => Some(Ds0::AdcCh5),
                    6 => Some(Ds0::AdcCh6),
                    7 => Some(Ds0::AdcCh7),
                    8 => Some(Ds0::AdcCh8),
                    9 => Some(Ds0::AdcCh9),
                    10 => Some(Ds0::AdcCh10),
                    11 => Some(Ds0::Temp),
                    12 => Some(Ds0::Vss),
                    _ => None,
                }
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Ds0::Opa0Out
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn is_adc_ch1(&self) -> bool {
                *self == Ds0::AdcCh1
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn is_adc_ch2(&self) -> bool {
                *self == Ds0::AdcCh2
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn is_adc_ch3(&self) -> bool {
                *self == Ds0::AdcCh3
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn is_adc_ch4(&self) -> bool {
                *self == Ds0::AdcCh4
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn is_adc_ch5(&self) -> bool {
                *self == Ds0::AdcCh5
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn is_adc_ch6(&self) -> bool {
                *self == Ds0::AdcCh6
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn is_adc_ch7(&self) -> bool {
                *self == Ds0::AdcCh7
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn is_adc_ch8(&self) -> bool {
                *self == Ds0::AdcCh8
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn is_adc_ch9(&self) -> bool {
                *self == Ds0::AdcCh9
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn is_adc_ch10(&self) -> bool {
                *self == Ds0::AdcCh10
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == Ds0::Temp
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn is_vss(&self) -> bool {
                *self == Ds0::Vss
            }
        }
        #[doc = "Field `DS0` writer - Data0 source"]
        pub type Ds0W<'a, REG> = crate::FieldWriter<'a, REG, 4, Ds0>;
        impl<'a, REG> Ds0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::Opa0Out)
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn adc_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::AdcCh1)
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn adc_ch2(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::AdcCh2)
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn adc_ch3(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::AdcCh3)
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn adc_ch4(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::AdcCh4)
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn adc_ch5(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::AdcCh5)
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn adc_ch6(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::AdcCh6)
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn adc_ch7(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::AdcCh7)
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn adc_ch8(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::AdcCh8)
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn adc_ch9(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::AdcCh9)
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn adc_ch10(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::AdcCh10)
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::Temp)
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn vss(self) -> &'a mut crate::W<REG> {
                self.variant(Ds0::Vss)
            }
        }
        #[doc = "Data1 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ds1 {
            #[doc = "0: OPA0_OUT"]
            Opa0Out = 0,
            #[doc = "1: ADC_CH1"]
            AdcCh1 = 1,
            #[doc = "2: ADC_CH2"]
            AdcCh2 = 2,
            #[doc = "3: ADC_CH3"]
            AdcCh3 = 3,
            #[doc = "4: ADC_CH4"]
            AdcCh4 = 4,
            #[doc = "5: ADC_CH5"]
            AdcCh5 = 5,
            #[doc = "6: ADC_CH6"]
            AdcCh6 = 6,
            #[doc = "7: ADC_CH7"]
            AdcCh7 = 7,
            #[doc = "8: ADC_CH8"]
            AdcCh8 = 8,
            #[doc = "9: ADC_CH9"]
            AdcCh9 = 9,
            #[doc = "10: ADC_CH10"]
            AdcCh10 = 10,
            #[doc = "11: TEMP"]
            Temp = 11,
            #[doc = "12: VSS"]
            Vss = 12,
        }
        impl From<Ds1> for u8 {
            #[inline(always)]
            fn from(variant: Ds1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ds1 {
            type Ux = u8;
        }
        impl crate::IsEnum for Ds1 {}
        #[doc = "Field `DS1` reader - Data1 source"]
        pub type Ds1R = crate::FieldReader<Ds1>;
        impl Ds1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Ds1> {
                match self.bits {
                    0 => Some(Ds1::Opa0Out),
                    1 => Some(Ds1::AdcCh1),
                    2 => Some(Ds1::AdcCh2),
                    3 => Some(Ds1::AdcCh3),
                    4 => Some(Ds1::AdcCh4),
                    5 => Some(Ds1::AdcCh5),
                    6 => Some(Ds1::AdcCh6),
                    7 => Some(Ds1::AdcCh7),
                    8 => Some(Ds1::AdcCh8),
                    9 => Some(Ds1::AdcCh9),
                    10 => Some(Ds1::AdcCh10),
                    11 => Some(Ds1::Temp),
                    12 => Some(Ds1::Vss),
                    _ => None,
                }
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Ds1::Opa0Out
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn is_adc_ch1(&self) -> bool {
                *self == Ds1::AdcCh1
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn is_adc_ch2(&self) -> bool {
                *self == Ds1::AdcCh2
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn is_adc_ch3(&self) -> bool {
                *self == Ds1::AdcCh3
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn is_adc_ch4(&self) -> bool {
                *self == Ds1::AdcCh4
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn is_adc_ch5(&self) -> bool {
                *self == Ds1::AdcCh5
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn is_adc_ch6(&self) -> bool {
                *self == Ds1::AdcCh6
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn is_adc_ch7(&self) -> bool {
                *self == Ds1::AdcCh7
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn is_adc_ch8(&self) -> bool {
                *self == Ds1::AdcCh8
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn is_adc_ch9(&self) -> bool {
                *self == Ds1::AdcCh9
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn is_adc_ch10(&self) -> bool {
                *self == Ds1::AdcCh10
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == Ds1::Temp
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn is_vss(&self) -> bool {
                *self == Ds1::Vss
            }
        }
        #[doc = "Field `DS1` writer - Data1 source"]
        pub type Ds1W<'a, REG> = crate::FieldWriter<'a, REG, 4, Ds1>;
        impl<'a, REG> Ds1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::Opa0Out)
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn adc_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::AdcCh1)
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn adc_ch2(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::AdcCh2)
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn adc_ch3(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::AdcCh3)
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn adc_ch4(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::AdcCh4)
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn adc_ch5(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::AdcCh5)
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn adc_ch6(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::AdcCh6)
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn adc_ch7(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::AdcCh7)
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn adc_ch8(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::AdcCh8)
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn adc_ch9(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::AdcCh9)
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn adc_ch10(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::AdcCh10)
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::Temp)
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn vss(self) -> &'a mut crate::W<REG> {
                self.variant(Ds1::Vss)
            }
        }
        #[doc = "Data2 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ds2 {
            #[doc = "0: OPA0_OUT"]
            Opa0Out = 0,
            #[doc = "1: ADC_CH1"]
            AdcCh1 = 1,
            #[doc = "2: ADC_CH2"]
            AdcCh2 = 2,
            #[doc = "3: ADC_CH3"]
            AdcCh3 = 3,
            #[doc = "4: ADC_CH4"]
            AdcCh4 = 4,
            #[doc = "5: ADC_CH5"]
            AdcCh5 = 5,
            #[doc = "6: ADC_CH6"]
            AdcCh6 = 6,
            #[doc = "7: ADC_CH7"]
            AdcCh7 = 7,
            #[doc = "8: ADC_CH8"]
            AdcCh8 = 8,
            #[doc = "9: ADC_CH9"]
            AdcCh9 = 9,
            #[doc = "10: ADC_CH10"]
            AdcCh10 = 10,
            #[doc = "11: TEMP"]
            Temp = 11,
            #[doc = "12: VSS"]
            Vss = 12,
        }
        impl From<Ds2> for u8 {
            #[inline(always)]
            fn from(variant: Ds2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ds2 {
            type Ux = u8;
        }
        impl crate::IsEnum for Ds2 {}
        #[doc = "Field `DS2` reader - Data2 source"]
        pub type Ds2R = crate::FieldReader<Ds2>;
        impl Ds2R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Ds2> {
                match self.bits {
                    0 => Some(Ds2::Opa0Out),
                    1 => Some(Ds2::AdcCh1),
                    2 => Some(Ds2::AdcCh2),
                    3 => Some(Ds2::AdcCh3),
                    4 => Some(Ds2::AdcCh4),
                    5 => Some(Ds2::AdcCh5),
                    6 => Some(Ds2::AdcCh6),
                    7 => Some(Ds2::AdcCh7),
                    8 => Some(Ds2::AdcCh8),
                    9 => Some(Ds2::AdcCh9),
                    10 => Some(Ds2::AdcCh10),
                    11 => Some(Ds2::Temp),
                    12 => Some(Ds2::Vss),
                    _ => None,
                }
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Ds2::Opa0Out
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn is_adc_ch1(&self) -> bool {
                *self == Ds2::AdcCh1
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn is_adc_ch2(&self) -> bool {
                *self == Ds2::AdcCh2
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn is_adc_ch3(&self) -> bool {
                *self == Ds2::AdcCh3
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn is_adc_ch4(&self) -> bool {
                *self == Ds2::AdcCh4
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn is_adc_ch5(&self) -> bool {
                *self == Ds2::AdcCh5
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn is_adc_ch6(&self) -> bool {
                *self == Ds2::AdcCh6
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn is_adc_ch7(&self) -> bool {
                *self == Ds2::AdcCh7
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn is_adc_ch8(&self) -> bool {
                *self == Ds2::AdcCh8
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn is_adc_ch9(&self) -> bool {
                *self == Ds2::AdcCh9
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn is_adc_ch10(&self) -> bool {
                *self == Ds2::AdcCh10
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == Ds2::Temp
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn is_vss(&self) -> bool {
                *self == Ds2::Vss
            }
        }
        #[doc = "Field `DS2` writer - Data2 source"]
        pub type Ds2W<'a, REG> = crate::FieldWriter<'a, REG, 4, Ds2>;
        impl<'a, REG> Ds2W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::Opa0Out)
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn adc_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::AdcCh1)
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn adc_ch2(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::AdcCh2)
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn adc_ch3(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::AdcCh3)
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn adc_ch4(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::AdcCh4)
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn adc_ch5(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::AdcCh5)
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn adc_ch6(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::AdcCh6)
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn adc_ch7(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::AdcCh7)
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn adc_ch8(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::AdcCh8)
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn adc_ch9(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::AdcCh9)
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn adc_ch10(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::AdcCh10)
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::Temp)
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn vss(self) -> &'a mut crate::W<REG> {
                self.variant(Ds2::Vss)
            }
        }
        #[doc = "Data3 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ds3 {
            #[doc = "0: OPA0_OUT"]
            Opa0Out = 0,
            #[doc = "1: ADC_CH1"]
            AdcCh1 = 1,
            #[doc = "2: ADC_CH2"]
            AdcCh2 = 2,
            #[doc = "3: ADC_CH3"]
            AdcCh3 = 3,
            #[doc = "4: ADC_CH4"]
            AdcCh4 = 4,
            #[doc = "5: ADC_CH5"]
            AdcCh5 = 5,
            #[doc = "6: ADC_CH6"]
            AdcCh6 = 6,
            #[doc = "7: ADC_CH7"]
            AdcCh7 = 7,
            #[doc = "8: ADC_CH8"]
            AdcCh8 = 8,
            #[doc = "9: ADC_CH9"]
            AdcCh9 = 9,
            #[doc = "10: ADC_CH10"]
            AdcCh10 = 10,
            #[doc = "11: TEMP"]
            Temp = 11,
            #[doc = "12: VSS"]
            Vss = 12,
        }
        impl From<Ds3> for u8 {
            #[inline(always)]
            fn from(variant: Ds3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ds3 {
            type Ux = u8;
        }
        impl crate::IsEnum for Ds3 {}
        #[doc = "Field `DS3` reader - Data3 source"]
        pub type Ds3R = crate::FieldReader<Ds3>;
        impl Ds3R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Ds3> {
                match self.bits {
                    0 => Some(Ds3::Opa0Out),
                    1 => Some(Ds3::AdcCh1),
                    2 => Some(Ds3::AdcCh2),
                    3 => Some(Ds3::AdcCh3),
                    4 => Some(Ds3::AdcCh4),
                    5 => Some(Ds3::AdcCh5),
                    6 => Some(Ds3::AdcCh6),
                    7 => Some(Ds3::AdcCh7),
                    8 => Some(Ds3::AdcCh8),
                    9 => Some(Ds3::AdcCh9),
                    10 => Some(Ds3::AdcCh10),
                    11 => Some(Ds3::Temp),
                    12 => Some(Ds3::Vss),
                    _ => None,
                }
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Ds3::Opa0Out
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn is_adc_ch1(&self) -> bool {
                *self == Ds3::AdcCh1
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn is_adc_ch2(&self) -> bool {
                *self == Ds3::AdcCh2
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn is_adc_ch3(&self) -> bool {
                *self == Ds3::AdcCh3
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn is_adc_ch4(&self) -> bool {
                *self == Ds3::AdcCh4
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn is_adc_ch5(&self) -> bool {
                *self == Ds3::AdcCh5
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn is_adc_ch6(&self) -> bool {
                *self == Ds3::AdcCh6
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn is_adc_ch7(&self) -> bool {
                *self == Ds3::AdcCh7
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn is_adc_ch8(&self) -> bool {
                *self == Ds3::AdcCh8
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn is_adc_ch9(&self) -> bool {
                *self == Ds3::AdcCh9
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn is_adc_ch10(&self) -> bool {
                *self == Ds3::AdcCh10
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == Ds3::Temp
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn is_vss(&self) -> bool {
                *self == Ds3::Vss
            }
        }
        #[doc = "Field `DS3` writer - Data3 source"]
        pub type Ds3W<'a, REG> = crate::FieldWriter<'a, REG, 4, Ds3>;
        impl<'a, REG> Ds3W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::Opa0Out)
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn adc_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::AdcCh1)
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn adc_ch2(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::AdcCh2)
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn adc_ch3(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::AdcCh3)
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn adc_ch4(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::AdcCh4)
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn adc_ch5(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::AdcCh5)
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn adc_ch6(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::AdcCh6)
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn adc_ch7(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::AdcCh7)
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn adc_ch8(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::AdcCh8)
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn adc_ch9(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::AdcCh9)
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn adc_ch10(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::AdcCh10)
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::Temp)
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn vss(self) -> &'a mut crate::W<REG> {
                self.variant(Ds3::Vss)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - Data0 source"]
            #[inline(always)]
            pub fn ds0(&self) -> Ds0R {
                Ds0R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Data1 source"]
            #[inline(always)]
            pub fn ds1(&self) -> Ds1R {
                Ds1R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - Data2 source"]
            #[inline(always)]
            pub fn ds2(&self) -> Ds2R {
                Ds2R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - Data3 source"]
            #[inline(always)]
            pub fn ds3(&self) -> Ds3R {
                Ds3R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Data0 source"]
            #[inline(always)]
            pub fn ds0(&mut self) -> Ds0W<Chn0Spec> {
                Ds0W::new(self, 0)
            }
            #[doc = "Bits 4:7 - Data1 source"]
            #[inline(always)]
            pub fn ds1(&mut self) -> Ds1W<Chn0Spec> {
                Ds1W::new(self, 4)
            }
            #[doc = "Bits 8:11 - Data2 source"]
            #[inline(always)]
            pub fn ds2(&mut self) -> Ds2W<Chn0Spec> {
                Ds2W::new(self, 8)
            }
            #[doc = "Bits 12:15 - Data3 source"]
            #[inline(always)]
            pub fn ds3(&mut self) -> Ds3W<Chn0Spec> {
                Ds3W::new(self, 12)
            }
        }
        #[doc = "ADC data0/1/2/3 source\n\nYou can [`read`](crate::Reg::read) this register and get [`chn0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chn0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Chn0Spec;
        impl crate::RegisterSpec for Chn0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`chn0::R`](R) reader structure"]
        impl crate::Readable for Chn0Spec {}
        #[doc = "`write(|w| ..)` method takes [`chn0::W`](W) writer structure"]
        impl crate::Writable for Chn0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CHN0 to value 0"]
        impl crate::Resettable for Chn0Spec {}
    }
    #[doc = "CHN1 (rw) register accessor: ADC data4/5/6/7 source\n\nYou can [`read`](crate::Reg::read) this register and get [`chn1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chn1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@chn1`] module"]
    #[doc(alias = "CHN1")]
    pub type Chn1 = crate::Reg<chn1::Chn1Spec>;
    #[doc = "ADC data4/5/6/7 source"]
    pub mod chn1 {
        #[doc = "Register `CHN1` reader"]
        pub type R = crate::R<Chn1Spec>;
        #[doc = "Register `CHN1` writer"]
        pub type W = crate::W<Chn1Spec>;
        #[doc = "Data4 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ds4 {
            #[doc = "0: OPA0_OUT"]
            Opa0Out = 0,
            #[doc = "1: ADC_CH1"]
            AdcCh1 = 1,
            #[doc = "2: ADC_CH2"]
            AdcCh2 = 2,
            #[doc = "3: ADC_CH3"]
            AdcCh3 = 3,
            #[doc = "4: ADC_CH4"]
            AdcCh4 = 4,
            #[doc = "5: ADC_CH5"]
            AdcCh5 = 5,
            #[doc = "6: ADC_CH6"]
            AdcCh6 = 6,
            #[doc = "7: ADC_CH7"]
            AdcCh7 = 7,
            #[doc = "8: ADC_CH8"]
            AdcCh8 = 8,
            #[doc = "9: ADC_CH9"]
            AdcCh9 = 9,
            #[doc = "10: ADC_CH10"]
            AdcCh10 = 10,
            #[doc = "11: TEMP"]
            Temp = 11,
            #[doc = "12: VSS"]
            Vss = 12,
        }
        impl From<Ds4> for u8 {
            #[inline(always)]
            fn from(variant: Ds4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ds4 {
            type Ux = u8;
        }
        impl crate::IsEnum for Ds4 {}
        #[doc = "Field `DS4` reader - Data4 source"]
        pub type Ds4R = crate::FieldReader<Ds4>;
        impl Ds4R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Ds4> {
                match self.bits {
                    0 => Some(Ds4::Opa0Out),
                    1 => Some(Ds4::AdcCh1),
                    2 => Some(Ds4::AdcCh2),
                    3 => Some(Ds4::AdcCh3),
                    4 => Some(Ds4::AdcCh4),
                    5 => Some(Ds4::AdcCh5),
                    6 => Some(Ds4::AdcCh6),
                    7 => Some(Ds4::AdcCh7),
                    8 => Some(Ds4::AdcCh8),
                    9 => Some(Ds4::AdcCh9),
                    10 => Some(Ds4::AdcCh10),
                    11 => Some(Ds4::Temp),
                    12 => Some(Ds4::Vss),
                    _ => None,
                }
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Ds4::Opa0Out
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn is_adc_ch1(&self) -> bool {
                *self == Ds4::AdcCh1
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn is_adc_ch2(&self) -> bool {
                *self == Ds4::AdcCh2
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn is_adc_ch3(&self) -> bool {
                *self == Ds4::AdcCh3
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn is_adc_ch4(&self) -> bool {
                *self == Ds4::AdcCh4
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn is_adc_ch5(&self) -> bool {
                *self == Ds4::AdcCh5
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn is_adc_ch6(&self) -> bool {
                *self == Ds4::AdcCh6
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn is_adc_ch7(&self) -> bool {
                *self == Ds4::AdcCh7
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn is_adc_ch8(&self) -> bool {
                *self == Ds4::AdcCh8
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn is_adc_ch9(&self) -> bool {
                *self == Ds4::AdcCh9
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn is_adc_ch10(&self) -> bool {
                *self == Ds4::AdcCh10
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == Ds4::Temp
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn is_vss(&self) -> bool {
                *self == Ds4::Vss
            }
        }
        #[doc = "Field `DS4` writer - Data4 source"]
        pub type Ds4W<'a, REG> = crate::FieldWriter<'a, REG, 4, Ds4>;
        impl<'a, REG> Ds4W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::Opa0Out)
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn adc_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::AdcCh1)
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn adc_ch2(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::AdcCh2)
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn adc_ch3(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::AdcCh3)
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn adc_ch4(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::AdcCh4)
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn adc_ch5(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::AdcCh5)
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn adc_ch6(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::AdcCh6)
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn adc_ch7(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::AdcCh7)
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn adc_ch8(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::AdcCh8)
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn adc_ch9(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::AdcCh9)
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn adc_ch10(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::AdcCh10)
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::Temp)
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn vss(self) -> &'a mut crate::W<REG> {
                self.variant(Ds4::Vss)
            }
        }
        #[doc = "Data5 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ds5 {
            #[doc = "0: OPA0_OUT"]
            Opa0Out = 0,
            #[doc = "1: ADC_CH1"]
            AdcCh1 = 1,
            #[doc = "2: ADC_CH2"]
            AdcCh2 = 2,
            #[doc = "3: ADC_CH3"]
            AdcCh3 = 3,
            #[doc = "4: ADC_CH4"]
            AdcCh4 = 4,
            #[doc = "5: ADC_CH5"]
            AdcCh5 = 5,
            #[doc = "6: ADC_CH6"]
            AdcCh6 = 6,
            #[doc = "7: ADC_CH7"]
            AdcCh7 = 7,
            #[doc = "8: ADC_CH8"]
            AdcCh8 = 8,
            #[doc = "9: ADC_CH9"]
            AdcCh9 = 9,
            #[doc = "10: ADC_CH10"]
            AdcCh10 = 10,
            #[doc = "11: TEMP"]
            Temp = 11,
            #[doc = "12: VSS"]
            Vss = 12,
        }
        impl From<Ds5> for u8 {
            #[inline(always)]
            fn from(variant: Ds5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ds5 {
            type Ux = u8;
        }
        impl crate::IsEnum for Ds5 {}
        #[doc = "Field `DS5` reader - Data5 source"]
        pub type Ds5R = crate::FieldReader<Ds5>;
        impl Ds5R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Ds5> {
                match self.bits {
                    0 => Some(Ds5::Opa0Out),
                    1 => Some(Ds5::AdcCh1),
                    2 => Some(Ds5::AdcCh2),
                    3 => Some(Ds5::AdcCh3),
                    4 => Some(Ds5::AdcCh4),
                    5 => Some(Ds5::AdcCh5),
                    6 => Some(Ds5::AdcCh6),
                    7 => Some(Ds5::AdcCh7),
                    8 => Some(Ds5::AdcCh8),
                    9 => Some(Ds5::AdcCh9),
                    10 => Some(Ds5::AdcCh10),
                    11 => Some(Ds5::Temp),
                    12 => Some(Ds5::Vss),
                    _ => None,
                }
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Ds5::Opa0Out
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn is_adc_ch1(&self) -> bool {
                *self == Ds5::AdcCh1
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn is_adc_ch2(&self) -> bool {
                *self == Ds5::AdcCh2
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn is_adc_ch3(&self) -> bool {
                *self == Ds5::AdcCh3
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn is_adc_ch4(&self) -> bool {
                *self == Ds5::AdcCh4
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn is_adc_ch5(&self) -> bool {
                *self == Ds5::AdcCh5
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn is_adc_ch6(&self) -> bool {
                *self == Ds5::AdcCh6
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn is_adc_ch7(&self) -> bool {
                *self == Ds5::AdcCh7
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn is_adc_ch8(&self) -> bool {
                *self == Ds5::AdcCh8
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn is_adc_ch9(&self) -> bool {
                *self == Ds5::AdcCh9
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn is_adc_ch10(&self) -> bool {
                *self == Ds5::AdcCh10
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == Ds5::Temp
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn is_vss(&self) -> bool {
                *self == Ds5::Vss
            }
        }
        #[doc = "Field `DS5` writer - Data5 source"]
        pub type Ds5W<'a, REG> = crate::FieldWriter<'a, REG, 4, Ds5>;
        impl<'a, REG> Ds5W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::Opa0Out)
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn adc_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::AdcCh1)
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn adc_ch2(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::AdcCh2)
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn adc_ch3(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::AdcCh3)
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn adc_ch4(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::AdcCh4)
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn adc_ch5(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::AdcCh5)
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn adc_ch6(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::AdcCh6)
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn adc_ch7(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::AdcCh7)
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn adc_ch8(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::AdcCh8)
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn adc_ch9(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::AdcCh9)
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn adc_ch10(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::AdcCh10)
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::Temp)
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn vss(self) -> &'a mut crate::W<REG> {
                self.variant(Ds5::Vss)
            }
        }
        #[doc = "Data6 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ds6 {
            #[doc = "0: OPA0_OUT"]
            Opa0Out = 0,
            #[doc = "1: ADC_CH1"]
            AdcCh1 = 1,
            #[doc = "2: ADC_CH2"]
            AdcCh2 = 2,
            #[doc = "3: ADC_CH3"]
            AdcCh3 = 3,
            #[doc = "4: ADC_CH4"]
            AdcCh4 = 4,
            #[doc = "5: ADC_CH5"]
            AdcCh5 = 5,
            #[doc = "6: ADC_CH6"]
            AdcCh6 = 6,
            #[doc = "7: ADC_CH7"]
            AdcCh7 = 7,
            #[doc = "8: ADC_CH8"]
            AdcCh8 = 8,
            #[doc = "9: ADC_CH9"]
            AdcCh9 = 9,
            #[doc = "10: ADC_CH10"]
            AdcCh10 = 10,
            #[doc = "11: TEMP"]
            Temp = 11,
            #[doc = "12: VSS"]
            Vss = 12,
        }
        impl From<Ds6> for u8 {
            #[inline(always)]
            fn from(variant: Ds6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ds6 {
            type Ux = u8;
        }
        impl crate::IsEnum for Ds6 {}
        #[doc = "Field `DS6` reader - Data6 source"]
        pub type Ds6R = crate::FieldReader<Ds6>;
        impl Ds6R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Ds6> {
                match self.bits {
                    0 => Some(Ds6::Opa0Out),
                    1 => Some(Ds6::AdcCh1),
                    2 => Some(Ds6::AdcCh2),
                    3 => Some(Ds6::AdcCh3),
                    4 => Some(Ds6::AdcCh4),
                    5 => Some(Ds6::AdcCh5),
                    6 => Some(Ds6::AdcCh6),
                    7 => Some(Ds6::AdcCh7),
                    8 => Some(Ds6::AdcCh8),
                    9 => Some(Ds6::AdcCh9),
                    10 => Some(Ds6::AdcCh10),
                    11 => Some(Ds6::Temp),
                    12 => Some(Ds6::Vss),
                    _ => None,
                }
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Ds6::Opa0Out
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn is_adc_ch1(&self) -> bool {
                *self == Ds6::AdcCh1
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn is_adc_ch2(&self) -> bool {
                *self == Ds6::AdcCh2
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn is_adc_ch3(&self) -> bool {
                *self == Ds6::AdcCh3
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn is_adc_ch4(&self) -> bool {
                *self == Ds6::AdcCh4
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn is_adc_ch5(&self) -> bool {
                *self == Ds6::AdcCh5
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn is_adc_ch6(&self) -> bool {
                *self == Ds6::AdcCh6
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn is_adc_ch7(&self) -> bool {
                *self == Ds6::AdcCh7
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn is_adc_ch8(&self) -> bool {
                *self == Ds6::AdcCh8
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn is_adc_ch9(&self) -> bool {
                *self == Ds6::AdcCh9
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn is_adc_ch10(&self) -> bool {
                *self == Ds6::AdcCh10
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == Ds6::Temp
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn is_vss(&self) -> bool {
                *self == Ds6::Vss
            }
        }
        #[doc = "Field `DS6` writer - Data6 source"]
        pub type Ds6W<'a, REG> = crate::FieldWriter<'a, REG, 4, Ds6>;
        impl<'a, REG> Ds6W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::Opa0Out)
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn adc_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::AdcCh1)
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn adc_ch2(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::AdcCh2)
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn adc_ch3(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::AdcCh3)
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn adc_ch4(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::AdcCh4)
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn adc_ch5(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::AdcCh5)
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn adc_ch6(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::AdcCh6)
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn adc_ch7(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::AdcCh7)
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn adc_ch8(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::AdcCh8)
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn adc_ch9(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::AdcCh9)
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn adc_ch10(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::AdcCh10)
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::Temp)
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn vss(self) -> &'a mut crate::W<REG> {
                self.variant(Ds6::Vss)
            }
        }
        #[doc = "Data7 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ds7 {
            #[doc = "0: OPA0_OUT"]
            Opa0Out = 0,
            #[doc = "1: ADC_CH1"]
            AdcCh1 = 1,
            #[doc = "2: ADC_CH2"]
            AdcCh2 = 2,
            #[doc = "3: ADC_CH3"]
            AdcCh3 = 3,
            #[doc = "4: ADC_CH4"]
            AdcCh4 = 4,
            #[doc = "5: ADC_CH5"]
            AdcCh5 = 5,
            #[doc = "6: ADC_CH6"]
            AdcCh6 = 6,
            #[doc = "7: ADC_CH7"]
            AdcCh7 = 7,
            #[doc = "8: ADC_CH8"]
            AdcCh8 = 8,
            #[doc = "9: ADC_CH9"]
            AdcCh9 = 9,
            #[doc = "10: ADC_CH10"]
            AdcCh10 = 10,
            #[doc = "11: TEMP"]
            Temp = 11,
            #[doc = "12: VSS"]
            Vss = 12,
        }
        impl From<Ds7> for u8 {
            #[inline(always)]
            fn from(variant: Ds7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ds7 {
            type Ux = u8;
        }
        impl crate::IsEnum for Ds7 {}
        #[doc = "Field `DS7` reader - Data7 source"]
        pub type Ds7R = crate::FieldReader<Ds7>;
        impl Ds7R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Ds7> {
                match self.bits {
                    0 => Some(Ds7::Opa0Out),
                    1 => Some(Ds7::AdcCh1),
                    2 => Some(Ds7::AdcCh2),
                    3 => Some(Ds7::AdcCh3),
                    4 => Some(Ds7::AdcCh4),
                    5 => Some(Ds7::AdcCh5),
                    6 => Some(Ds7::AdcCh6),
                    7 => Some(Ds7::AdcCh7),
                    8 => Some(Ds7::AdcCh8),
                    9 => Some(Ds7::AdcCh9),
                    10 => Some(Ds7::AdcCh10),
                    11 => Some(Ds7::Temp),
                    12 => Some(Ds7::Vss),
                    _ => None,
                }
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Ds7::Opa0Out
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn is_adc_ch1(&self) -> bool {
                *self == Ds7::AdcCh1
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn is_adc_ch2(&self) -> bool {
                *self == Ds7::AdcCh2
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn is_adc_ch3(&self) -> bool {
                *self == Ds7::AdcCh3
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn is_adc_ch4(&self) -> bool {
                *self == Ds7::AdcCh4
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn is_adc_ch5(&self) -> bool {
                *self == Ds7::AdcCh5
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn is_adc_ch6(&self) -> bool {
                *self == Ds7::AdcCh6
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn is_adc_ch7(&self) -> bool {
                *self == Ds7::AdcCh7
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn is_adc_ch8(&self) -> bool {
                *self == Ds7::AdcCh8
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn is_adc_ch9(&self) -> bool {
                *self == Ds7::AdcCh9
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn is_adc_ch10(&self) -> bool {
                *self == Ds7::AdcCh10
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == Ds7::Temp
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn is_vss(&self) -> bool {
                *self == Ds7::Vss
            }
        }
        #[doc = "Field `DS7` writer - Data7 source"]
        pub type Ds7W<'a, REG> = crate::FieldWriter<'a, REG, 4, Ds7>;
        impl<'a, REG> Ds7W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::Opa0Out)
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn adc_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::AdcCh1)
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn adc_ch2(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::AdcCh2)
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn adc_ch3(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::AdcCh3)
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn adc_ch4(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::AdcCh4)
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn adc_ch5(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::AdcCh5)
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn adc_ch6(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::AdcCh6)
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn adc_ch7(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::AdcCh7)
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn adc_ch8(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::AdcCh8)
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn adc_ch9(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::AdcCh9)
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn adc_ch10(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::AdcCh10)
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::Temp)
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn vss(self) -> &'a mut crate::W<REG> {
                self.variant(Ds7::Vss)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - Data4 source"]
            #[inline(always)]
            pub fn ds4(&self) -> Ds4R {
                Ds4R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Data5 source"]
            #[inline(always)]
            pub fn ds5(&self) -> Ds5R {
                Ds5R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - Data6 source"]
            #[inline(always)]
            pub fn ds6(&self) -> Ds6R {
                Ds6R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - Data7 source"]
            #[inline(always)]
            pub fn ds7(&self) -> Ds7R {
                Ds7R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Data4 source"]
            #[inline(always)]
            pub fn ds4(&mut self) -> Ds4W<Chn1Spec> {
                Ds4W::new(self, 0)
            }
            #[doc = "Bits 4:7 - Data5 source"]
            #[inline(always)]
            pub fn ds5(&mut self) -> Ds5W<Chn1Spec> {
                Ds5W::new(self, 4)
            }
            #[doc = "Bits 8:11 - Data6 source"]
            #[inline(always)]
            pub fn ds6(&mut self) -> Ds6W<Chn1Spec> {
                Ds6W::new(self, 8)
            }
            #[doc = "Bits 12:15 - Data7 source"]
            #[inline(always)]
            pub fn ds7(&mut self) -> Ds7W<Chn1Spec> {
                Ds7W::new(self, 12)
            }
        }
        #[doc = "ADC data4/5/6/7 source\n\nYou can [`read`](crate::Reg::read) this register and get [`chn1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chn1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Chn1Spec;
        impl crate::RegisterSpec for Chn1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`chn1::R`](R) reader structure"]
        impl crate::Readable for Chn1Spec {}
        #[doc = "`write(|w| ..)` method takes [`chn1::W`](W) writer structure"]
        impl crate::Writable for Chn1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CHN1 to value 0"]
        impl crate::Resettable for Chn1Spec {}
    }
    #[doc = "CHN2 (rw) register accessor: ADC data8/9 source\n\nYou can [`read`](crate::Reg::read) this register and get [`chn2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chn2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@chn2`] module"]
    #[doc(alias = "CHN2")]
    pub type Chn2 = crate::Reg<chn2::Chn2Spec>;
    #[doc = "ADC data8/9 source"]
    pub mod chn2 {
        #[doc = "Register `CHN2` reader"]
        pub type R = crate::R<Chn2Spec>;
        #[doc = "Register `CHN2` writer"]
        pub type W = crate::W<Chn2Spec>;
        #[doc = "Data8 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ds8 {
            #[doc = "0: OPA0_OUT"]
            Opa0Out = 0,
            #[doc = "1: ADC_CH1"]
            AdcCh1 = 1,
            #[doc = "2: ADC_CH2"]
            AdcCh2 = 2,
            #[doc = "3: ADC_CH3"]
            AdcCh3 = 3,
            #[doc = "4: ADC_CH4"]
            AdcCh4 = 4,
            #[doc = "5: ADC_CH5"]
            AdcCh5 = 5,
            #[doc = "6: ADC_CH6"]
            AdcCh6 = 6,
            #[doc = "7: ADC_CH7"]
            AdcCh7 = 7,
            #[doc = "8: ADC_CH8"]
            AdcCh8 = 8,
            #[doc = "9: ADC_CH9"]
            AdcCh9 = 9,
            #[doc = "10: ADC_CH10"]
            AdcCh10 = 10,
            #[doc = "11: TEMP"]
            Temp = 11,
            #[doc = "12: VSS"]
            Vss = 12,
        }
        impl From<Ds8> for u8 {
            #[inline(always)]
            fn from(variant: Ds8) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ds8 {
            type Ux = u8;
        }
        impl crate::IsEnum for Ds8 {}
        #[doc = "Field `DS8` reader - Data8 source"]
        pub type Ds8R = crate::FieldReader<Ds8>;
        impl Ds8R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Ds8> {
                match self.bits {
                    0 => Some(Ds8::Opa0Out),
                    1 => Some(Ds8::AdcCh1),
                    2 => Some(Ds8::AdcCh2),
                    3 => Some(Ds8::AdcCh3),
                    4 => Some(Ds8::AdcCh4),
                    5 => Some(Ds8::AdcCh5),
                    6 => Some(Ds8::AdcCh6),
                    7 => Some(Ds8::AdcCh7),
                    8 => Some(Ds8::AdcCh8),
                    9 => Some(Ds8::AdcCh9),
                    10 => Some(Ds8::AdcCh10),
                    11 => Some(Ds8::Temp),
                    12 => Some(Ds8::Vss),
                    _ => None,
                }
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Ds8::Opa0Out
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn is_adc_ch1(&self) -> bool {
                *self == Ds8::AdcCh1
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn is_adc_ch2(&self) -> bool {
                *self == Ds8::AdcCh2
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn is_adc_ch3(&self) -> bool {
                *self == Ds8::AdcCh3
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn is_adc_ch4(&self) -> bool {
                *self == Ds8::AdcCh4
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn is_adc_ch5(&self) -> bool {
                *self == Ds8::AdcCh5
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn is_adc_ch6(&self) -> bool {
                *self == Ds8::AdcCh6
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn is_adc_ch7(&self) -> bool {
                *self == Ds8::AdcCh7
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn is_adc_ch8(&self) -> bool {
                *self == Ds8::AdcCh8
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn is_adc_ch9(&self) -> bool {
                *self == Ds8::AdcCh9
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn is_adc_ch10(&self) -> bool {
                *self == Ds8::AdcCh10
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == Ds8::Temp
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn is_vss(&self) -> bool {
                *self == Ds8::Vss
            }
        }
        #[doc = "Field `DS8` writer - Data8 source"]
        pub type Ds8W<'a, REG> = crate::FieldWriter<'a, REG, 4, Ds8>;
        impl<'a, REG> Ds8W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::Opa0Out)
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn adc_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::AdcCh1)
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn adc_ch2(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::AdcCh2)
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn adc_ch3(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::AdcCh3)
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn adc_ch4(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::AdcCh4)
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn adc_ch5(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::AdcCh5)
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn adc_ch6(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::AdcCh6)
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn adc_ch7(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::AdcCh7)
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn adc_ch8(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::AdcCh8)
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn adc_ch9(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::AdcCh9)
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn adc_ch10(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::AdcCh10)
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::Temp)
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn vss(self) -> &'a mut crate::W<REG> {
                self.variant(Ds8::Vss)
            }
        }
        #[doc = "Data9 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ds9 {
            #[doc = "0: OPA0_OUT"]
            Opa0Out = 0,
            #[doc = "1: ADC_CH1"]
            AdcCh1 = 1,
            #[doc = "2: ADC_CH2"]
            AdcCh2 = 2,
            #[doc = "3: ADC_CH3"]
            AdcCh3 = 3,
            #[doc = "4: ADC_CH4"]
            AdcCh4 = 4,
            #[doc = "5: ADC_CH5"]
            AdcCh5 = 5,
            #[doc = "6: ADC_CH6"]
            AdcCh6 = 6,
            #[doc = "7: ADC_CH7"]
            AdcCh7 = 7,
            #[doc = "8: ADC_CH8"]
            AdcCh8 = 8,
            #[doc = "9: ADC_CH9"]
            AdcCh9 = 9,
            #[doc = "10: ADC_CH10"]
            AdcCh10 = 10,
            #[doc = "11: TEMP"]
            Temp = 11,
            #[doc = "12: VSS"]
            Vss = 12,
        }
        impl From<Ds9> for u8 {
            #[inline(always)]
            fn from(variant: Ds9) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ds9 {
            type Ux = u8;
        }
        impl crate::IsEnum for Ds9 {}
        #[doc = "Field `DS9` reader - Data9 source"]
        pub type Ds9R = crate::FieldReader<Ds9>;
        impl Ds9R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Ds9> {
                match self.bits {
                    0 => Some(Ds9::Opa0Out),
                    1 => Some(Ds9::AdcCh1),
                    2 => Some(Ds9::AdcCh2),
                    3 => Some(Ds9::AdcCh3),
                    4 => Some(Ds9::AdcCh4),
                    5 => Some(Ds9::AdcCh5),
                    6 => Some(Ds9::AdcCh6),
                    7 => Some(Ds9::AdcCh7),
                    8 => Some(Ds9::AdcCh8),
                    9 => Some(Ds9::AdcCh9),
                    10 => Some(Ds9::AdcCh10),
                    11 => Some(Ds9::Temp),
                    12 => Some(Ds9::Vss),
                    _ => None,
                }
            }
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn is_opa0_out(&self) -> bool {
                *self == Ds9::Opa0Out
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn is_adc_ch1(&self) -> bool {
                *self == Ds9::AdcCh1
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn is_adc_ch2(&self) -> bool {
                *self == Ds9::AdcCh2
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn is_adc_ch3(&self) -> bool {
                *self == Ds9::AdcCh3
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn is_adc_ch4(&self) -> bool {
                *self == Ds9::AdcCh4
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn is_adc_ch5(&self) -> bool {
                *self == Ds9::AdcCh5
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn is_adc_ch6(&self) -> bool {
                *self == Ds9::AdcCh6
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn is_adc_ch7(&self) -> bool {
                *self == Ds9::AdcCh7
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn is_adc_ch8(&self) -> bool {
                *self == Ds9::AdcCh8
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn is_adc_ch9(&self) -> bool {
                *self == Ds9::AdcCh9
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn is_adc_ch10(&self) -> bool {
                *self == Ds9::AdcCh10
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == Ds9::Temp
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn is_vss(&self) -> bool {
                *self == Ds9::Vss
            }
        }
        #[doc = "Field `DS9` writer - Data9 source"]
        pub type Ds9W<'a, REG> = crate::FieldWriter<'a, REG, 4, Ds9>;
        impl<'a, REG> Ds9W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "OPA0_OUT"]
            #[inline(always)]
            pub fn opa0_out(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::Opa0Out)
            }
            #[doc = "ADC_CH1"]
            #[inline(always)]
            pub fn adc_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::AdcCh1)
            }
            #[doc = "ADC_CH2"]
            #[inline(always)]
            pub fn adc_ch2(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::AdcCh2)
            }
            #[doc = "ADC_CH3"]
            #[inline(always)]
            pub fn adc_ch3(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::AdcCh3)
            }
            #[doc = "ADC_CH4"]
            #[inline(always)]
            pub fn adc_ch4(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::AdcCh4)
            }
            #[doc = "ADC_CH5"]
            #[inline(always)]
            pub fn adc_ch5(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::AdcCh5)
            }
            #[doc = "ADC_CH6"]
            #[inline(always)]
            pub fn adc_ch6(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::AdcCh6)
            }
            #[doc = "ADC_CH7"]
            #[inline(always)]
            pub fn adc_ch7(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::AdcCh7)
            }
            #[doc = "ADC_CH8"]
            #[inline(always)]
            pub fn adc_ch8(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::AdcCh8)
            }
            #[doc = "ADC_CH9"]
            #[inline(always)]
            pub fn adc_ch9(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::AdcCh9)
            }
            #[doc = "ADC_CH10"]
            #[inline(always)]
            pub fn adc_ch10(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::AdcCh10)
            }
            #[doc = "TEMP"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::Temp)
            }
            #[doc = "VSS"]
            #[inline(always)]
            pub fn vss(self) -> &'a mut crate::W<REG> {
                self.variant(Ds9::Vss)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - Data8 source"]
            #[inline(always)]
            pub fn ds8(&self) -> Ds8R {
                Ds8R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Data9 source"]
            #[inline(always)]
            pub fn ds9(&self) -> Ds9R {
                Ds9R::new(((self.bits >> 4) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Data8 source"]
            #[inline(always)]
            pub fn ds8(&mut self) -> Ds8W<Chn2Spec> {
                Ds8W::new(self, 0)
            }
            #[doc = "Bits 4:7 - Data9 source"]
            #[inline(always)]
            pub fn ds9(&mut self) -> Ds9W<Chn2Spec> {
                Ds9W::new(self, 4)
            }
        }
        #[doc = "ADC data8/9 source\n\nYou can [`read`](crate::Reg::read) this register and get [`chn2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chn2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Chn2Spec;
        impl crate::RegisterSpec for Chn2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`chn2::R`](R) reader structure"]
        impl crate::Readable for Chn2Spec {}
        #[doc = "`write(|w| ..)` method takes [`chn2::W`](W) writer structure"]
        impl crate::Writable for Chn2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CHN2 to value 0"]
        impl crate::Resettable for Chn2Spec {}
    }
    #[doc = "CHNT (rw) register accessor: ADC channel numbers\n\nYou can [`read`](crate::Reg::read) this register and get [`chnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@chnt`] module"]
    #[doc(alias = "CHNT")]
    pub type Chnt = crate::Reg<chnt::ChntSpec>;
    #[doc = "ADC channel numbers"]
    pub mod chnt {
        #[doc = "Register `CHNT` reader"]
        pub type R = crate::R<ChntSpec>;
        #[doc = "Register `CHNT` writer"]
        pub type W = crate::W<ChntSpec>;
        #[doc = "Field `S1` reader - 1st segment sample times"]
        pub type S1R = crate::FieldReader;
        #[doc = "Field `S1` writer - 1st segment sample times"]
        pub type S1W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `S2` reader - 2nd segment sample times"]
        pub type S2R = crate::FieldReader;
        #[doc = "Field `S2` writer - 2nd segment sample times"]
        pub type S2W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `S3` reader - 3rd segment sample times"]
        pub type S3R = crate::FieldReader;
        #[doc = "Field `S3` writer - 3rd segment sample times"]
        pub type S3W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `S4` reader - 4th segment sample times"]
        pub type S4R = crate::FieldReader;
        #[doc = "Field `S4` writer - 4th segment sample times"]
        pub type S4W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - 1st segment sample times"]
            #[inline(always)]
            pub fn s1(&self) -> S1R {
                S1R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - 2nd segment sample times"]
            #[inline(always)]
            pub fn s2(&self) -> S2R {
                S2R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - 3rd segment sample times"]
            #[inline(always)]
            pub fn s3(&self) -> S3R {
                S3R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - 4th segment sample times"]
            #[inline(always)]
            pub fn s4(&self) -> S4R {
                S4R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - 1st segment sample times"]
            #[inline(always)]
            pub fn s1(&mut self) -> S1W<ChntSpec> {
                S1W::new(self, 0)
            }
            #[doc = "Bits 4:7 - 2nd segment sample times"]
            #[inline(always)]
            pub fn s2(&mut self) -> S2W<ChntSpec> {
                S2W::new(self, 4)
            }
            #[doc = "Bits 8:11 - 3rd segment sample times"]
            #[inline(always)]
            pub fn s3(&mut self) -> S3W<ChntSpec> {
                S3W::new(self, 8)
            }
            #[doc = "Bits 12:15 - 4th segment sample times"]
            #[inline(always)]
            pub fn s4(&mut self) -> S4W<ChntSpec> {
                S4W::new(self, 12)
            }
        }
        #[doc = "ADC channel numbers\n\nYou can [`read`](crate::Reg::read) this register and get [`chnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ChntSpec;
        impl crate::RegisterSpec for ChntSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`chnt::R`](R) reader structure"]
        impl crate::Readable for ChntSpec {}
        #[doc = "`write(|w| ..)` method takes [`chnt::W`](W) writer structure"]
        impl crate::Writable for ChntSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CHNT to value 0"]
        impl crate::Resettable for ChntSpec {}
    }
    #[doc = "CFG (rw) register accessor: ADC configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"]
    #[doc(alias = "CFG")]
    pub type Cfg = crate::Reg<cfg::CfgSpec>;
    #[doc = "ADC configuration"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CfgSpec>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CfgSpec>;
        #[doc = "Field `TRG_EN` reader - trigger enable"]
        pub type TrgEnR = crate::FieldReader;
        #[doc = "Field `TRG_EN` writer - trigger enable"]
        pub type TrgEnW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `SINGLE_TCNT` reader - single segment trigger counter"]
        pub type SingleTcntR = crate::FieldReader;
        #[doc = "Field `SINGLE_TCNT` writer - single segment trigger counter"]
        pub type SingleTcntW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "trigger mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TrgMode {
            #[doc = "0: One round sample"]
            OneRound = 0,
            #[doc = "1: Two rounds sample"]
            TwoRound = 1,
            #[doc = "3: Four rounds sample"]
            FourRound = 3,
        }
        impl From<TrgMode> for u8 {
            #[inline(always)]
            fn from(variant: TrgMode) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TrgMode {
            type Ux = u8;
        }
        impl crate::IsEnum for TrgMode {}
        #[doc = "Field `TRG_MODE` reader - trigger mode"]
        pub type TrgModeR = crate::FieldReader<TrgMode>;
        impl TrgModeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<TrgMode> {
                match self.bits {
                    0 => Some(TrgMode::OneRound),
                    1 => Some(TrgMode::TwoRound),
                    3 => Some(TrgMode::FourRound),
                    _ => None,
                }
            }
            #[doc = "One round sample"]
            #[inline(always)]
            pub fn is_one_round(&self) -> bool {
                *self == TrgMode::OneRound
            }
            #[doc = "Two rounds sample"]
            #[inline(always)]
            pub fn is_two_round(&self) -> bool {
                *self == TrgMode::TwoRound
            }
            #[doc = "Four rounds sample"]
            #[inline(always)]
            pub fn is_four_round(&self) -> bool {
                *self == TrgMode::FourRound
            }
        }
        #[doc = "Field `TRG_MODE` writer - trigger mode"]
        pub type TrgModeW<'a, REG> = crate::FieldWriter<'a, REG, 2, TrgMode>;
        impl<'a, REG> TrgModeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "One round sample"]
            #[inline(always)]
            pub fn one_round(self) -> &'a mut crate::W<REG> {
                self.variant(TrgMode::OneRound)
            }
            #[doc = "Two rounds sample"]
            #[inline(always)]
            pub fn two_round(self) -> &'a mut crate::W<REG> {
                self.variant(TrgMode::TwoRound)
            }
            #[doc = "Four rounds sample"]
            #[inline(always)]
            pub fn four_round(self) -> &'a mut crate::W<REG> {
                self.variant(TrgMode::FourRound)
            }
        }
        #[doc = "ADC data alignment\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DataAlign {
            #[doc = "0: left alignment, padding with 4'b0"]
            Left = 0,
            #[doc = "1: right alignment, sign bit extension at head"]
            Right = 1,
        }
        impl From<DataAlign> for bool {
            #[inline(always)]
            fn from(variant: DataAlign) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DATA_ALIGN` reader - ADC data alignment"]
        pub type DataAlignR = crate::BitReader<DataAlign>;
        impl DataAlignR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DataAlign {
                match self.bits {
                    false => DataAlign::Left,
                    true => DataAlign::Right,
                }
            }
            #[doc = "left alignment, padding with 4'b0"]
            #[inline(always)]
            pub fn is_left(&self) -> bool {
                *self == DataAlign::Left
            }
            #[doc = "right alignment, sign bit extension at head"]
            #[inline(always)]
            pub fn is_right(&self) -> bool {
                *self == DataAlign::Right
            }
        }
        #[doc = "Field `DATA_ALIGN` writer - ADC data alignment"]
        pub type DataAlignW<'a, REG> = crate::BitWriter<'a, REG, DataAlign>;
        impl<'a, REG> DataAlignW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "left alignment, padding with 4'b0"]
            #[inline(always)]
            pub fn left(self) -> &'a mut crate::W<REG> {
                self.variant(DataAlign::Left)
            }
            #[doc = "right alignment, sign bit extension at head"]
            #[inline(always)]
            pub fn right(self) -> &'a mut crate::W<REG> {
                self.variant(DataAlign::Right)
            }
        }
        #[doc = "Field `FSM_RESET` reader - sample state machine reset"]
        pub type FsmResetR = crate::BitReader;
        #[doc = "Field `FSM_RESET` writer - sample state machine reset"]
        pub type FsmResetW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "ADC Trigger source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sel {
            #[doc = "0: MCPWM trigger"]
            Mcpwm = 0,
            #[doc = "1: Utimer trigger"]
            Utimer = 1,
        }
        impl From<Sel> for bool {
            #[inline(always)]
            fn from(variant: Sel) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SEL` reader - ADC Trigger source"]
        pub type SelR = crate::BitReader<Sel>;
        impl SelR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sel {
                match self.bits {
                    false => Sel::Mcpwm,
                    true => Sel::Utimer,
                }
            }
            #[doc = "MCPWM trigger"]
            #[inline(always)]
            pub fn is_mcpwm(&self) -> bool {
                *self == Sel::Mcpwm
            }
            #[doc = "Utimer trigger"]
            #[inline(always)]
            pub fn is_utimer(&self) -> bool {
                *self == Sel::Utimer
            }
        }
        #[doc = "Field `SEL` writer - ADC Trigger source"]
        pub type SelW<'a, REG> = crate::BitWriter<'a, REG, Sel>;
        impl<'a, REG> SelW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "MCPWM trigger"]
            #[inline(always)]
            pub fn mcpwm(self) -> &'a mut crate::W<REG> {
                self.variant(Sel::Mcpwm)
            }
            #[doc = "Utimer trigger"]
            #[inline(always)]
            pub fn utimer(self) -> &'a mut crate::W<REG> {
                self.variant(Sel::Utimer)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - trigger enable"]
            #[inline(always)]
            pub fn trg_en(&self) -> TrgEnR {
                TrgEnR::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - single segment trigger counter"]
            #[inline(always)]
            pub fn single_tcnt(&self) -> SingleTcntR {
                SingleTcntR::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:9 - trigger mode"]
            #[inline(always)]
            pub fn trg_mode(&self) -> TrgModeR {
                TrgModeR::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bit 10 - ADC data alignment"]
            #[inline(always)]
            pub fn data_align(&self) -> DataAlignR {
                DataAlignR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - sample state machine reset"]
            #[inline(always)]
            pub fn fsm_reset(&self) -> FsmResetR {
                FsmResetR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - ADC Trigger source"]
            #[inline(always)]
            pub fn sel(&self) -> SelR {
                SelR::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - trigger enable"]
            #[inline(always)]
            pub fn trg_en(&mut self) -> TrgEnW<CfgSpec> {
                TrgEnW::new(self, 0)
            }
            #[doc = "Bits 4:7 - single segment trigger counter"]
            #[inline(always)]
            pub fn single_tcnt(&mut self) -> SingleTcntW<CfgSpec> {
                SingleTcntW::new(self, 4)
            }
            #[doc = "Bits 8:9 - trigger mode"]
            #[inline(always)]
            pub fn trg_mode(&mut self) -> TrgModeW<CfgSpec> {
                TrgModeW::new(self, 8)
            }
            #[doc = "Bit 10 - ADC data alignment"]
            #[inline(always)]
            pub fn data_align(&mut self) -> DataAlignW<CfgSpec> {
                DataAlignW::new(self, 10)
            }
            #[doc = "Bit 11 - sample state machine reset"]
            #[inline(always)]
            pub fn fsm_reset(&mut self) -> FsmResetW<CfgSpec> {
                FsmResetW::new(self, 11)
            }
            #[doc = "Bit 12 - ADC Trigger source"]
            #[inline(always)]
            pub fn sel(&mut self) -> SelW<CfgSpec> {
                SelW::new(self, 12)
            }
        }
        #[doc = "ADC configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgSpec;
        impl crate::RegisterSpec for CfgSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFG to value 0"]
        impl crate::Resettable for CfgSpec {}
    }
    #[doc = "SWT (w) register accessor: ADC software trigger\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swt::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@swt`] module"]
    #[doc(alias = "SWT")]
    pub type Swt = crate::Reg<swt::SwtSpec>;
    #[doc = "ADC software trigger"]
    pub mod swt {
        #[doc = "Register `SWT` writer"]
        pub type W = crate::W<SwtSpec>;
        #[doc = "write 0x5AA5 to trigger ADC sample\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u16)]
        pub enum Swt {
            #[doc = "23205: Trigger password"]
            Trg = 23205,
        }
        impl From<Swt> for u16 {
            #[inline(always)]
            fn from(variant: Swt) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Swt {
            type Ux = u16;
        }
        impl crate::IsEnum for Swt {}
        #[doc = "Field `SWT` writer - write 0x5AA5 to trigger ADC sample"]
        pub type SwtW<'a, REG> = crate::FieldWriter<'a, REG, 16, Swt>;
        impl<'a, REG> SwtW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u16>,
        {
            #[doc = "Trigger password"]
            #[inline(always)]
            pub fn trg(self) -> &'a mut crate::W<REG> {
                self.variant(Swt::Trg)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - write 0x5AA5 to trigger ADC sample"]
            #[inline(always)]
            pub fn swt(&mut self) -> SwtW<SwtSpec> {
                SwtW::new(self, 0)
            }
        }
        #[doc = "ADC software trigger\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swt::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SwtSpec;
        impl crate::RegisterSpec for SwtSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`swt::W`](W) writer structure"]
        impl crate::Writable for SwtSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SWT to value 0"]
        impl crate::Resettable for SwtSpec {}
    }
    #[doc = "DC (rw) register accessor: ADC DC offset of sample circuit A for low gain\n\nYou can [`read`](crate::Reg::read) this register and get [`dc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dc`] module"]
    #[doc(alias = "DC")]
    pub type Dc = crate::Reg<dc::DcSpec>;
    #[doc = "ADC DC offset of sample circuit A for low gain"]
    pub mod dc {
        #[doc = "Register `DC` reader"]
        pub type R = crate::R<DcSpec>;
        #[doc = "Register `DC` writer"]
        pub type W = crate::W<DcSpec>;
        #[doc = "Field `OFFSET` reader - DC offset value"]
        pub type OffsetR = crate::FieldReader;
        #[doc = "Field `OFFSET` writer - DC offset value"]
        pub type OffsetW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - DC offset value"]
            #[inline(always)]
            pub fn offset(&self) -> OffsetR {
                OffsetR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - DC offset value"]
            #[inline(always)]
            pub fn offset(&mut self) -> OffsetW<DcSpec> {
                OffsetW::new(self, 0)
            }
        }
        #[doc = "ADC DC offset of sample circuit A for low gain\n\nYou can [`read`](crate::Reg::read) this register and get [`dc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DcSpec;
        impl crate::RegisterSpec for DcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dc::R`](R) reader structure"]
        impl crate::Readable for DcSpec {}
        #[doc = "`write(|w| ..)` method takes [`dc::W`](W) writer structure"]
        impl crate::Writable for DcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DC to value 0"]
        impl crate::Resettable for DcSpec {}
    }
    #[doc = "AMC (rw) register accessor: ADC amplification calibration of sample circuit A for low gain\n\nYou can [`read`](crate::Reg::read) this register and get [`amc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`amc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@amc`] module"]
    #[doc(alias = "AMC")]
    pub type Amc = crate::Reg<amc::AmcSpec>;
    #[doc = "ADC amplification calibration of sample circuit A for low gain"]
    pub mod amc {
        #[doc = "Register `AMC` reader"]
        pub type R = crate::R<AmcSpec>;
        #[doc = "Register `AMC` writer"]
        pub type W = crate::W<AmcSpec>;
        #[doc = "Field `AM` reader - Amplification calibration value"]
        pub type AmR = crate::FieldReader<u16>;
        #[doc = "Field `AM` writer - Amplification calibration value"]
        pub type AmW<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        impl R {
            #[doc = "Bits 0:9 - Amplification calibration value"]
            #[inline(always)]
            pub fn am(&self) -> AmR {
                AmR::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:9 - Amplification calibration value"]
            #[inline(always)]
            pub fn am(&mut self) -> AmW<AmcSpec> {
                AmW::new(self, 0)
            }
        }
        #[doc = "ADC amplification calibration of sample circuit A for low gain\n\nYou can [`read`](crate::Reg::read) this register and get [`amc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`amc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AmcSpec;
        impl crate::RegisterSpec for AmcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`amc::R`](R) reader structure"]
        impl crate::Readable for AmcSpec {}
        #[doc = "`write(|w| ..)` method takes [`amc::W`](W) writer structure"]
        impl crate::Writable for AmcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AMC to value 0x0200"]
        impl crate::Resettable for AmcSpec {
            const RESET_VALUE: u32 = 0x0200;
        }
    }
    #[doc = "IE (rw) register accessor: ADC interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie`] module"]
    #[doc(alias = "IE")]
    pub type Ie = crate::Reg<ie::IeSpec>;
    #[doc = "ADC interrupt enable"]
    pub mod ie {
        #[doc = "Register `IE` reader"]
        pub type R = crate::R<IeSpec>;
        #[doc = "Register `IE` writer"]
        pub type W = crate::W<IeSpec>;
        #[doc = "Field `S1_IE` reader - 1st segment sample finish interrupt enable"]
        pub type S1IeR = crate::BitReader;
        #[doc = "Field `S1_IE` writer - 1st segment sample finish interrupt enable"]
        pub type S1IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `S2_IE` reader - 2nd segment sample finish interrupt enable"]
        pub type S2IeR = crate::BitReader;
        #[doc = "Field `S2_IE` writer - 2nd segment sample finish interrupt enable"]
        pub type S2IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `S3_IE` reader - 3rd segment sample finish interrupt enable"]
        pub type S3IeR = crate::BitReader;
        #[doc = "Field `S3_IE` writer - 3rd segment sample finish interrupt enable"]
        pub type S3IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `S4_IE` reader - 4th segment sample finish interrupt enable"]
        pub type S4IeR = crate::BitReader;
        #[doc = "Field `S4_IE` writer - 4th segment sample finish interrupt enable"]
        pub type S4IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SERR_IE` reader - Software trigger error interrupt enable"]
        pub type SerrIeR = crate::BitReader;
        #[doc = "Field `SERR_IE` writer - Software trigger error interrupt enable"]
        pub type SerrIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HERR_IE` reader - Hardware trigger error interrupt enable"]
        pub type HerrIeR = crate::BitReader;
        #[doc = "Field `HERR_IE` writer - Hardware trigger error interrupt enable"]
        pub type HerrIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `AWD_IE` reader - ADC_DATx out of range interrrup enable"]
        pub type AwdIeR = crate::BitReader;
        #[doc = "Field `AWD_IE` writer - ADC_DATx out of range interrrup enable"]
        pub type AwdIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `S1_RE` reader - 1st segment sample finish interrupt enable"]
        pub type S1ReR = crate::BitReader;
        #[doc = "Field `S1_RE` writer - 1st segment sample finish interrupt enable"]
        pub type S1ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `S2_RE` reader - 2nd segment sample finish interrupt enable"]
        pub type S2ReR = crate::BitReader;
        #[doc = "Field `S2_RE` writer - 2nd segment sample finish interrupt enable"]
        pub type S2ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `S3_RE` reader - 3rd segment sample finish interrupt enable"]
        pub type S3ReR = crate::BitReader;
        #[doc = "Field `S3_RE` writer - 3rd segment sample finish interrupt enable"]
        pub type S3ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `S4_RE` reader - 4th segment sample finish interrupt enable"]
        pub type S4ReR = crate::BitReader;
        #[doc = "Field `S4_RE` writer - 4th segment sample finish interrupt enable"]
        pub type S4ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SERR_RE` reader - Software trigger error interrupt enable"]
        pub type SerrReR = crate::BitReader;
        #[doc = "Field `SERR_RE` writer - Software trigger error interrupt enable"]
        pub type SerrReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HERR_RE` reader - Hardware trigger error interrupt enable"]
        pub type HerrReR = crate::BitReader;
        #[doc = "Field `HERR_RE` writer - Hardware trigger error interrupt enable"]
        pub type HerrReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `AWD_RE` reader - ADC_DATx out of range DMA request enable"]
        pub type AwdReR = crate::BitReader;
        #[doc = "Field `AWD_RE` writer - ADC_DATx out of range DMA request enable"]
        pub type AwdReW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - 1st segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s1_ie(&self) -> S1IeR {
                S1IeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - 2nd segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s2_ie(&self) -> S2IeR {
                S2IeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - 3rd segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s3_ie(&self) -> S3IeR {
                S3IeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - 4th segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s4_ie(&self) -> S4IeR {
                S4IeR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Software trigger error interrupt enable"]
            #[inline(always)]
            pub fn serr_ie(&self) -> SerrIeR {
                SerrIeR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Hardware trigger error interrupt enable"]
            #[inline(always)]
            pub fn herr_ie(&self) -> HerrIeR {
                HerrIeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - ADC_DATx out of range interrrup enable"]
            #[inline(always)]
            pub fn awd_ie(&self) -> AwdIeR {
                AwdIeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - 1st segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s1_re(&self) -> S1ReR {
                S1ReR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - 2nd segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s2_re(&self) -> S2ReR {
                S2ReR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - 3rd segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s3_re(&self) -> S3ReR {
                S3ReR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - 4th segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s4_re(&self) -> S4ReR {
                S4ReR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Software trigger error interrupt enable"]
            #[inline(always)]
            pub fn serr_re(&self) -> SerrReR {
                SerrReR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Hardware trigger error interrupt enable"]
            #[inline(always)]
            pub fn herr_re(&self) -> HerrReR {
                HerrReR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - ADC_DATx out of range DMA request enable"]
            #[inline(always)]
            pub fn awd_re(&self) -> AwdReR {
                AwdReR::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - 1st segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s1_ie(&mut self) -> S1IeW<IeSpec> {
                S1IeW::new(self, 0)
            }
            #[doc = "Bit 1 - 2nd segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s2_ie(&mut self) -> S2IeW<IeSpec> {
                S2IeW::new(self, 1)
            }
            #[doc = "Bit 2 - 3rd segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s3_ie(&mut self) -> S3IeW<IeSpec> {
                S3IeW::new(self, 2)
            }
            #[doc = "Bit 3 - 4th segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s4_ie(&mut self) -> S4IeW<IeSpec> {
                S4IeW::new(self, 3)
            }
            #[doc = "Bit 4 - Software trigger error interrupt enable"]
            #[inline(always)]
            pub fn serr_ie(&mut self) -> SerrIeW<IeSpec> {
                SerrIeW::new(self, 4)
            }
            #[doc = "Bit 5 - Hardware trigger error interrupt enable"]
            #[inline(always)]
            pub fn herr_ie(&mut self) -> HerrIeW<IeSpec> {
                HerrIeW::new(self, 5)
            }
            #[doc = "Bit 6 - ADC_DATx out of range interrrup enable"]
            #[inline(always)]
            pub fn awd_ie(&mut self) -> AwdIeW<IeSpec> {
                AwdIeW::new(self, 6)
            }
            #[doc = "Bit 8 - 1st segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s1_re(&mut self) -> S1ReW<IeSpec> {
                S1ReW::new(self, 8)
            }
            #[doc = "Bit 9 - 2nd segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s2_re(&mut self) -> S2ReW<IeSpec> {
                S2ReW::new(self, 9)
            }
            #[doc = "Bit 10 - 3rd segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s3_re(&mut self) -> S3ReW<IeSpec> {
                S3ReW::new(self, 10)
            }
            #[doc = "Bit 11 - 4th segment sample finish interrupt enable"]
            #[inline(always)]
            pub fn s4_re(&mut self) -> S4ReW<IeSpec> {
                S4ReW::new(self, 11)
            }
            #[doc = "Bit 12 - Software trigger error interrupt enable"]
            #[inline(always)]
            pub fn serr_re(&mut self) -> SerrReW<IeSpec> {
                SerrReW::new(self, 12)
            }
            #[doc = "Bit 13 - Hardware trigger error interrupt enable"]
            #[inline(always)]
            pub fn herr_re(&mut self) -> HerrReW<IeSpec> {
                HerrReW::new(self, 13)
            }
            #[doc = "Bit 14 - ADC_DATx out of range DMA request enable"]
            #[inline(always)]
            pub fn awd_re(&mut self) -> AwdReW<IeSpec> {
                AwdReW::new(self, 14)
            }
        }
        #[doc = "ADC interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IeSpec;
        impl crate::RegisterSpec for IeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ie::R`](R) reader structure"]
        impl crate::Readable for IeSpec {}
        #[doc = "`write(|w| ..)` method takes [`ie::W`](W) writer structure"]
        impl crate::Writable for IeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE to value 0"]
        impl crate::Resettable for IeSpec {}
    }
    #[doc = "IF (rw) register accessor: ADC interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@if_`] module"]
    #[doc(alias = "IF")]
    pub type If = crate::Reg<if_::IfSpec>;
    #[doc = "ADC interrupt flag"]
    pub mod if_ {
        #[doc = "Register `IF` reader"]
        pub type R = crate::R<IfSpec>;
        #[doc = "Register `IF` writer"]
        pub type W = crate::W<IfSpec>;
        #[doc = "Field `S1_IF` reader - 1st segment sample finish interrupt, write 1 to clear"]
        pub type S1IfR = crate::BitReader;
        #[doc = "Field `S1_IF` writer - 1st segment sample finish interrupt, write 1 to clear"]
        pub type S1IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `S2_IF` reader - 2nd segment sample finish interrupt, write 1 to clear"]
        pub type S2IfR = crate::BitReader;
        #[doc = "Field `S2_IF` writer - 2nd segment sample finish interrupt, write 1 to clear"]
        pub type S2IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `S3_IF` reader - 3rd segment sample finish interrupt, write 1 to clear"]
        pub type S3IfR = crate::BitReader;
        #[doc = "Field `S3_IF` writer - 3rd segment sample finish interrupt, write 1 to clear"]
        pub type S3IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `S4_IF` reader - 4th segment sample finish interrupt, write 1 to clear"]
        pub type S4IfR = crate::BitReader;
        #[doc = "Field `S4_IF` writer - 4th segment sample finish interrupt, write 1 to clear"]
        pub type S4IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SERR_IF` reader - Software trigger error interrupt, write 1 to clear"]
        pub type SerrIfR = crate::BitReader;
        #[doc = "Field `SERR_IF` writer - Software trigger error interrupt, write 1 to clear"]
        pub type SerrIfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HERR_IF` reader - Hardware trigger error interrupt, write 1 to clear"]
        pub type HerrIfR = crate::BitReader;
        #[doc = "Field `HERR_IF` writer - Hardware trigger error interrupt, write 1 to clear"]
        pub type HerrIfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `AWD_IF` reader - ADC_DATx is monitored and out of the threshold range"]
        pub type AwdIfR = crate::BitReader;
        #[doc = "Field `AWD_IF` writer - ADC_DATx is monitored and out of the threshold range"]
        pub type AwdIfW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - 1st segment sample finish interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn s1_if(&self) -> S1IfR {
                S1IfR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - 2nd segment sample finish interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn s2_if(&self) -> S2IfR {
                S2IfR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - 3rd segment sample finish interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn s3_if(&self) -> S3IfR {
                S3IfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - 4th segment sample finish interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn s4_if(&self) -> S4IfR {
                S4IfR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Software trigger error interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn serr_if(&self) -> SerrIfR {
                SerrIfR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Hardware trigger error interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn herr_if(&self) -> HerrIfR {
                HerrIfR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - ADC_DATx is monitored and out of the threshold range"]
            #[inline(always)]
            pub fn awd_if(&self) -> AwdIfR {
                AwdIfR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - 1st segment sample finish interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn s1_if(&mut self) -> S1IfW<IfSpec> {
                S1IfW::new(self, 0)
            }
            #[doc = "Bit 1 - 2nd segment sample finish interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn s2_if(&mut self) -> S2IfW<IfSpec> {
                S2IfW::new(self, 1)
            }
            #[doc = "Bit 2 - 3rd segment sample finish interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn s3_if(&mut self) -> S3IfW<IfSpec> {
                S3IfW::new(self, 2)
            }
            #[doc = "Bit 3 - 4th segment sample finish interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn s4_if(&mut self) -> S4IfW<IfSpec> {
                S4IfW::new(self, 3)
            }
            #[doc = "Bit 4 - Software trigger error interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn serr_if(&mut self) -> SerrIfW<IfSpec> {
                SerrIfW::new(self, 4)
            }
            #[doc = "Bit 5 - Hardware trigger error interrupt, write 1 to clear"]
            #[inline(always)]
            pub fn herr_if(&mut self) -> HerrIfW<IfSpec> {
                HerrIfW::new(self, 5)
            }
            #[doc = "Bit 6 - ADC_DATx is monitored and out of the threshold range"]
            #[inline(always)]
            pub fn awd_if(&mut self) -> AwdIfW<IfSpec> {
                AwdIfW::new(self, 6)
            }
        }
        #[doc = "ADC interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IfSpec;
        impl crate::RegisterSpec for IfSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`if_::R`](R) reader structure"]
        impl crate::Readable for IfSpec {}
        #[doc = "`write(|w| ..)` method takes [`if_::W`](W) writer structure"]
        impl crate::Writable for IfSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IF to value 0"]
        impl crate::Resettable for IfSpec {}
    }
}
#[doc = "UTIMER0 registers"]
pub type Utimer0 = crate::Periph<utimer0::RegisterBlock, 0x4001_0500>;
impl core::fmt::Debug for Utimer0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Utimer0").finish()
    }
}
#[doc = "UTIMER0 registers"]
pub mod utimer0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        cfg: Cfg,
        th: Th,
        cnt: Cnt,
        cmp0: Cmp0,
        cmp1: Cmp1,
        evt: Evt,
        flt: Flt,
        ie: Ie,
        if_: If,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Timer configuration"]
        #[inline(always)]
        pub const fn cfg(&self) -> &Cfg {
            &self.cfg
        }
        #[doc = "0x04 - Timer counter threshold, timer will count from 0 to TH, then over again"]
        #[inline(always)]
        pub const fn th(&self) -> &Th {
            &self.th
        }
        #[doc = "0x08 - Timer current counter value (write to set)"]
        #[inline(always)]
        pub const fn cnt(&self) -> &Cnt {
            &self.cnt
        }
        #[doc = "0x0c - Timer Channel0 CMP/CAP threshold"]
        #[inline(always)]
        pub const fn cmp0(&self) -> &Cmp0 {
            &self.cmp0
        }
        #[doc = "0x10 - Timer Channel1 CMP/CAP threshold"]
        #[inline(always)]
        pub const fn cmp1(&self) -> &Cmp1 {
            &self.cmp1
        }
        #[doc = "0x14 - Timer External Trigger Event"]
        #[inline(always)]
        pub const fn evt(&self) -> &Evt {
            &self.evt
        }
        #[doc = "0x18 - Timer Filter Width (FLT*8 timer clock cycles)"]
        #[inline(always)]
        pub const fn flt(&self) -> &Flt {
            &self.flt
        }
        #[doc = "0x1c - Timer Interrupt Enable"]
        #[inline(always)]
        pub const fn ie(&self) -> &Ie {
            &self.ie
        }
        #[doc = "0x20 - Timer Interrupt Flag"]
        #[inline(always)]
        pub const fn if_(&self) -> &If {
            &self.if_
        }
    }
    #[doc = "CFG (rw) register accessor: Timer configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"]
    #[doc(alias = "CFG")]
    pub type Cfg = crate::Reg<cfg::CfgSpec>;
    #[doc = "Timer configuration"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CfgSpec>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CfgSpec>;
        #[doc = "Channel 0 rising edge capture enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch0ReCapEn {
            #[doc = "0: Rising edge event disabled"]
            Disabled = 0,
            #[doc = "1: Rising edge event enabled"]
            Enabled = 1,
        }
        impl From<Ch0ReCapEn> for bool {
            #[inline(always)]
            fn from(variant: Ch0ReCapEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH0_RE_CAP_EN` reader - Channel 0 rising edge capture enable"]
        pub type Ch0ReCapEnR = crate::BitReader<Ch0ReCapEn>;
        impl Ch0ReCapEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch0ReCapEn {
                match self.bits {
                    false => Ch0ReCapEn::Disabled,
                    true => Ch0ReCapEn::Enabled,
                }
            }
            #[doc = "Rising edge event disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ch0ReCapEn::Disabled
            }
            #[doc = "Rising edge event enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ch0ReCapEn::Enabled
            }
        }
        #[doc = "Field `CH0_RE_CAP_EN` writer - Channel 0 rising edge capture enable"]
        pub type Ch0ReCapEnW<'a, REG> = crate::BitWriter<'a, REG, Ch0ReCapEn>;
        impl<'a, REG> Ch0ReCapEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Rising edge event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0ReCapEn::Disabled)
            }
            #[doc = "Rising edge event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0ReCapEn::Enabled)
            }
        }
        #[doc = "Channel 0 falling edge capture enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch0FeCapEn {
            #[doc = "0: Falling edge event disabled"]
            Disabled = 0,
            #[doc = "1: Falling edge event enabled"]
            Enabled = 1,
        }
        impl From<Ch0FeCapEn> for bool {
            #[inline(always)]
            fn from(variant: Ch0FeCapEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH0_FE_CAP_EN` reader - Channel 0 falling edge capture enable"]
        pub type Ch0FeCapEnR = crate::BitReader<Ch0FeCapEn>;
        impl Ch0FeCapEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch0FeCapEn {
                match self.bits {
                    false => Ch0FeCapEn::Disabled,
                    true => Ch0FeCapEn::Enabled,
                }
            }
            #[doc = "Falling edge event disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ch0FeCapEn::Disabled
            }
            #[doc = "Falling edge event enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ch0FeCapEn::Enabled
            }
        }
        #[doc = "Field `CH0_FE_CAP_EN` writer - Channel 0 falling edge capture enable"]
        pub type Ch0FeCapEnW<'a, REG> = crate::BitWriter<'a, REG, Ch0FeCapEn>;
        impl<'a, REG> Ch0FeCapEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Falling edge event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0FeCapEn::Disabled)
            }
            #[doc = "Falling edge event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0FeCapEn::Enabled)
            }
        }
        #[doc = "Channel 0 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch0Mode {
            #[doc = "0: Comparison mode"]
            Cmp = 0,
            #[doc = "1: Capture mode"]
            Cap = 1,
        }
        impl From<Ch0Mode> for bool {
            #[inline(always)]
            fn from(variant: Ch0Mode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH0_MODE` reader - Channel 0 mode"]
        pub type Ch0ModeR = crate::BitReader<Ch0Mode>;
        impl Ch0ModeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch0Mode {
                match self.bits {
                    false => Ch0Mode::Cmp,
                    true => Ch0Mode::Cap,
                }
            }
            #[doc = "Comparison mode"]
            #[inline(always)]
            pub fn is_cmp(&self) -> bool {
                *self == Ch0Mode::Cmp
            }
            #[doc = "Capture mode"]
            #[inline(always)]
            pub fn is_cap(&self) -> bool {
                *self == Ch0Mode::Cap
            }
        }
        #[doc = "Field `CH0_MODE` writer - Channel 0 mode"]
        pub type Ch0ModeW<'a, REG> = crate::BitWriter<'a, REG, Ch0Mode>;
        impl<'a, REG> Ch0ModeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Comparison mode"]
            #[inline(always)]
            pub fn cmp(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0Mode::Cmp)
            }
            #[doc = "Capture mode"]
            #[inline(always)]
            pub fn cap(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0Mode::Cap)
            }
        }
        #[doc = "Channel 0 output polarity at zero-crossing in comparision mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch0Pol {
            #[doc = "0: Output 0"]
            L = 0,
            #[doc = "1: Output 1"]
            H = 1,
        }
        impl From<Ch0Pol> for bool {
            #[inline(always)]
            fn from(variant: Ch0Pol) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH0_POL` reader - Channel 0 output polarity at zero-crossing in comparision mode"]
        pub type Ch0PolR = crate::BitReader<Ch0Pol>;
        impl Ch0PolR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch0Pol {
                match self.bits {
                    false => Ch0Pol::L,
                    true => Ch0Pol::H,
                }
            }
            #[doc = "Output 0"]
            #[inline(always)]
            pub fn is_l(&self) -> bool {
                *self == Ch0Pol::L
            }
            #[doc = "Output 1"]
            #[inline(always)]
            pub fn is_h(&self) -> bool {
                *self == Ch0Pol::H
            }
        }
        #[doc = "Field `CH0_POL` writer - Channel 0 output polarity at zero-crossing in comparision mode"]
        pub type Ch0PolW<'a, REG> = crate::BitWriter<'a, REG, Ch0Pol>;
        impl<'a, REG> Ch0PolW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Output 0"]
            #[inline(always)]
            pub fn l(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0Pol::L)
            }
            #[doc = "Output 1"]
            #[inline(always)]
            pub fn h(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0Pol::H)
            }
        }
        #[doc = "Timer capture mode ch0 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Src0 {
            #[doc = "0: timer ch0"]
            Ch0 = 0,
            #[doc = "1: timer ch1"]
            Ch1 = 1,
            #[doc = "2: Comparator 0 output"]
            Cmp0 = 2,
            #[doc = "3: Comparator 1 output"]
            Cmp1 = 3,
            #[doc = "8: timer ch0^ch1"]
            Ch01xor = 8,
        }
        impl From<Src0> for u8 {
            #[inline(always)]
            fn from(variant: Src0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Src0 {
            type Ux = u8;
        }
        impl crate::IsEnum for Src0 {}
        #[doc = "Field `SRC0` reader - Timer capture mode ch0 source"]
        pub type Src0R = crate::FieldReader<Src0>;
        impl Src0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Src0> {
                match self.bits {
                    0 => Some(Src0::Ch0),
                    1 => Some(Src0::Ch1),
                    2 => Some(Src0::Cmp0),
                    3 => Some(Src0::Cmp1),
                    8 => Some(Src0::Ch01xor),
                    _ => None,
                }
            }
            #[doc = "timer ch0"]
            #[inline(always)]
            pub fn is_ch0(&self) -> bool {
                *self == Src0::Ch0
            }
            #[doc = "timer ch1"]
            #[inline(always)]
            pub fn is_ch1(&self) -> bool {
                *self == Src0::Ch1
            }
            #[doc = "Comparator 0 output"]
            #[inline(always)]
            pub fn is_cmp0(&self) -> bool {
                *self == Src0::Cmp0
            }
            #[doc = "Comparator 1 output"]
            #[inline(always)]
            pub fn is_cmp1(&self) -> bool {
                *self == Src0::Cmp1
            }
            #[doc = "timer ch0^ch1"]
            #[inline(always)]
            pub fn is_ch01xor(&self) -> bool {
                *self == Src0::Ch01xor
            }
        }
        #[doc = "Field `SRC0` writer - Timer capture mode ch0 source"]
        pub type Src0W<'a, REG> = crate::FieldWriter<'a, REG, 4, Src0>;
        impl<'a, REG> Src0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "timer ch0"]
            #[inline(always)]
            pub fn ch0(self) -> &'a mut crate::W<REG> {
                self.variant(Src0::Ch0)
            }
            #[doc = "timer ch1"]
            #[inline(always)]
            pub fn ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Src0::Ch1)
            }
            #[doc = "Comparator 0 output"]
            #[inline(always)]
            pub fn cmp0(self) -> &'a mut crate::W<REG> {
                self.variant(Src0::Cmp0)
            }
            #[doc = "Comparator 1 output"]
            #[inline(always)]
            pub fn cmp1(self) -> &'a mut crate::W<REG> {
                self.variant(Src0::Cmp1)
            }
            #[doc = "timer ch0^ch1"]
            #[inline(always)]
            pub fn ch01xor(self) -> &'a mut crate::W<REG> {
                self.variant(Src0::Ch01xor)
            }
        }
        #[doc = "Channel 1 rising edge capture enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch1ReCapEn {
            #[doc = "0: Rising edge event disabled"]
            Disabled = 0,
            #[doc = "1: Rising edge event enabled"]
            Enabled = 1,
        }
        impl From<Ch1ReCapEn> for bool {
            #[inline(always)]
            fn from(variant: Ch1ReCapEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH1_RE_CAP_EN` reader - Channel 1 rising edge capture enable"]
        pub type Ch1ReCapEnR = crate::BitReader<Ch1ReCapEn>;
        impl Ch1ReCapEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch1ReCapEn {
                match self.bits {
                    false => Ch1ReCapEn::Disabled,
                    true => Ch1ReCapEn::Enabled,
                }
            }
            #[doc = "Rising edge event disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ch1ReCapEn::Disabled
            }
            #[doc = "Rising edge event enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ch1ReCapEn::Enabled
            }
        }
        #[doc = "Field `CH1_RE_CAP_EN` writer - Channel 1 rising edge capture enable"]
        pub type Ch1ReCapEnW<'a, REG> = crate::BitWriter<'a, REG, Ch1ReCapEn>;
        impl<'a, REG> Ch1ReCapEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Rising edge event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1ReCapEn::Disabled)
            }
            #[doc = "Rising edge event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1ReCapEn::Enabled)
            }
        }
        #[doc = "Channel 1 falling edge capture enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch1FeCapEn {
            #[doc = "0: Falling edge event disabled"]
            Disabled = 0,
            #[doc = "1: Falling edge event enabled"]
            Enabled = 1,
        }
        impl From<Ch1FeCapEn> for bool {
            #[inline(always)]
            fn from(variant: Ch1FeCapEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH1_FE_CAP_EN` reader - Channel 1 falling edge capture enable"]
        pub type Ch1FeCapEnR = crate::BitReader<Ch1FeCapEn>;
        impl Ch1FeCapEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch1FeCapEn {
                match self.bits {
                    false => Ch1FeCapEn::Disabled,
                    true => Ch1FeCapEn::Enabled,
                }
            }
            #[doc = "Falling edge event disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ch1FeCapEn::Disabled
            }
            #[doc = "Falling edge event enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ch1FeCapEn::Enabled
            }
        }
        #[doc = "Field `CH1_FE_CAP_EN` writer - Channel 1 falling edge capture enable"]
        pub type Ch1FeCapEnW<'a, REG> = crate::BitWriter<'a, REG, Ch1FeCapEn>;
        impl<'a, REG> Ch1FeCapEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Falling edge event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1FeCapEn::Disabled)
            }
            #[doc = "Falling edge event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1FeCapEn::Enabled)
            }
        }
        #[doc = "Channel 1 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch1Mode {
            #[doc = "0: Comparison mode"]
            Cmp = 0,
            #[doc = "1: Capture mode"]
            Cap = 1,
        }
        impl From<Ch1Mode> for bool {
            #[inline(always)]
            fn from(variant: Ch1Mode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH1_MODE` reader - Channel 1 mode"]
        pub type Ch1ModeR = crate::BitReader<Ch1Mode>;
        impl Ch1ModeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch1Mode {
                match self.bits {
                    false => Ch1Mode::Cmp,
                    true => Ch1Mode::Cap,
                }
            }
            #[doc = "Comparison mode"]
            #[inline(always)]
            pub fn is_cmp(&self) -> bool {
                *self == Ch1Mode::Cmp
            }
            #[doc = "Capture mode"]
            #[inline(always)]
            pub fn is_cap(&self) -> bool {
                *self == Ch1Mode::Cap
            }
        }
        #[doc = "Field `CH1_MODE` writer - Channel 1 mode"]
        pub type Ch1ModeW<'a, REG> = crate::BitWriter<'a, REG, Ch1Mode>;
        impl<'a, REG> Ch1ModeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Comparison mode"]
            #[inline(always)]
            pub fn cmp(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1Mode::Cmp)
            }
            #[doc = "Capture mode"]
            #[inline(always)]
            pub fn cap(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1Mode::Cap)
            }
        }
        #[doc = "Channel 1 output polarity at zero-crossing in comparision mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch1Pol {
            #[doc = "0: Output 0"]
            L = 0,
            #[doc = "1: Output 1"]
            H = 1,
        }
        impl From<Ch1Pol> for bool {
            #[inline(always)]
            fn from(variant: Ch1Pol) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH1_POL` reader - Channel 1 output polarity at zero-crossing in comparision mode"]
        pub type Ch1PolR = crate::BitReader<Ch1Pol>;
        impl Ch1PolR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch1Pol {
                match self.bits {
                    false => Ch1Pol::L,
                    true => Ch1Pol::H,
                }
            }
            #[doc = "Output 0"]
            #[inline(always)]
            pub fn is_l(&self) -> bool {
                *self == Ch1Pol::L
            }
            #[doc = "Output 1"]
            #[inline(always)]
            pub fn is_h(&self) -> bool {
                *self == Ch1Pol::H
            }
        }
        #[doc = "Field `CH1_POL` writer - Channel 1 output polarity at zero-crossing in comparision mode"]
        pub type Ch1PolW<'a, REG> = crate::BitWriter<'a, REG, Ch1Pol>;
        impl<'a, REG> Ch1PolW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Output 0"]
            #[inline(always)]
            pub fn l(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1Pol::L)
            }
            #[doc = "Output 1"]
            #[inline(always)]
            pub fn h(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1Pol::H)
            }
        }
        #[doc = "Timer capture mode ch1 source\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Src1 {
            #[doc = "0: timer ch0"]
            Ch0 = 0,
            #[doc = "1: timer ch1"]
            Ch1 = 1,
            #[doc = "2: Comparator 0 output"]
            Cmp0 = 2,
            #[doc = "3: Comparator 1 output"]
            Cmp1 = 3,
            #[doc = "8: timer ch0^ch1"]
            Ch01xor = 8,
        }
        impl From<Src1> for u8 {
            #[inline(always)]
            fn from(variant: Src1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Src1 {
            type Ux = u8;
        }
        impl crate::IsEnum for Src1 {}
        #[doc = "Field `SRC1` reader - Timer capture mode ch1 source"]
        pub type Src1R = crate::FieldReader<Src1>;
        impl Src1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Src1> {
                match self.bits {
                    0 => Some(Src1::Ch0),
                    1 => Some(Src1::Ch1),
                    2 => Some(Src1::Cmp0),
                    3 => Some(Src1::Cmp1),
                    8 => Some(Src1::Ch01xor),
                    _ => None,
                }
            }
            #[doc = "timer ch0"]
            #[inline(always)]
            pub fn is_ch0(&self) -> bool {
                *self == Src1::Ch0
            }
            #[doc = "timer ch1"]
            #[inline(always)]
            pub fn is_ch1(&self) -> bool {
                *self == Src1::Ch1
            }
            #[doc = "Comparator 0 output"]
            #[inline(always)]
            pub fn is_cmp0(&self) -> bool {
                *self == Src1::Cmp0
            }
            #[doc = "Comparator 1 output"]
            #[inline(always)]
            pub fn is_cmp1(&self) -> bool {
                *self == Src1::Cmp1
            }
            #[doc = "timer ch0^ch1"]
            #[inline(always)]
            pub fn is_ch01xor(&self) -> bool {
                *self == Src1::Ch01xor
            }
        }
        #[doc = "Field `SRC1` writer - Timer capture mode ch1 source"]
        pub type Src1W<'a, REG> = crate::FieldWriter<'a, REG, 4, Src1>;
        impl<'a, REG> Src1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "timer ch0"]
            #[inline(always)]
            pub fn ch0(self) -> &'a mut crate::W<REG> {
                self.variant(Src1::Ch0)
            }
            #[doc = "timer ch1"]
            #[inline(always)]
            pub fn ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Src1::Ch1)
            }
            #[doc = "Comparator 0 output"]
            #[inline(always)]
            pub fn cmp0(self) -> &'a mut crate::W<REG> {
                self.variant(Src1::Cmp0)
            }
            #[doc = "Comparator 1 output"]
            #[inline(always)]
            pub fn cmp1(self) -> &'a mut crate::W<REG> {
                self.variant(Src1::Cmp1)
            }
            #[doc = "timer ch0^ch1"]
            #[inline(always)]
            pub fn ch01xor(self) -> &'a mut crate::W<REG> {
                self.variant(Src1::Ch01xor)
            }
        }
        #[doc = "Timer clock source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ClkSrc {
            #[doc = "0: internal system clock"]
            Sysclk = 0,
            #[doc = "2: timer0 ch0"]
            T0Ch0 = 2,
            #[doc = "3: timer0 ch1"]
            T0Ch1 = 3,
            #[doc = "4: timer1 ch0"]
            T1Ch0 = 4,
            #[doc = "5: timer1 ch1"]
            T1Ch1 = 5,
        }
        impl From<ClkSrc> for u8 {
            #[inline(always)]
            fn from(variant: ClkSrc) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ClkSrc {
            type Ux = u8;
        }
        impl crate::IsEnum for ClkSrc {}
        #[doc = "Field `CLK_SRC` reader - Timer clock source"]
        pub type ClkSrcR = crate::FieldReader<ClkSrc>;
        impl ClkSrcR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<ClkSrc> {
                match self.bits {
                    0 => Some(ClkSrc::Sysclk),
                    2 => Some(ClkSrc::T0Ch0),
                    3 => Some(ClkSrc::T0Ch1),
                    4 => Some(ClkSrc::T1Ch0),
                    5 => Some(ClkSrc::T1Ch1),
                    _ => None,
                }
            }
            #[doc = "internal system clock"]
            #[inline(always)]
            pub fn is_sysclk(&self) -> bool {
                *self == ClkSrc::Sysclk
            }
            #[doc = "timer0 ch0"]
            #[inline(always)]
            pub fn is_t0_ch0(&self) -> bool {
                *self == ClkSrc::T0Ch0
            }
            #[doc = "timer0 ch1"]
            #[inline(always)]
            pub fn is_t0_ch1(&self) -> bool {
                *self == ClkSrc::T0Ch1
            }
            #[doc = "timer1 ch0"]
            #[inline(always)]
            pub fn is_t1_ch0(&self) -> bool {
                *self == ClkSrc::T1Ch0
            }
            #[doc = "timer1 ch1"]
            #[inline(always)]
            pub fn is_t1_ch1(&self) -> bool {
                *self == ClkSrc::T1Ch1
            }
        }
        #[doc = "Field `CLK_SRC` writer - Timer clock source"]
        pub type ClkSrcW<'a, REG> = crate::FieldWriter<'a, REG, 4, ClkSrc>;
        impl<'a, REG> ClkSrcW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "internal system clock"]
            #[inline(always)]
            pub fn sysclk(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSrc::Sysclk)
            }
            #[doc = "timer0 ch0"]
            #[inline(always)]
            pub fn t0_ch0(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSrc::T0Ch0)
            }
            #[doc = "timer0 ch1"]
            #[inline(always)]
            pub fn t0_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSrc::T0Ch1)
            }
            #[doc = "timer1 ch0"]
            #[inline(always)]
            pub fn t1_ch0(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSrc::T1Ch0)
            }
            #[doc = "timer1 ch1"]
            #[inline(always)]
            pub fn t1_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSrc::T1Ch1)
            }
        }
        #[doc = "Timer clock division ratio\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ClkDiv {
            #[doc = "0: Main clock no division"]
            Div1 = 0,
            #[doc = "1: Main clock divided by 2"]
            Div2 = 1,
            #[doc = "2: Main clock divided by 4"]
            Div4 = 2,
            #[doc = "3: Main clock divided by 8"]
            Div8 = 3,
            #[doc = "4: Main clock divided by 16"]
            Div16 = 4,
            #[doc = "5: Main clock divided by 32"]
            Div32 = 5,
            #[doc = "6: Main clock divided by 64"]
            Div64 = 6,
            #[doc = "7: Main clock divided by 128"]
            Div128 = 7,
        }
        impl From<ClkDiv> for u8 {
            #[inline(always)]
            fn from(variant: ClkDiv) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ClkDiv {
            type Ux = u8;
        }
        impl crate::IsEnum for ClkDiv {}
        #[doc = "Field `CLK_DIV` reader - Timer clock division ratio"]
        pub type ClkDivR = crate::FieldReader<ClkDiv>;
        impl ClkDivR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ClkDiv {
                match self.bits {
                    0 => ClkDiv::Div1,
                    1 => ClkDiv::Div2,
                    2 => ClkDiv::Div4,
                    3 => ClkDiv::Div8,
                    4 => ClkDiv::Div16,
                    5 => ClkDiv::Div32,
                    6 => ClkDiv::Div64,
                    7 => ClkDiv::Div128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Main clock no division"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == ClkDiv::Div1
            }
            #[doc = "Main clock divided by 2"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ClkDiv::Div2
            }
            #[doc = "Main clock divided by 4"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ClkDiv::Div4
            }
            #[doc = "Main clock divided by 8"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ClkDiv::Div8
            }
            #[doc = "Main clock divided by 16"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == ClkDiv::Div16
            }
            #[doc = "Main clock divided by 32"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == ClkDiv::Div32
            }
            #[doc = "Main clock divided by 64"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == ClkDiv::Div64
            }
            #[doc = "Main clock divided by 128"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == ClkDiv::Div128
            }
        }
        #[doc = "Field `CLK_DIV` writer - Timer clock division ratio"]
        pub type ClkDivW<'a, REG> = crate::FieldWriter<'a, REG, 3, ClkDiv, crate::Safe>;
        impl<'a, REG> ClkDivW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Main clock no division"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div1)
            }
            #[doc = "Main clock divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div2)
            }
            #[doc = "Main clock divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div4)
            }
            #[doc = "Main clock divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div8)
            }
            #[doc = "Main clock divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div16)
            }
            #[doc = "Main clock divided by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div32)
            }
            #[doc = "Main clock divided by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div64)
            }
            #[doc = "Main clock divided by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div128)
            }
        }
        #[doc = "Timer external trigger\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Eton {
            #[doc = "0: Free run"]
            It = 0,
            #[doc = "1: Extrenal trigger"]
            Et = 1,
        }
        impl From<Eton> for bool {
            #[inline(always)]
            fn from(variant: Eton) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ETON` reader - Timer external trigger"]
        pub type EtonR = crate::BitReader<Eton>;
        impl EtonR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Eton {
                match self.bits {
                    false => Eton::It,
                    true => Eton::Et,
                }
            }
            #[doc = "Free run"]
            #[inline(always)]
            pub fn is_it(&self) -> bool {
                *self == Eton::It
            }
            #[doc = "Extrenal trigger"]
            #[inline(always)]
            pub fn is_et(&self) -> bool {
                *self == Eton::Et
            }
        }
        #[doc = "Field `ETON` writer - Timer external trigger"]
        pub type EtonW<'a, REG> = crate::BitWriter<'a, REG, Eton>;
        impl<'a, REG> EtonW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Free run"]
            #[inline(always)]
            pub fn it(self) -> &'a mut crate::W<REG> {
                self.variant(Eton::It)
            }
            #[doc = "Extrenal trigger"]
            #[inline(always)]
            pub fn et(self) -> &'a mut crate::W<REG> {
                self.variant(Eton::Et)
            }
        }
        #[doc = "Field `ONE_TRIG` reader - trigger timer to send for one period"]
        pub type OneTrigR = crate::BitReader;
        #[doc = "Field `ONE_TRIG` writer - trigger timer to send for one period"]
        pub type OneTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CAP0_CLR_EN` reader - clear timer cnt when CAP0"]
        pub type Cap0ClrEnR = crate::BitReader;
        #[doc = "Field `CAP0_CLR_EN` writer - clear timer cnt when CAP0"]
        pub type Cap0ClrEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CAP1_CLR_EN` reader - clear timer cnt when CAP1"]
        pub type Cap1ClrEnR = crate::BitReader;
        #[doc = "Field `CAP1_CLR_EN` writer - clear timer cnt when CAP1"]
        pub type Cap1ClrEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EN` reader - Timer enable"]
        pub type EnR = crate::BitReader;
        #[doc = "Field `EN` writer - Timer enable"]
        pub type EnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Channel 0 rising edge capture enable"]
            #[inline(always)]
            pub fn ch0_re_cap_en(&self) -> Ch0ReCapEnR {
                Ch0ReCapEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Channel 0 falling edge capture enable"]
            #[inline(always)]
            pub fn ch0_fe_cap_en(&self) -> Ch0FeCapEnR {
                Ch0FeCapEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Channel 0 mode"]
            #[inline(always)]
            pub fn ch0_mode(&self) -> Ch0ModeR {
                Ch0ModeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Channel 0 output polarity at zero-crossing in comparision mode"]
            #[inline(always)]
            pub fn ch0_pol(&self) -> Ch0PolR {
                Ch0PolR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:7 - Timer capture mode ch0 source"]
            #[inline(always)]
            pub fn src0(&self) -> Src0R {
                Src0R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bit 8 - Channel 1 rising edge capture enable"]
            #[inline(always)]
            pub fn ch1_re_cap_en(&self) -> Ch1ReCapEnR {
                Ch1ReCapEnR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Channel 1 falling edge capture enable"]
            #[inline(always)]
            pub fn ch1_fe_cap_en(&self) -> Ch1FeCapEnR {
                Ch1FeCapEnR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Channel 1 mode"]
            #[inline(always)]
            pub fn ch1_mode(&self) -> Ch1ModeR {
                Ch1ModeR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Channel 1 output polarity at zero-crossing in comparision mode"]
            #[inline(always)]
            pub fn ch1_pol(&self) -> Ch1PolR {
                Ch1PolR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bits 12:15 - Timer capture mode ch1 source"]
            #[inline(always)]
            pub fn src1(&self) -> Src1R {
                Src1R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 16:19 - Timer clock source"]
            #[inline(always)]
            pub fn clk_src(&self) -> ClkSrcR {
                ClkSrcR::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 20:22 - Timer clock division ratio"]
            #[inline(always)]
            pub fn clk_div(&self) -> ClkDivR {
                ClkDivR::new(((self.bits >> 20) & 7) as u8)
            }
            #[doc = "Bit 24 - Timer external trigger"]
            #[inline(always)]
            pub fn eton(&self) -> EtonR {
                EtonR::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - trigger timer to send for one period"]
            #[inline(always)]
            pub fn one_trig(&self) -> OneTrigR {
                OneTrigR::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - clear timer cnt when CAP0"]
            #[inline(always)]
            pub fn cap0_clr_en(&self) -> Cap0ClrEnR {
                Cap0ClrEnR::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - clear timer cnt when CAP1"]
            #[inline(always)]
            pub fn cap1_clr_en(&self) -> Cap1ClrEnR {
                Cap1ClrEnR::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 31 - Timer enable"]
            #[inline(always)]
            pub fn en(&self) -> EnR {
                EnR::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Channel 0 rising edge capture enable"]
            #[inline(always)]
            pub fn ch0_re_cap_en(&mut self) -> Ch0ReCapEnW<CfgSpec> {
                Ch0ReCapEnW::new(self, 0)
            }
            #[doc = "Bit 1 - Channel 0 falling edge capture enable"]
            #[inline(always)]
            pub fn ch0_fe_cap_en(&mut self) -> Ch0FeCapEnW<CfgSpec> {
                Ch0FeCapEnW::new(self, 1)
            }
            #[doc = "Bit 2 - Channel 0 mode"]
            #[inline(always)]
            pub fn ch0_mode(&mut self) -> Ch0ModeW<CfgSpec> {
                Ch0ModeW::new(self, 2)
            }
            #[doc = "Bit 3 - Channel 0 output polarity at zero-crossing in comparision mode"]
            #[inline(always)]
            pub fn ch0_pol(&mut self) -> Ch0PolW<CfgSpec> {
                Ch0PolW::new(self, 3)
            }
            #[doc = "Bits 4:7 - Timer capture mode ch0 source"]
            #[inline(always)]
            pub fn src0(&mut self) -> Src0W<CfgSpec> {
                Src0W::new(self, 4)
            }
            #[doc = "Bit 8 - Channel 1 rising edge capture enable"]
            #[inline(always)]
            pub fn ch1_re_cap_en(&mut self) -> Ch1ReCapEnW<CfgSpec> {
                Ch1ReCapEnW::new(self, 8)
            }
            #[doc = "Bit 9 - Channel 1 falling edge capture enable"]
            #[inline(always)]
            pub fn ch1_fe_cap_en(&mut self) -> Ch1FeCapEnW<CfgSpec> {
                Ch1FeCapEnW::new(self, 9)
            }
            #[doc = "Bit 10 - Channel 1 mode"]
            #[inline(always)]
            pub fn ch1_mode(&mut self) -> Ch1ModeW<CfgSpec> {
                Ch1ModeW::new(self, 10)
            }
            #[doc = "Bit 11 - Channel 1 output polarity at zero-crossing in comparision mode"]
            #[inline(always)]
            pub fn ch1_pol(&mut self) -> Ch1PolW<CfgSpec> {
                Ch1PolW::new(self, 11)
            }
            #[doc = "Bits 12:15 - Timer capture mode ch1 source"]
            #[inline(always)]
            pub fn src1(&mut self) -> Src1W<CfgSpec> {
                Src1W::new(self, 12)
            }
            #[doc = "Bits 16:19 - Timer clock source"]
            #[inline(always)]
            pub fn clk_src(&mut self) -> ClkSrcW<CfgSpec> {
                ClkSrcW::new(self, 16)
            }
            #[doc = "Bits 20:22 - Timer clock division ratio"]
            #[inline(always)]
            pub fn clk_div(&mut self) -> ClkDivW<CfgSpec> {
                ClkDivW::new(self, 20)
            }
            #[doc = "Bit 24 - Timer external trigger"]
            #[inline(always)]
            pub fn eton(&mut self) -> EtonW<CfgSpec> {
                EtonW::new(self, 24)
            }
            #[doc = "Bit 25 - trigger timer to send for one period"]
            #[inline(always)]
            pub fn one_trig(&mut self) -> OneTrigW<CfgSpec> {
                OneTrigW::new(self, 25)
            }
            #[doc = "Bit 26 - clear timer cnt when CAP0"]
            #[inline(always)]
            pub fn cap0_clr_en(&mut self) -> Cap0ClrEnW<CfgSpec> {
                Cap0ClrEnW::new(self, 26)
            }
            #[doc = "Bit 27 - clear timer cnt when CAP1"]
            #[inline(always)]
            pub fn cap1_clr_en(&mut self) -> Cap1ClrEnW<CfgSpec> {
                Cap1ClrEnW::new(self, 27)
            }
            #[doc = "Bit 31 - Timer enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EnW<CfgSpec> {
                EnW::new(self, 31)
            }
        }
        #[doc = "Timer configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgSpec;
        impl crate::RegisterSpec for CfgSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFG to value 0x1000"]
        impl crate::Resettable for CfgSpec {
            const RESET_VALUE: u32 = 0x1000;
        }
    }
    #[doc = "TH (rw) register accessor: Timer counter threshold, timer will count from 0 to TH, then over again\n\nYou can [`read`](crate::Reg::read) this register and get [`th::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th`] module"]
    #[doc(alias = "TH")]
    pub type Th = crate::Reg<th::ThSpec>;
    #[doc = "Timer counter threshold, timer will count from 0 to TH, then over again"]
    pub mod th {
        #[doc = "Register `TH` reader"]
        pub type R = crate::R<ThSpec>;
        #[doc = "Register `TH` writer"]
        pub type W = crate::W<ThSpec>;
        #[doc = "Field `TH` reader - Timer counter threshold"]
        pub type ThR = crate::FieldReader<u16>;
        #[doc = "Field `TH` writer - Timer counter threshold"]
        pub type ThW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Timer counter threshold"]
            #[inline(always)]
            pub fn th(&self) -> ThR {
                ThR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Timer counter threshold"]
            #[inline(always)]
            pub fn th(&mut self) -> ThW<ThSpec> {
                ThW::new(self, 0)
            }
        }
        #[doc = "Timer counter threshold, timer will count from 0 to TH, then over again\n\nYou can [`read`](crate::Reg::read) this register and get [`th::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ThSpec;
        impl crate::RegisterSpec for ThSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th::R`](R) reader structure"]
        impl crate::Readable for ThSpec {}
        #[doc = "`write(|w| ..)` method takes [`th::W`](W) writer structure"]
        impl crate::Writable for ThSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH to value 0"]
        impl crate::Resettable for ThSpec {}
    }
    #[doc = "CNT (rw) register accessor: Timer current counter value (write to set)\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
    #[doc(alias = "CNT")]
    pub type Cnt = crate::Reg<cnt::CntSpec>;
    #[doc = "Timer current counter value (write to set)"]
    pub mod cnt {
        #[doc = "Register `CNT` reader"]
        pub type R = crate::R<CntSpec>;
        #[doc = "Register `CNT` writer"]
        pub type W = crate::W<CntSpec>;
        #[doc = "Field `CNT` reader - Timer counter value"]
        pub type CntR = crate::FieldReader<u16>;
        #[doc = "Field `CNT` writer - Timer counter value"]
        pub type CntW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Timer counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CntR {
                CntR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Timer counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CntW<CntSpec> {
                CntW::new(self, 0)
            }
        }
        #[doc = "Timer current counter value (write to set)\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CntSpec;
        impl crate::RegisterSpec for CntSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt::R`](R) reader structure"]
        impl crate::Readable for CntSpec {}
        #[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"]
        impl crate::Writable for CntSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CNT to value 0"]
        impl crate::Resettable for CntSpec {}
    }
    #[doc = "CMP0 (rw) register accessor: Timer Channel0 CMP/CAP threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmp0`] module"]
    #[doc(alias = "CMP0")]
    pub type Cmp0 = crate::Reg<cmp0::Cmp0Spec>;
    #[doc = "Timer Channel0 CMP/CAP threshold"]
    pub mod cmp0 {
        #[doc = "Register `CMP0` reader"]
        pub type R = crate::R<Cmp0Spec>;
        #[doc = "Register `CMP0` writer"]
        pub type W = crate::W<Cmp0Spec>;
        #[doc = "Field `CMP0` reader - Timer Channel0 CMP/CAP threshold"]
        pub type Cmp0R = crate::FieldReader<u16>;
        #[doc = "Field `CMP0` writer - Timer Channel0 CMP/CAP threshold"]
        pub type Cmp0W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Timer Channel0 CMP/CAP threshold"]
            #[inline(always)]
            pub fn cmp0(&self) -> Cmp0R {
                Cmp0R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Timer Channel0 CMP/CAP threshold"]
            #[inline(always)]
            pub fn cmp0(&mut self) -> Cmp0W<Cmp0Spec> {
                Cmp0W::new(self, 0)
            }
        }
        #[doc = "Timer Channel0 CMP/CAP threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Cmp0Spec;
        impl crate::RegisterSpec for Cmp0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cmp0::R`](R) reader structure"]
        impl crate::Readable for Cmp0Spec {}
        #[doc = "`write(|w| ..)` method takes [`cmp0::W`](W) writer structure"]
        impl crate::Writable for Cmp0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CMP0 to value 0"]
        impl crate::Resettable for Cmp0Spec {}
    }
    #[doc = "CMP1 (rw) register accessor: Timer Channel1 CMP/CAP threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmp1`] module"]
    #[doc(alias = "CMP1")]
    pub type Cmp1 = crate::Reg<cmp1::Cmp1Spec>;
    #[doc = "Timer Channel1 CMP/CAP threshold"]
    pub mod cmp1 {
        #[doc = "Register `CMP1` reader"]
        pub type R = crate::R<Cmp1Spec>;
        #[doc = "Register `CMP1` writer"]
        pub type W = crate::W<Cmp1Spec>;
        #[doc = "Field `CMP1` reader - Timer Channel1 CMP/CAP threshold"]
        pub type Cmp1R = crate::FieldReader<u16>;
        #[doc = "Field `CMP1` writer - Timer Channel1 CMP/CAP threshold"]
        pub type Cmp1W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Timer Channel1 CMP/CAP threshold"]
            #[inline(always)]
            pub fn cmp1(&self) -> Cmp1R {
                Cmp1R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Timer Channel1 CMP/CAP threshold"]
            #[inline(always)]
            pub fn cmp1(&mut self) -> Cmp1W<Cmp1Spec> {
                Cmp1W::new(self, 0)
            }
        }
        #[doc = "Timer Channel1 CMP/CAP threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Cmp1Spec;
        impl crate::RegisterSpec for Cmp1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cmp1::R`](R) reader structure"]
        impl crate::Readable for Cmp1Spec {}
        #[doc = "`write(|w| ..)` method takes [`cmp1::W`](W) writer structure"]
        impl crate::Writable for Cmp1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CMP1 to value 0"]
        impl crate::Resettable for Cmp1Spec {}
    }
    #[doc = "EVT (rw) register accessor: Timer External Trigger Event\n\nYou can [`read`](crate::Reg::read) this register and get [`evt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@evt`] module"]
    #[doc(alias = "EVT")]
    pub type Evt = crate::Reg<evt::EvtSpec>;
    #[doc = "Timer External Trigger Event"]
    pub mod evt {
        #[doc = "Register `EVT` reader"]
        pub type R = crate::R<EvtSpec>;
        #[doc = "Register `EVT` writer"]
        pub type W = crate::W<EvtSpec>;
        #[doc = "external event select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Src {
            #[doc = "0: Use timer0 channel 0 as trigger"]
            T0Ch0 = 0,
            #[doc = "1: Use timer0 channel 1 as trigger"]
            T0Ch1 = 1,
            #[doc = "2: Use timer1 channel 0 as trigger"]
            T1Ch0 = 2,
            #[doc = "3: Use timer1 channel 1 as trigger"]
            T1Ch1 = 3,
            #[doc = "10: Use MCPWM TADC0 as trigger"]
            McpwmTadc0 = 10,
            #[doc = "11: Use MCPWM TADC1 as trigger"]
            McpwmTadc1 = 11,
            #[doc = "12: Use MCPWM TADC2 as trigger"]
            McpwmTadc2 = 12,
            #[doc = "13: Use MCPWM TADC3 as trigger"]
            McpwmTadc3 = 13,
        }
        impl From<Src> for u8 {
            #[inline(always)]
            fn from(variant: Src) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Src {
            type Ux = u8;
        }
        impl crate::IsEnum for Src {}
        #[doc = "Field `SRC` reader - external event select"]
        pub type SrcR = crate::FieldReader<Src>;
        impl SrcR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Src> {
                match self.bits {
                    0 => Some(Src::T0Ch0),
                    1 => Some(Src::T0Ch1),
                    2 => Some(Src::T1Ch0),
                    3 => Some(Src::T1Ch1),
                    10 => Some(Src::McpwmTadc0),
                    11 => Some(Src::McpwmTadc1),
                    12 => Some(Src::McpwmTadc2),
                    13 => Some(Src::McpwmTadc3),
                    _ => None,
                }
            }
            #[doc = "Use timer0 channel 0 as trigger"]
            #[inline(always)]
            pub fn is_t0_ch0(&self) -> bool {
                *self == Src::T0Ch0
            }
            #[doc = "Use timer0 channel 1 as trigger"]
            #[inline(always)]
            pub fn is_t0_ch1(&self) -> bool {
                *self == Src::T0Ch1
            }
            #[doc = "Use timer1 channel 0 as trigger"]
            #[inline(always)]
            pub fn is_t1_ch0(&self) -> bool {
                *self == Src::T1Ch0
            }
            #[doc = "Use timer1 channel 1 as trigger"]
            #[inline(always)]
            pub fn is_t1_ch1(&self) -> bool {
                *self == Src::T1Ch1
            }
            #[doc = "Use MCPWM TADC0 as trigger"]
            #[inline(always)]
            pub fn is_mcpwm_tadc0(&self) -> bool {
                *self == Src::McpwmTadc0
            }
            #[doc = "Use MCPWM TADC1 as trigger"]
            #[inline(always)]
            pub fn is_mcpwm_tadc1(&self) -> bool {
                *self == Src::McpwmTadc1
            }
            #[doc = "Use MCPWM TADC2 as trigger"]
            #[inline(always)]
            pub fn is_mcpwm_tadc2(&self) -> bool {
                *self == Src::McpwmTadc2
            }
            #[doc = "Use MCPWM TADC3 as trigger"]
            #[inline(always)]
            pub fn is_mcpwm_tadc3(&self) -> bool {
                *self == Src::McpwmTadc3
            }
        }
        #[doc = "Field `SRC` writer - external event select"]
        pub type SrcW<'a, REG> = crate::FieldWriter<'a, REG, 5, Src>;
        impl<'a, REG> SrcW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Use timer0 channel 0 as trigger"]
            #[inline(always)]
            pub fn t0_ch0(self) -> &'a mut crate::W<REG> {
                self.variant(Src::T0Ch0)
            }
            #[doc = "Use timer0 channel 1 as trigger"]
            #[inline(always)]
            pub fn t0_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Src::T0Ch1)
            }
            #[doc = "Use timer1 channel 0 as trigger"]
            #[inline(always)]
            pub fn t1_ch0(self) -> &'a mut crate::W<REG> {
                self.variant(Src::T1Ch0)
            }
            #[doc = "Use timer1 channel 1 as trigger"]
            #[inline(always)]
            pub fn t1_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Src::T1Ch1)
            }
            #[doc = "Use MCPWM TADC0 as trigger"]
            #[inline(always)]
            pub fn mcpwm_tadc0(self) -> &'a mut crate::W<REG> {
                self.variant(Src::McpwmTadc0)
            }
            #[doc = "Use MCPWM TADC1 as trigger"]
            #[inline(always)]
            pub fn mcpwm_tadc1(self) -> &'a mut crate::W<REG> {
                self.variant(Src::McpwmTadc1)
            }
            #[doc = "Use MCPWM TADC2 as trigger"]
            #[inline(always)]
            pub fn mcpwm_tadc2(self) -> &'a mut crate::W<REG> {
                self.variant(Src::McpwmTadc2)
            }
            #[doc = "Use MCPWM TADC3 as trigger"]
            #[inline(always)]
            pub fn mcpwm_tadc3(self) -> &'a mut crate::W<REG> {
                self.variant(Src::McpwmTadc3)
            }
        }
        impl R {
            #[doc = "Bits 0:4 - external event select"]
            #[inline(always)]
            pub fn src(&self) -> SrcR {
                SrcR::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:4 - external event select"]
            #[inline(always)]
            pub fn src(&mut self) -> SrcW<EvtSpec> {
                SrcW::new(self, 0)
            }
        }
        #[doc = "Timer External Trigger Event\n\nYou can [`read`](crate::Reg::read) this register and get [`evt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvtSpec;
        impl crate::RegisterSpec for EvtSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`evt::R`](R) reader structure"]
        impl crate::Readable for EvtSpec {}
        #[doc = "`write(|w| ..)` method takes [`evt::W`](W) writer structure"]
        impl crate::Writable for EvtSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets EVT to value 0"]
        impl crate::Resettable for EvtSpec {}
    }
    #[doc = "FLT (rw) register accessor: Timer Filter Width (FLT*8 timer clock cycles)\n\nYou can [`read`](crate::Reg::read) this register and get [`flt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@flt`] module"]
    #[doc(alias = "FLT")]
    pub type Flt = crate::Reg<flt::FltSpec>;
    #[doc = "Timer Filter Width (FLT*8 timer clock cycles)"]
    pub mod flt {
        #[doc = "Register `FLT` reader"]
        pub type R = crate::R<FltSpec>;
        #[doc = "Register `FLT` writer"]
        pub type W = crate::W<FltSpec>;
        #[doc = "Field `FLT` reader - Filter width"]
        pub type FltR = crate::FieldReader;
        #[doc = "Field `FLT` writer - Filter width"]
        pub type FltW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Filter width"]
            #[inline(always)]
            pub fn flt(&self) -> FltR {
                FltR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Filter width"]
            #[inline(always)]
            pub fn flt(&mut self) -> FltW<FltSpec> {
                FltW::new(self, 0)
            }
        }
        #[doc = "Timer Filter Width (FLT*8 timer clock cycles)\n\nYou can [`read`](crate::Reg::read) this register and get [`flt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FltSpec;
        impl crate::RegisterSpec for FltSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`flt::R`](R) reader structure"]
        impl crate::Readable for FltSpec {}
        #[doc = "`write(|w| ..)` method takes [`flt::W`](W) writer structure"]
        impl crate::Writable for FltSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FLT to value 0"]
        impl crate::Resettable for FltSpec {}
    }
    #[doc = "IE (rw) register accessor: Timer Interrupt Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie`] module"]
    #[doc(alias = "IE")]
    pub type Ie = crate::Reg<ie::IeSpec>;
    #[doc = "Timer Interrupt Enable"]
    pub mod ie {
        #[doc = "Register `IE` reader"]
        pub type R = crate::R<IeSpec>;
        #[doc = "Register `IE` writer"]
        pub type W = crate::W<IeSpec>;
        #[doc = "Field `CH0_IE` reader - ch0 cmp/cap interrupt request enable"]
        pub type Ch0IeR = crate::BitReader;
        #[doc = "Field `CH0_IE` writer - ch0 cmp/cap interrupt request enable"]
        pub type Ch0IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_IE` reader - ch1 cmp/cap interrupt request enable"]
        pub type Ch1IeR = crate::BitReader;
        #[doc = "Field `CH1_IE` writer - ch1 cmp/cap interrupt request enable"]
        pub type Ch1IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ZC_IE` reader - Zero cross interrupt request enable"]
        pub type ZcIeR = crate::BitReader;
        #[doc = "Field `ZC_IE` writer - Zero cross interrupt request enable"]
        pub type ZcIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0_RE` reader - ch0 cmp/cap dma request enable"]
        pub type Ch0ReR = crate::BitReader;
        #[doc = "Field `CH0_RE` writer - ch0 cmp/cap dma request enable"]
        pub type Ch0ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_RE` reader - ch1 cmp/cap dma request enable"]
        pub type Ch1ReR = crate::BitReader;
        #[doc = "Field `CH1_RE` writer - ch1 cmp/cap dma request enable"]
        pub type Ch1ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ZC_RE` reader - Zero cross DMA request enable"]
        pub type ZcReR = crate::BitReader;
        #[doc = "Field `ZC_RE` writer - Zero cross DMA request enable"]
        pub type ZcReW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - ch0 cmp/cap interrupt request enable"]
            #[inline(always)]
            pub fn ch0_ie(&self) -> Ch0IeR {
                Ch0IeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - ch1 cmp/cap interrupt request enable"]
            #[inline(always)]
            pub fn ch1_ie(&self) -> Ch1IeR {
                Ch1IeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Zero cross interrupt request enable"]
            #[inline(always)]
            pub fn zc_ie(&self) -> ZcIeR {
                ZcIeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 8 - ch0 cmp/cap dma request enable"]
            #[inline(always)]
            pub fn ch0_re(&self) -> Ch0ReR {
                Ch0ReR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - ch1 cmp/cap dma request enable"]
            #[inline(always)]
            pub fn ch1_re(&self) -> Ch1ReR {
                Ch1ReR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Zero cross DMA request enable"]
            #[inline(always)]
            pub fn zc_re(&self) -> ZcReR {
                ZcReR::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ch0 cmp/cap interrupt request enable"]
            #[inline(always)]
            pub fn ch0_ie(&mut self) -> Ch0IeW<IeSpec> {
                Ch0IeW::new(self, 0)
            }
            #[doc = "Bit 1 - ch1 cmp/cap interrupt request enable"]
            #[inline(always)]
            pub fn ch1_ie(&mut self) -> Ch1IeW<IeSpec> {
                Ch1IeW::new(self, 1)
            }
            #[doc = "Bit 2 - Zero cross interrupt request enable"]
            #[inline(always)]
            pub fn zc_ie(&mut self) -> ZcIeW<IeSpec> {
                ZcIeW::new(self, 2)
            }
            #[doc = "Bit 8 - ch0 cmp/cap dma request enable"]
            #[inline(always)]
            pub fn ch0_re(&mut self) -> Ch0ReW<IeSpec> {
                Ch0ReW::new(self, 8)
            }
            #[doc = "Bit 9 - ch1 cmp/cap dma request enable"]
            #[inline(always)]
            pub fn ch1_re(&mut self) -> Ch1ReW<IeSpec> {
                Ch1ReW::new(self, 9)
            }
            #[doc = "Bit 10 - Zero cross DMA request enable"]
            #[inline(always)]
            pub fn zc_re(&mut self) -> ZcReW<IeSpec> {
                ZcReW::new(self, 10)
            }
        }
        #[doc = "Timer Interrupt Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IeSpec;
        impl crate::RegisterSpec for IeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ie::R`](R) reader structure"]
        impl crate::Readable for IeSpec {}
        #[doc = "`write(|w| ..)` method takes [`ie::W`](W) writer structure"]
        impl crate::Writable for IeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE to value 0"]
        impl crate::Resettable for IeSpec {}
    }
    #[doc = "IF (rw) register accessor: Timer Interrupt Flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@if_`] module"]
    #[doc(alias = "IF")]
    pub type If = crate::Reg<if_::IfSpec>;
    #[doc = "Timer Interrupt Flag"]
    pub mod if_ {
        #[doc = "Register `IF` reader"]
        pub type R = crate::R<IfSpec>;
        #[doc = "Register `IF` writer"]
        pub type W = crate::W<IfSpec>;
        #[doc = "Field `T0_CH0_IF` reader - ch0 cmp/cap interrupt flag"]
        pub type T0Ch0IfR = crate::BitReader;
        #[doc = "Field `T0_CH0_IF` writer - ch0 cmp/cap interrupt flag"]
        pub type T0Ch0IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `T0_CH1_IF` reader - ch1 cmp/cap interrupt flag"]
        pub type T0Ch1IfR = crate::BitReader;
        #[doc = "Field `T0_CH1_IF` writer - ch1 cmp/cap interrupt flag"]
        pub type T0Ch1IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ZC_IF` reader - Zero cross interrupt flag"]
        pub type ZcIfR = crate::BitReader;
        #[doc = "Field `ZC_IF` writer - Zero cross interrupt flag"]
        pub type ZcIfW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - ch0 cmp/cap interrupt flag"]
            #[inline(always)]
            pub fn t0_ch0_if(&self) -> T0Ch0IfR {
                T0Ch0IfR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - ch1 cmp/cap interrupt flag"]
            #[inline(always)]
            pub fn t0_ch1_if(&self) -> T0Ch1IfR {
                T0Ch1IfR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Zero cross interrupt flag"]
            #[inline(always)]
            pub fn zc_if(&self) -> ZcIfR {
                ZcIfR::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ch0 cmp/cap interrupt flag"]
            #[inline(always)]
            pub fn t0_ch0_if(&mut self) -> T0Ch0IfW<IfSpec> {
                T0Ch0IfW::new(self, 0)
            }
            #[doc = "Bit 1 - ch1 cmp/cap interrupt flag"]
            #[inline(always)]
            pub fn t0_ch1_if(&mut self) -> T0Ch1IfW<IfSpec> {
                T0Ch1IfW::new(self, 1)
            }
            #[doc = "Bit 2 - Zero cross interrupt flag"]
            #[inline(always)]
            pub fn zc_if(&mut self) -> ZcIfW<IfSpec> {
                ZcIfW::new(self, 2)
            }
        }
        #[doc = "Timer Interrupt Flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IfSpec;
        impl crate::RegisterSpec for IfSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`if_::R`](R) reader structure"]
        impl crate::Readable for IfSpec {}
        #[doc = "`write(|w| ..)` method takes [`if_::W`](W) writer structure"]
        impl crate::Writable for IfSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IF to value 0"]
        impl crate::Resettable for IfSpec {}
    }
}
#[doc = "UTIMER1 registers"]
pub type Utimer1 = crate::Periph<utimer1::RegisterBlock, 0x4001_0600>;
impl core::fmt::Debug for Utimer1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Utimer1").finish()
    }
}
#[doc = "UTIMER1 registers"]
pub mod utimer1 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        cfg: Cfg,
        th: Th,
        cnt: Cnt,
        cmp0: Cmp0,
        cmp1: Cmp1,
        evt: Evt,
        flt: Flt,
        ie: Ie,
        if_: If,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Timer configuration"]
        #[inline(always)]
        pub const fn cfg(&self) -> &Cfg {
            &self.cfg
        }
        #[doc = "0x04 - Timer counter threshold, timer will count from 0 to TH, then over again"]
        #[inline(always)]
        pub const fn th(&self) -> &Th {
            &self.th
        }
        #[doc = "0x08 - Timer current counter value (write to set)"]
        #[inline(always)]
        pub const fn cnt(&self) -> &Cnt {
            &self.cnt
        }
        #[doc = "0x0c - Timer Channel0 CMP/CAP threshold"]
        #[inline(always)]
        pub const fn cmp0(&self) -> &Cmp0 {
            &self.cmp0
        }
        #[doc = "0x10 - Timer Channel1 CMP/CAP threshold"]
        #[inline(always)]
        pub const fn cmp1(&self) -> &Cmp1 {
            &self.cmp1
        }
        #[doc = "0x14 - Timer External Trigger Event"]
        #[inline(always)]
        pub const fn evt(&self) -> &Evt {
            &self.evt
        }
        #[doc = "0x18 - Timer Filter Width (FLT*8 timer clock cycles)"]
        #[inline(always)]
        pub const fn flt(&self) -> &Flt {
            &self.flt
        }
        #[doc = "0x1c - Timer Interrupt Enable"]
        #[inline(always)]
        pub const fn ie(&self) -> &Ie {
            &self.ie
        }
        #[doc = "0x20 - Timer Interrupt Flag"]
        #[inline(always)]
        pub const fn if_(&self) -> &If {
            &self.if_
        }
    }
    #[doc = "CFG (rw) register accessor: Timer configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"]
    #[doc(alias = "CFG")]
    pub type Cfg = crate::Reg<cfg::CfgSpec>;
    #[doc = "Timer configuration"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CfgSpec>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CfgSpec>;
        #[doc = "Channel 0 rising edge capture enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch0ReCapEn {
            #[doc = "0: Rising edge event disabled"]
            Disabled = 0,
            #[doc = "1: Rising edge event enabled"]
            Enabled = 1,
        }
        impl From<Ch0ReCapEn> for bool {
            #[inline(always)]
            fn from(variant: Ch0ReCapEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH0_RE_CAP_EN` reader - Channel 0 rising edge capture enable"]
        pub type Ch0ReCapEnR = crate::BitReader<Ch0ReCapEn>;
        impl Ch0ReCapEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch0ReCapEn {
                match self.bits {
                    false => Ch0ReCapEn::Disabled,
                    true => Ch0ReCapEn::Enabled,
                }
            }
            #[doc = "Rising edge event disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ch0ReCapEn::Disabled
            }
            #[doc = "Rising edge event enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ch0ReCapEn::Enabled
            }
        }
        #[doc = "Field `CH0_RE_CAP_EN` writer - Channel 0 rising edge capture enable"]
        pub type Ch0ReCapEnW<'a, REG> = crate::BitWriter<'a, REG, Ch0ReCapEn>;
        impl<'a, REG> Ch0ReCapEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Rising edge event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0ReCapEn::Disabled)
            }
            #[doc = "Rising edge event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0ReCapEn::Enabled)
            }
        }
        #[doc = "Channel 0 falling edge capture enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch0FeCapEn {
            #[doc = "0: Falling edge event disabled"]
            Disabled = 0,
            #[doc = "1: Falling edge event enabled"]
            Enabled = 1,
        }
        impl From<Ch0FeCapEn> for bool {
            #[inline(always)]
            fn from(variant: Ch0FeCapEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH0_FE_CAP_EN` reader - Channel 0 falling edge capture enable"]
        pub type Ch0FeCapEnR = crate::BitReader<Ch0FeCapEn>;
        impl Ch0FeCapEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch0FeCapEn {
                match self.bits {
                    false => Ch0FeCapEn::Disabled,
                    true => Ch0FeCapEn::Enabled,
                }
            }
            #[doc = "Falling edge event disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ch0FeCapEn::Disabled
            }
            #[doc = "Falling edge event enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ch0FeCapEn::Enabled
            }
        }
        #[doc = "Field `CH0_FE_CAP_EN` writer - Channel 0 falling edge capture enable"]
        pub type Ch0FeCapEnW<'a, REG> = crate::BitWriter<'a, REG, Ch0FeCapEn>;
        impl<'a, REG> Ch0FeCapEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Falling edge event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0FeCapEn::Disabled)
            }
            #[doc = "Falling edge event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0FeCapEn::Enabled)
            }
        }
        #[doc = "Channel 0 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch0Mode {
            #[doc = "0: Comparison mode"]
            Cmp = 0,
            #[doc = "1: Capture mode"]
            Cap = 1,
        }
        impl From<Ch0Mode> for bool {
            #[inline(always)]
            fn from(variant: Ch0Mode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH0_MODE` reader - Channel 0 mode"]
        pub type Ch0ModeR = crate::BitReader<Ch0Mode>;
        impl Ch0ModeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch0Mode {
                match self.bits {
                    false => Ch0Mode::Cmp,
                    true => Ch0Mode::Cap,
                }
            }
            #[doc = "Comparison mode"]
            #[inline(always)]
            pub fn is_cmp(&self) -> bool {
                *self == Ch0Mode::Cmp
            }
            #[doc = "Capture mode"]
            #[inline(always)]
            pub fn is_cap(&self) -> bool {
                *self == Ch0Mode::Cap
            }
        }
        #[doc = "Field `CH0_MODE` writer - Channel 0 mode"]
        pub type Ch0ModeW<'a, REG> = crate::BitWriter<'a, REG, Ch0Mode>;
        impl<'a, REG> Ch0ModeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Comparison mode"]
            #[inline(always)]
            pub fn cmp(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0Mode::Cmp)
            }
            #[doc = "Capture mode"]
            #[inline(always)]
            pub fn cap(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0Mode::Cap)
            }
        }
        #[doc = "Channel 0 output polarity at zero-crossing in comparision mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch0Pol {
            #[doc = "0: Output 0"]
            L = 0,
            #[doc = "1: Output 1"]
            H = 1,
        }
        impl From<Ch0Pol> for bool {
            #[inline(always)]
            fn from(variant: Ch0Pol) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH0_POL` reader - Channel 0 output polarity at zero-crossing in comparision mode"]
        pub type Ch0PolR = crate::BitReader<Ch0Pol>;
        impl Ch0PolR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch0Pol {
                match self.bits {
                    false => Ch0Pol::L,
                    true => Ch0Pol::H,
                }
            }
            #[doc = "Output 0"]
            #[inline(always)]
            pub fn is_l(&self) -> bool {
                *self == Ch0Pol::L
            }
            #[doc = "Output 1"]
            #[inline(always)]
            pub fn is_h(&self) -> bool {
                *self == Ch0Pol::H
            }
        }
        #[doc = "Field `CH0_POL` writer - Channel 0 output polarity at zero-crossing in comparision mode"]
        pub type Ch0PolW<'a, REG> = crate::BitWriter<'a, REG, Ch0Pol>;
        impl<'a, REG> Ch0PolW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Output 0"]
            #[inline(always)]
            pub fn l(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0Pol::L)
            }
            #[doc = "Output 1"]
            #[inline(always)]
            pub fn h(self) -> &'a mut crate::W<REG> {
                self.variant(Ch0Pol::H)
            }
        }
        #[doc = "Timer capture mode ch0 source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Src0 {
            #[doc = "0: timer ch0"]
            Ch0 = 0,
            #[doc = "1: timer ch1"]
            Ch1 = 1,
            #[doc = "2: Comparator 0 output"]
            Cmp0 = 2,
            #[doc = "3: Comparator 1 output"]
            Cmp1 = 3,
            #[doc = "8: timer ch0^ch1"]
            Ch01xor = 8,
        }
        impl From<Src0> for u8 {
            #[inline(always)]
            fn from(variant: Src0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Src0 {
            type Ux = u8;
        }
        impl crate::IsEnum for Src0 {}
        #[doc = "Field `SRC0` reader - Timer capture mode ch0 source"]
        pub type Src0R = crate::FieldReader<Src0>;
        impl Src0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Src0> {
                match self.bits {
                    0 => Some(Src0::Ch0),
                    1 => Some(Src0::Ch1),
                    2 => Some(Src0::Cmp0),
                    3 => Some(Src0::Cmp1),
                    8 => Some(Src0::Ch01xor),
                    _ => None,
                }
            }
            #[doc = "timer ch0"]
            #[inline(always)]
            pub fn is_ch0(&self) -> bool {
                *self == Src0::Ch0
            }
            #[doc = "timer ch1"]
            #[inline(always)]
            pub fn is_ch1(&self) -> bool {
                *self == Src0::Ch1
            }
            #[doc = "Comparator 0 output"]
            #[inline(always)]
            pub fn is_cmp0(&self) -> bool {
                *self == Src0::Cmp0
            }
            #[doc = "Comparator 1 output"]
            #[inline(always)]
            pub fn is_cmp1(&self) -> bool {
                *self == Src0::Cmp1
            }
            #[doc = "timer ch0^ch1"]
            #[inline(always)]
            pub fn is_ch01xor(&self) -> bool {
                *self == Src0::Ch01xor
            }
        }
        #[doc = "Field `SRC0` writer - Timer capture mode ch0 source"]
        pub type Src0W<'a, REG> = crate::FieldWriter<'a, REG, 4, Src0>;
        impl<'a, REG> Src0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "timer ch0"]
            #[inline(always)]
            pub fn ch0(self) -> &'a mut crate::W<REG> {
                self.variant(Src0::Ch0)
            }
            #[doc = "timer ch1"]
            #[inline(always)]
            pub fn ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Src0::Ch1)
            }
            #[doc = "Comparator 0 output"]
            #[inline(always)]
            pub fn cmp0(self) -> &'a mut crate::W<REG> {
                self.variant(Src0::Cmp0)
            }
            #[doc = "Comparator 1 output"]
            #[inline(always)]
            pub fn cmp1(self) -> &'a mut crate::W<REG> {
                self.variant(Src0::Cmp1)
            }
            #[doc = "timer ch0^ch1"]
            #[inline(always)]
            pub fn ch01xor(self) -> &'a mut crate::W<REG> {
                self.variant(Src0::Ch01xor)
            }
        }
        #[doc = "Channel 1 rising edge capture enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch1ReCapEn {
            #[doc = "0: Rising edge event disabled"]
            Disabled = 0,
            #[doc = "1: Rising edge event enabled"]
            Enabled = 1,
        }
        impl From<Ch1ReCapEn> for bool {
            #[inline(always)]
            fn from(variant: Ch1ReCapEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH1_RE_CAP_EN` reader - Channel 1 rising edge capture enable"]
        pub type Ch1ReCapEnR = crate::BitReader<Ch1ReCapEn>;
        impl Ch1ReCapEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch1ReCapEn {
                match self.bits {
                    false => Ch1ReCapEn::Disabled,
                    true => Ch1ReCapEn::Enabled,
                }
            }
            #[doc = "Rising edge event disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ch1ReCapEn::Disabled
            }
            #[doc = "Rising edge event enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ch1ReCapEn::Enabled
            }
        }
        #[doc = "Field `CH1_RE_CAP_EN` writer - Channel 1 rising edge capture enable"]
        pub type Ch1ReCapEnW<'a, REG> = crate::BitWriter<'a, REG, Ch1ReCapEn>;
        impl<'a, REG> Ch1ReCapEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Rising edge event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1ReCapEn::Disabled)
            }
            #[doc = "Rising edge event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1ReCapEn::Enabled)
            }
        }
        #[doc = "Channel 1 falling edge capture enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch1FeCapEn {
            #[doc = "0: Falling edge event disabled"]
            Disabled = 0,
            #[doc = "1: Falling edge event enabled"]
            Enabled = 1,
        }
        impl From<Ch1FeCapEn> for bool {
            #[inline(always)]
            fn from(variant: Ch1FeCapEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH1_FE_CAP_EN` reader - Channel 1 falling edge capture enable"]
        pub type Ch1FeCapEnR = crate::BitReader<Ch1FeCapEn>;
        impl Ch1FeCapEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch1FeCapEn {
                match self.bits {
                    false => Ch1FeCapEn::Disabled,
                    true => Ch1FeCapEn::Enabled,
                }
            }
            #[doc = "Falling edge event disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ch1FeCapEn::Disabled
            }
            #[doc = "Falling edge event enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ch1FeCapEn::Enabled
            }
        }
        #[doc = "Field `CH1_FE_CAP_EN` writer - Channel 1 falling edge capture enable"]
        pub type Ch1FeCapEnW<'a, REG> = crate::BitWriter<'a, REG, Ch1FeCapEn>;
        impl<'a, REG> Ch1FeCapEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Falling edge event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1FeCapEn::Disabled)
            }
            #[doc = "Falling edge event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1FeCapEn::Enabled)
            }
        }
        #[doc = "Channel 1 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch1Mode {
            #[doc = "0: Comparison mode"]
            Cmp = 0,
            #[doc = "1: Capture mode"]
            Cap = 1,
        }
        impl From<Ch1Mode> for bool {
            #[inline(always)]
            fn from(variant: Ch1Mode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH1_MODE` reader - Channel 1 mode"]
        pub type Ch1ModeR = crate::BitReader<Ch1Mode>;
        impl Ch1ModeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch1Mode {
                match self.bits {
                    false => Ch1Mode::Cmp,
                    true => Ch1Mode::Cap,
                }
            }
            #[doc = "Comparison mode"]
            #[inline(always)]
            pub fn is_cmp(&self) -> bool {
                *self == Ch1Mode::Cmp
            }
            #[doc = "Capture mode"]
            #[inline(always)]
            pub fn is_cap(&self) -> bool {
                *self == Ch1Mode::Cap
            }
        }
        #[doc = "Field `CH1_MODE` writer - Channel 1 mode"]
        pub type Ch1ModeW<'a, REG> = crate::BitWriter<'a, REG, Ch1Mode>;
        impl<'a, REG> Ch1ModeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Comparison mode"]
            #[inline(always)]
            pub fn cmp(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1Mode::Cmp)
            }
            #[doc = "Capture mode"]
            #[inline(always)]
            pub fn cap(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1Mode::Cap)
            }
        }
        #[doc = "Channel 1 output polarity at zero-crossing in comparision mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ch1Pol {
            #[doc = "0: Output 0"]
            L = 0,
            #[doc = "1: Output 1"]
            H = 1,
        }
        impl From<Ch1Pol> for bool {
            #[inline(always)]
            fn from(variant: Ch1Pol) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CH1_POL` reader - Channel 1 output polarity at zero-crossing in comparision mode"]
        pub type Ch1PolR = crate::BitReader<Ch1Pol>;
        impl Ch1PolR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ch1Pol {
                match self.bits {
                    false => Ch1Pol::L,
                    true => Ch1Pol::H,
                }
            }
            #[doc = "Output 0"]
            #[inline(always)]
            pub fn is_l(&self) -> bool {
                *self == Ch1Pol::L
            }
            #[doc = "Output 1"]
            #[inline(always)]
            pub fn is_h(&self) -> bool {
                *self == Ch1Pol::H
            }
        }
        #[doc = "Field `CH1_POL` writer - Channel 1 output polarity at zero-crossing in comparision mode"]
        pub type Ch1PolW<'a, REG> = crate::BitWriter<'a, REG, Ch1Pol>;
        impl<'a, REG> Ch1PolW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Output 0"]
            #[inline(always)]
            pub fn l(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1Pol::L)
            }
            #[doc = "Output 1"]
            #[inline(always)]
            pub fn h(self) -> &'a mut crate::W<REG> {
                self.variant(Ch1Pol::H)
            }
        }
        #[doc = "Timer capture mode ch1 source\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Src1 {
            #[doc = "0: timer ch0"]
            Ch0 = 0,
            #[doc = "1: timer ch1"]
            Ch1 = 1,
            #[doc = "2: Comparator 0 output"]
            Cmp0 = 2,
            #[doc = "3: Comparator 1 output"]
            Cmp1 = 3,
            #[doc = "8: timer ch0^ch1"]
            Ch01xor = 8,
        }
        impl From<Src1> for u8 {
            #[inline(always)]
            fn from(variant: Src1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Src1 {
            type Ux = u8;
        }
        impl crate::IsEnum for Src1 {}
        #[doc = "Field `SRC1` reader - Timer capture mode ch1 source"]
        pub type Src1R = crate::FieldReader<Src1>;
        impl Src1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Src1> {
                match self.bits {
                    0 => Some(Src1::Ch0),
                    1 => Some(Src1::Ch1),
                    2 => Some(Src1::Cmp0),
                    3 => Some(Src1::Cmp1),
                    8 => Some(Src1::Ch01xor),
                    _ => None,
                }
            }
            #[doc = "timer ch0"]
            #[inline(always)]
            pub fn is_ch0(&self) -> bool {
                *self == Src1::Ch0
            }
            #[doc = "timer ch1"]
            #[inline(always)]
            pub fn is_ch1(&self) -> bool {
                *self == Src1::Ch1
            }
            #[doc = "Comparator 0 output"]
            #[inline(always)]
            pub fn is_cmp0(&self) -> bool {
                *self == Src1::Cmp0
            }
            #[doc = "Comparator 1 output"]
            #[inline(always)]
            pub fn is_cmp1(&self) -> bool {
                *self == Src1::Cmp1
            }
            #[doc = "timer ch0^ch1"]
            #[inline(always)]
            pub fn is_ch01xor(&self) -> bool {
                *self == Src1::Ch01xor
            }
        }
        #[doc = "Field `SRC1` writer - Timer capture mode ch1 source"]
        pub type Src1W<'a, REG> = crate::FieldWriter<'a, REG, 4, Src1>;
        impl<'a, REG> Src1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "timer ch0"]
            #[inline(always)]
            pub fn ch0(self) -> &'a mut crate::W<REG> {
                self.variant(Src1::Ch0)
            }
            #[doc = "timer ch1"]
            #[inline(always)]
            pub fn ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Src1::Ch1)
            }
            #[doc = "Comparator 0 output"]
            #[inline(always)]
            pub fn cmp0(self) -> &'a mut crate::W<REG> {
                self.variant(Src1::Cmp0)
            }
            #[doc = "Comparator 1 output"]
            #[inline(always)]
            pub fn cmp1(self) -> &'a mut crate::W<REG> {
                self.variant(Src1::Cmp1)
            }
            #[doc = "timer ch0^ch1"]
            #[inline(always)]
            pub fn ch01xor(self) -> &'a mut crate::W<REG> {
                self.variant(Src1::Ch01xor)
            }
        }
        #[doc = "Timer clock source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ClkSrc {
            #[doc = "0: internal system clock"]
            Sysclk = 0,
            #[doc = "2: timer0 ch0"]
            T0Ch0 = 2,
            #[doc = "3: timer0 ch1"]
            T0Ch1 = 3,
            #[doc = "4: timer1 ch0"]
            T1Ch0 = 4,
            #[doc = "5: timer1 ch1"]
            T1Ch1 = 5,
        }
        impl From<ClkSrc> for u8 {
            #[inline(always)]
            fn from(variant: ClkSrc) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ClkSrc {
            type Ux = u8;
        }
        impl crate::IsEnum for ClkSrc {}
        #[doc = "Field `CLK_SRC` reader - Timer clock source"]
        pub type ClkSrcR = crate::FieldReader<ClkSrc>;
        impl ClkSrcR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<ClkSrc> {
                match self.bits {
                    0 => Some(ClkSrc::Sysclk),
                    2 => Some(ClkSrc::T0Ch0),
                    3 => Some(ClkSrc::T0Ch1),
                    4 => Some(ClkSrc::T1Ch0),
                    5 => Some(ClkSrc::T1Ch1),
                    _ => None,
                }
            }
            #[doc = "internal system clock"]
            #[inline(always)]
            pub fn is_sysclk(&self) -> bool {
                *self == ClkSrc::Sysclk
            }
            #[doc = "timer0 ch0"]
            #[inline(always)]
            pub fn is_t0_ch0(&self) -> bool {
                *self == ClkSrc::T0Ch0
            }
            #[doc = "timer0 ch1"]
            #[inline(always)]
            pub fn is_t0_ch1(&self) -> bool {
                *self == ClkSrc::T0Ch1
            }
            #[doc = "timer1 ch0"]
            #[inline(always)]
            pub fn is_t1_ch0(&self) -> bool {
                *self == ClkSrc::T1Ch0
            }
            #[doc = "timer1 ch1"]
            #[inline(always)]
            pub fn is_t1_ch1(&self) -> bool {
                *self == ClkSrc::T1Ch1
            }
        }
        #[doc = "Field `CLK_SRC` writer - Timer clock source"]
        pub type ClkSrcW<'a, REG> = crate::FieldWriter<'a, REG, 4, ClkSrc>;
        impl<'a, REG> ClkSrcW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "internal system clock"]
            #[inline(always)]
            pub fn sysclk(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSrc::Sysclk)
            }
            #[doc = "timer0 ch0"]
            #[inline(always)]
            pub fn t0_ch0(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSrc::T0Ch0)
            }
            #[doc = "timer0 ch1"]
            #[inline(always)]
            pub fn t0_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSrc::T0Ch1)
            }
            #[doc = "timer1 ch0"]
            #[inline(always)]
            pub fn t1_ch0(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSrc::T1Ch0)
            }
            #[doc = "timer1 ch1"]
            #[inline(always)]
            pub fn t1_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(ClkSrc::T1Ch1)
            }
        }
        #[doc = "Timer clock division ratio\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ClkDiv {
            #[doc = "0: Main clock no division"]
            Div1 = 0,
            #[doc = "1: Main clock divided by 2"]
            Div2 = 1,
            #[doc = "2: Main clock divided by 4"]
            Div4 = 2,
            #[doc = "3: Main clock divided by 8"]
            Div8 = 3,
            #[doc = "4: Main clock divided by 16"]
            Div16 = 4,
            #[doc = "5: Main clock divided by 32"]
            Div32 = 5,
            #[doc = "6: Main clock divided by 64"]
            Div64 = 6,
            #[doc = "7: Main clock divided by 128"]
            Div128 = 7,
        }
        impl From<ClkDiv> for u8 {
            #[inline(always)]
            fn from(variant: ClkDiv) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ClkDiv {
            type Ux = u8;
        }
        impl crate::IsEnum for ClkDiv {}
        #[doc = "Field `CLK_DIV` reader - Timer clock division ratio"]
        pub type ClkDivR = crate::FieldReader<ClkDiv>;
        impl ClkDivR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ClkDiv {
                match self.bits {
                    0 => ClkDiv::Div1,
                    1 => ClkDiv::Div2,
                    2 => ClkDiv::Div4,
                    3 => ClkDiv::Div8,
                    4 => ClkDiv::Div16,
                    5 => ClkDiv::Div32,
                    6 => ClkDiv::Div64,
                    7 => ClkDiv::Div128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Main clock no division"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == ClkDiv::Div1
            }
            #[doc = "Main clock divided by 2"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ClkDiv::Div2
            }
            #[doc = "Main clock divided by 4"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ClkDiv::Div4
            }
            #[doc = "Main clock divided by 8"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ClkDiv::Div8
            }
            #[doc = "Main clock divided by 16"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == ClkDiv::Div16
            }
            #[doc = "Main clock divided by 32"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == ClkDiv::Div32
            }
            #[doc = "Main clock divided by 64"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == ClkDiv::Div64
            }
            #[doc = "Main clock divided by 128"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == ClkDiv::Div128
            }
        }
        #[doc = "Field `CLK_DIV` writer - Timer clock division ratio"]
        pub type ClkDivW<'a, REG> = crate::FieldWriter<'a, REG, 3, ClkDiv, crate::Safe>;
        impl<'a, REG> ClkDivW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Main clock no division"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div1)
            }
            #[doc = "Main clock divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div2)
            }
            #[doc = "Main clock divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div4)
            }
            #[doc = "Main clock divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div8)
            }
            #[doc = "Main clock divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div16)
            }
            #[doc = "Main clock divided by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div32)
            }
            #[doc = "Main clock divided by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div64)
            }
            #[doc = "Main clock divided by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div128)
            }
        }
        #[doc = "Timer external trigger\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Eton {
            #[doc = "0: Free run"]
            It = 0,
            #[doc = "1: Extrenal trigger"]
            Et = 1,
        }
        impl From<Eton> for bool {
            #[inline(always)]
            fn from(variant: Eton) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ETON` reader - Timer external trigger"]
        pub type EtonR = crate::BitReader<Eton>;
        impl EtonR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Eton {
                match self.bits {
                    false => Eton::It,
                    true => Eton::Et,
                }
            }
            #[doc = "Free run"]
            #[inline(always)]
            pub fn is_it(&self) -> bool {
                *self == Eton::It
            }
            #[doc = "Extrenal trigger"]
            #[inline(always)]
            pub fn is_et(&self) -> bool {
                *self == Eton::Et
            }
        }
        #[doc = "Field `ETON` writer - Timer external trigger"]
        pub type EtonW<'a, REG> = crate::BitWriter<'a, REG, Eton>;
        impl<'a, REG> EtonW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Free run"]
            #[inline(always)]
            pub fn it(self) -> &'a mut crate::W<REG> {
                self.variant(Eton::It)
            }
            #[doc = "Extrenal trigger"]
            #[inline(always)]
            pub fn et(self) -> &'a mut crate::W<REG> {
                self.variant(Eton::Et)
            }
        }
        #[doc = "Field `ONE_TRIG` reader - trigger timer to send for one period"]
        pub type OneTrigR = crate::BitReader;
        #[doc = "Field `ONE_TRIG` writer - trigger timer to send for one period"]
        pub type OneTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CAP0_CLR_EN` reader - clear timer cnt when CAP0"]
        pub type Cap0ClrEnR = crate::BitReader;
        #[doc = "Field `CAP0_CLR_EN` writer - clear timer cnt when CAP0"]
        pub type Cap0ClrEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CAP1_CLR_EN` reader - clear timer cnt when CAP1"]
        pub type Cap1ClrEnR = crate::BitReader;
        #[doc = "Field `CAP1_CLR_EN` writer - clear timer cnt when CAP1"]
        pub type Cap1ClrEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EN` reader - Timer enable"]
        pub type EnR = crate::BitReader;
        #[doc = "Field `EN` writer - Timer enable"]
        pub type EnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Channel 0 rising edge capture enable"]
            #[inline(always)]
            pub fn ch0_re_cap_en(&self) -> Ch0ReCapEnR {
                Ch0ReCapEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Channel 0 falling edge capture enable"]
            #[inline(always)]
            pub fn ch0_fe_cap_en(&self) -> Ch0FeCapEnR {
                Ch0FeCapEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Channel 0 mode"]
            #[inline(always)]
            pub fn ch0_mode(&self) -> Ch0ModeR {
                Ch0ModeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Channel 0 output polarity at zero-crossing in comparision mode"]
            #[inline(always)]
            pub fn ch0_pol(&self) -> Ch0PolR {
                Ch0PolR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:7 - Timer capture mode ch0 source"]
            #[inline(always)]
            pub fn src0(&self) -> Src0R {
                Src0R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bit 8 - Channel 1 rising edge capture enable"]
            #[inline(always)]
            pub fn ch1_re_cap_en(&self) -> Ch1ReCapEnR {
                Ch1ReCapEnR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Channel 1 falling edge capture enable"]
            #[inline(always)]
            pub fn ch1_fe_cap_en(&self) -> Ch1FeCapEnR {
                Ch1FeCapEnR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Channel 1 mode"]
            #[inline(always)]
            pub fn ch1_mode(&self) -> Ch1ModeR {
                Ch1ModeR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Channel 1 output polarity at zero-crossing in comparision mode"]
            #[inline(always)]
            pub fn ch1_pol(&self) -> Ch1PolR {
                Ch1PolR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bits 12:15 - Timer capture mode ch1 source"]
            #[inline(always)]
            pub fn src1(&self) -> Src1R {
                Src1R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 16:19 - Timer clock source"]
            #[inline(always)]
            pub fn clk_src(&self) -> ClkSrcR {
                ClkSrcR::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 20:22 - Timer clock division ratio"]
            #[inline(always)]
            pub fn clk_div(&self) -> ClkDivR {
                ClkDivR::new(((self.bits >> 20) & 7) as u8)
            }
            #[doc = "Bit 24 - Timer external trigger"]
            #[inline(always)]
            pub fn eton(&self) -> EtonR {
                EtonR::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - trigger timer to send for one period"]
            #[inline(always)]
            pub fn one_trig(&self) -> OneTrigR {
                OneTrigR::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - clear timer cnt when CAP0"]
            #[inline(always)]
            pub fn cap0_clr_en(&self) -> Cap0ClrEnR {
                Cap0ClrEnR::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - clear timer cnt when CAP1"]
            #[inline(always)]
            pub fn cap1_clr_en(&self) -> Cap1ClrEnR {
                Cap1ClrEnR::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 31 - Timer enable"]
            #[inline(always)]
            pub fn en(&self) -> EnR {
                EnR::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Channel 0 rising edge capture enable"]
            #[inline(always)]
            pub fn ch0_re_cap_en(&mut self) -> Ch0ReCapEnW<CfgSpec> {
                Ch0ReCapEnW::new(self, 0)
            }
            #[doc = "Bit 1 - Channel 0 falling edge capture enable"]
            #[inline(always)]
            pub fn ch0_fe_cap_en(&mut self) -> Ch0FeCapEnW<CfgSpec> {
                Ch0FeCapEnW::new(self, 1)
            }
            #[doc = "Bit 2 - Channel 0 mode"]
            #[inline(always)]
            pub fn ch0_mode(&mut self) -> Ch0ModeW<CfgSpec> {
                Ch0ModeW::new(self, 2)
            }
            #[doc = "Bit 3 - Channel 0 output polarity at zero-crossing in comparision mode"]
            #[inline(always)]
            pub fn ch0_pol(&mut self) -> Ch0PolW<CfgSpec> {
                Ch0PolW::new(self, 3)
            }
            #[doc = "Bits 4:7 - Timer capture mode ch0 source"]
            #[inline(always)]
            pub fn src0(&mut self) -> Src0W<CfgSpec> {
                Src0W::new(self, 4)
            }
            #[doc = "Bit 8 - Channel 1 rising edge capture enable"]
            #[inline(always)]
            pub fn ch1_re_cap_en(&mut self) -> Ch1ReCapEnW<CfgSpec> {
                Ch1ReCapEnW::new(self, 8)
            }
            #[doc = "Bit 9 - Channel 1 falling edge capture enable"]
            #[inline(always)]
            pub fn ch1_fe_cap_en(&mut self) -> Ch1FeCapEnW<CfgSpec> {
                Ch1FeCapEnW::new(self, 9)
            }
            #[doc = "Bit 10 - Channel 1 mode"]
            #[inline(always)]
            pub fn ch1_mode(&mut self) -> Ch1ModeW<CfgSpec> {
                Ch1ModeW::new(self, 10)
            }
            #[doc = "Bit 11 - Channel 1 output polarity at zero-crossing in comparision mode"]
            #[inline(always)]
            pub fn ch1_pol(&mut self) -> Ch1PolW<CfgSpec> {
                Ch1PolW::new(self, 11)
            }
            #[doc = "Bits 12:15 - Timer capture mode ch1 source"]
            #[inline(always)]
            pub fn src1(&mut self) -> Src1W<CfgSpec> {
                Src1W::new(self, 12)
            }
            #[doc = "Bits 16:19 - Timer clock source"]
            #[inline(always)]
            pub fn clk_src(&mut self) -> ClkSrcW<CfgSpec> {
                ClkSrcW::new(self, 16)
            }
            #[doc = "Bits 20:22 - Timer clock division ratio"]
            #[inline(always)]
            pub fn clk_div(&mut self) -> ClkDivW<CfgSpec> {
                ClkDivW::new(self, 20)
            }
            #[doc = "Bit 24 - Timer external trigger"]
            #[inline(always)]
            pub fn eton(&mut self) -> EtonW<CfgSpec> {
                EtonW::new(self, 24)
            }
            #[doc = "Bit 25 - trigger timer to send for one period"]
            #[inline(always)]
            pub fn one_trig(&mut self) -> OneTrigW<CfgSpec> {
                OneTrigW::new(self, 25)
            }
            #[doc = "Bit 26 - clear timer cnt when CAP0"]
            #[inline(always)]
            pub fn cap0_clr_en(&mut self) -> Cap0ClrEnW<CfgSpec> {
                Cap0ClrEnW::new(self, 26)
            }
            #[doc = "Bit 27 - clear timer cnt when CAP1"]
            #[inline(always)]
            pub fn cap1_clr_en(&mut self) -> Cap1ClrEnW<CfgSpec> {
                Cap1ClrEnW::new(self, 27)
            }
            #[doc = "Bit 31 - Timer enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EnW<CfgSpec> {
                EnW::new(self, 31)
            }
        }
        #[doc = "Timer configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgSpec;
        impl crate::RegisterSpec for CfgSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFG to value 0x1000"]
        impl crate::Resettable for CfgSpec {
            const RESET_VALUE: u32 = 0x1000;
        }
    }
    #[doc = "TH (rw) register accessor: Timer counter threshold, timer will count from 0 to TH, then over again\n\nYou can [`read`](crate::Reg::read) this register and get [`th::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th`] module"]
    #[doc(alias = "TH")]
    pub type Th = crate::Reg<th::ThSpec>;
    #[doc = "Timer counter threshold, timer will count from 0 to TH, then over again"]
    pub mod th {
        #[doc = "Register `TH` reader"]
        pub type R = crate::R<ThSpec>;
        #[doc = "Register `TH` writer"]
        pub type W = crate::W<ThSpec>;
        #[doc = "Field `TH` reader - Timer counter threshold"]
        pub type ThR = crate::FieldReader<u32>;
        #[doc = "Field `TH` writer - Timer counter threshold"]
        pub type ThW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Timer counter threshold"]
            #[inline(always)]
            pub fn th(&self) -> ThR {
                ThR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Timer counter threshold"]
            #[inline(always)]
            pub fn th(&mut self) -> ThW<ThSpec> {
                ThW::new(self, 0)
            }
        }
        #[doc = "Timer counter threshold, timer will count from 0 to TH, then over again\n\nYou can [`read`](crate::Reg::read) this register and get [`th::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ThSpec;
        impl crate::RegisterSpec for ThSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th::R`](R) reader structure"]
        impl crate::Readable for ThSpec {}
        #[doc = "`write(|w| ..)` method takes [`th::W`](W) writer structure"]
        impl crate::Writable for ThSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH to value 0"]
        impl crate::Resettable for ThSpec {}
    }
    #[doc = "CNT (rw) register accessor: Timer current counter value (write to set)\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
    #[doc(alias = "CNT")]
    pub type Cnt = crate::Reg<cnt::CntSpec>;
    #[doc = "Timer current counter value (write to set)"]
    pub mod cnt {
        #[doc = "Register `CNT` reader"]
        pub type R = crate::R<CntSpec>;
        #[doc = "Register `CNT` writer"]
        pub type W = crate::W<CntSpec>;
        #[doc = "Field `CNT` reader - Timer counter value"]
        pub type CntR = crate::FieldReader<u32>;
        #[doc = "Field `CNT` writer - Timer counter value"]
        pub type CntW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Timer counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CntR {
                CntR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Timer counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CntW<CntSpec> {
                CntW::new(self, 0)
            }
        }
        #[doc = "Timer current counter value (write to set)\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CntSpec;
        impl crate::RegisterSpec for CntSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt::R`](R) reader structure"]
        impl crate::Readable for CntSpec {}
        #[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"]
        impl crate::Writable for CntSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CNT to value 0"]
        impl crate::Resettable for CntSpec {}
    }
    #[doc = "CMP0 (rw) register accessor: Timer Channel0 CMP/CAP threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmp0`] module"]
    #[doc(alias = "CMP0")]
    pub type Cmp0 = crate::Reg<cmp0::Cmp0Spec>;
    #[doc = "Timer Channel0 CMP/CAP threshold"]
    pub mod cmp0 {
        #[doc = "Register `CMP0` reader"]
        pub type R = crate::R<Cmp0Spec>;
        #[doc = "Register `CMP0` writer"]
        pub type W = crate::W<Cmp0Spec>;
        #[doc = "Field `CMP0` reader - Timer Channel0 CMP/CAP threshold"]
        pub type Cmp0R = crate::FieldReader<u32>;
        #[doc = "Field `CMP0` writer - Timer Channel0 CMP/CAP threshold"]
        pub type Cmp0W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Timer Channel0 CMP/CAP threshold"]
            #[inline(always)]
            pub fn cmp0(&self) -> Cmp0R {
                Cmp0R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Timer Channel0 CMP/CAP threshold"]
            #[inline(always)]
            pub fn cmp0(&mut self) -> Cmp0W<Cmp0Spec> {
                Cmp0W::new(self, 0)
            }
        }
        #[doc = "Timer Channel0 CMP/CAP threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Cmp0Spec;
        impl crate::RegisterSpec for Cmp0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cmp0::R`](R) reader structure"]
        impl crate::Readable for Cmp0Spec {}
        #[doc = "`write(|w| ..)` method takes [`cmp0::W`](W) writer structure"]
        impl crate::Writable for Cmp0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CMP0 to value 0"]
        impl crate::Resettable for Cmp0Spec {}
    }
    #[doc = "CMP1 (rw) register accessor: Timer Channel1 CMP/CAP threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmp1`] module"]
    #[doc(alias = "CMP1")]
    pub type Cmp1 = crate::Reg<cmp1::Cmp1Spec>;
    #[doc = "Timer Channel1 CMP/CAP threshold"]
    pub mod cmp1 {
        #[doc = "Register `CMP1` reader"]
        pub type R = crate::R<Cmp1Spec>;
        #[doc = "Register `CMP1` writer"]
        pub type W = crate::W<Cmp1Spec>;
        #[doc = "Field `CMP1` reader - Timer Channel1 CMP/CAP threshold"]
        pub type Cmp1R = crate::FieldReader<u32>;
        #[doc = "Field `CMP1` writer - Timer Channel1 CMP/CAP threshold"]
        pub type Cmp1W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Timer Channel1 CMP/CAP threshold"]
            #[inline(always)]
            pub fn cmp1(&self) -> Cmp1R {
                Cmp1R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Timer Channel1 CMP/CAP threshold"]
            #[inline(always)]
            pub fn cmp1(&mut self) -> Cmp1W<Cmp1Spec> {
                Cmp1W::new(self, 0)
            }
        }
        #[doc = "Timer Channel1 CMP/CAP threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Cmp1Spec;
        impl crate::RegisterSpec for Cmp1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cmp1::R`](R) reader structure"]
        impl crate::Readable for Cmp1Spec {}
        #[doc = "`write(|w| ..)` method takes [`cmp1::W`](W) writer structure"]
        impl crate::Writable for Cmp1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CMP1 to value 0"]
        impl crate::Resettable for Cmp1Spec {}
    }
    #[doc = "EVT (rw) register accessor: Timer External Trigger Event\n\nYou can [`read`](crate::Reg::read) this register and get [`evt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@evt`] module"]
    #[doc(alias = "EVT")]
    pub type Evt = crate::Reg<evt::EvtSpec>;
    #[doc = "Timer External Trigger Event"]
    pub mod evt {
        #[doc = "Register `EVT` reader"]
        pub type R = crate::R<EvtSpec>;
        #[doc = "Register `EVT` writer"]
        pub type W = crate::W<EvtSpec>;
        #[doc = "external event select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Src {
            #[doc = "0: Use timer0 channel 0 as trigger"]
            T0Ch0 = 0,
            #[doc = "1: Use timer0 channel 1 as trigger"]
            T0Ch1 = 1,
            #[doc = "2: Use timer1 channel 0 as trigger"]
            T1Ch0 = 2,
            #[doc = "3: Use timer1 channel 1 as trigger"]
            T1Ch1 = 3,
            #[doc = "10: Use MCPWM TADC0 as trigger"]
            McpwmTadc0 = 10,
            #[doc = "11: Use MCPWM TADC1 as trigger"]
            McpwmTadc1 = 11,
            #[doc = "12: Use MCPWM TADC2 as trigger"]
            McpwmTadc2 = 12,
            #[doc = "13: Use MCPWM TADC3 as trigger"]
            McpwmTadc3 = 13,
        }
        impl From<Src> for u8 {
            #[inline(always)]
            fn from(variant: Src) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Src {
            type Ux = u8;
        }
        impl crate::IsEnum for Src {}
        #[doc = "Field `SRC` reader - external event select"]
        pub type SrcR = crate::FieldReader<Src>;
        impl SrcR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Src> {
                match self.bits {
                    0 => Some(Src::T0Ch0),
                    1 => Some(Src::T0Ch1),
                    2 => Some(Src::T1Ch0),
                    3 => Some(Src::T1Ch1),
                    10 => Some(Src::McpwmTadc0),
                    11 => Some(Src::McpwmTadc1),
                    12 => Some(Src::McpwmTadc2),
                    13 => Some(Src::McpwmTadc3),
                    _ => None,
                }
            }
            #[doc = "Use timer0 channel 0 as trigger"]
            #[inline(always)]
            pub fn is_t0_ch0(&self) -> bool {
                *self == Src::T0Ch0
            }
            #[doc = "Use timer0 channel 1 as trigger"]
            #[inline(always)]
            pub fn is_t0_ch1(&self) -> bool {
                *self == Src::T0Ch1
            }
            #[doc = "Use timer1 channel 0 as trigger"]
            #[inline(always)]
            pub fn is_t1_ch0(&self) -> bool {
                *self == Src::T1Ch0
            }
            #[doc = "Use timer1 channel 1 as trigger"]
            #[inline(always)]
            pub fn is_t1_ch1(&self) -> bool {
                *self == Src::T1Ch1
            }
            #[doc = "Use MCPWM TADC0 as trigger"]
            #[inline(always)]
            pub fn is_mcpwm_tadc0(&self) -> bool {
                *self == Src::McpwmTadc0
            }
            #[doc = "Use MCPWM TADC1 as trigger"]
            #[inline(always)]
            pub fn is_mcpwm_tadc1(&self) -> bool {
                *self == Src::McpwmTadc1
            }
            #[doc = "Use MCPWM TADC2 as trigger"]
            #[inline(always)]
            pub fn is_mcpwm_tadc2(&self) -> bool {
                *self == Src::McpwmTadc2
            }
            #[doc = "Use MCPWM TADC3 as trigger"]
            #[inline(always)]
            pub fn is_mcpwm_tadc3(&self) -> bool {
                *self == Src::McpwmTadc3
            }
        }
        #[doc = "Field `SRC` writer - external event select"]
        pub type SrcW<'a, REG> = crate::FieldWriter<'a, REG, 5, Src>;
        impl<'a, REG> SrcW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Use timer0 channel 0 as trigger"]
            #[inline(always)]
            pub fn t0_ch0(self) -> &'a mut crate::W<REG> {
                self.variant(Src::T0Ch0)
            }
            #[doc = "Use timer0 channel 1 as trigger"]
            #[inline(always)]
            pub fn t0_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Src::T0Ch1)
            }
            #[doc = "Use timer1 channel 0 as trigger"]
            #[inline(always)]
            pub fn t1_ch0(self) -> &'a mut crate::W<REG> {
                self.variant(Src::T1Ch0)
            }
            #[doc = "Use timer1 channel 1 as trigger"]
            #[inline(always)]
            pub fn t1_ch1(self) -> &'a mut crate::W<REG> {
                self.variant(Src::T1Ch1)
            }
            #[doc = "Use MCPWM TADC0 as trigger"]
            #[inline(always)]
            pub fn mcpwm_tadc0(self) -> &'a mut crate::W<REG> {
                self.variant(Src::McpwmTadc0)
            }
            #[doc = "Use MCPWM TADC1 as trigger"]
            #[inline(always)]
            pub fn mcpwm_tadc1(self) -> &'a mut crate::W<REG> {
                self.variant(Src::McpwmTadc1)
            }
            #[doc = "Use MCPWM TADC2 as trigger"]
            #[inline(always)]
            pub fn mcpwm_tadc2(self) -> &'a mut crate::W<REG> {
                self.variant(Src::McpwmTadc2)
            }
            #[doc = "Use MCPWM TADC3 as trigger"]
            #[inline(always)]
            pub fn mcpwm_tadc3(self) -> &'a mut crate::W<REG> {
                self.variant(Src::McpwmTadc3)
            }
        }
        impl R {
            #[doc = "Bits 0:4 - external event select"]
            #[inline(always)]
            pub fn src(&self) -> SrcR {
                SrcR::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:4 - external event select"]
            #[inline(always)]
            pub fn src(&mut self) -> SrcW<EvtSpec> {
                SrcW::new(self, 0)
            }
        }
        #[doc = "Timer External Trigger Event\n\nYou can [`read`](crate::Reg::read) this register and get [`evt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvtSpec;
        impl crate::RegisterSpec for EvtSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`evt::R`](R) reader structure"]
        impl crate::Readable for EvtSpec {}
        #[doc = "`write(|w| ..)` method takes [`evt::W`](W) writer structure"]
        impl crate::Writable for EvtSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets EVT to value 0"]
        impl crate::Resettable for EvtSpec {}
    }
    #[doc = "FLT (rw) register accessor: Timer Filter Width (FLT*8 timer clock cycles)\n\nYou can [`read`](crate::Reg::read) this register and get [`flt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@flt`] module"]
    #[doc(alias = "FLT")]
    pub type Flt = crate::Reg<flt::FltSpec>;
    #[doc = "Timer Filter Width (FLT*8 timer clock cycles)"]
    pub mod flt {
        #[doc = "Register `FLT` reader"]
        pub type R = crate::R<FltSpec>;
        #[doc = "Register `FLT` writer"]
        pub type W = crate::W<FltSpec>;
        #[doc = "Field `FLT` reader - Filter width"]
        pub type FltR = crate::FieldReader;
        #[doc = "Field `FLT` writer - Filter width"]
        pub type FltW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Filter width"]
            #[inline(always)]
            pub fn flt(&self) -> FltR {
                FltR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Filter width"]
            #[inline(always)]
            pub fn flt(&mut self) -> FltW<FltSpec> {
                FltW::new(self, 0)
            }
        }
        #[doc = "Timer Filter Width (FLT*8 timer clock cycles)\n\nYou can [`read`](crate::Reg::read) this register and get [`flt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FltSpec;
        impl crate::RegisterSpec for FltSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`flt::R`](R) reader structure"]
        impl crate::Readable for FltSpec {}
        #[doc = "`write(|w| ..)` method takes [`flt::W`](W) writer structure"]
        impl crate::Writable for FltSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FLT to value 0"]
        impl crate::Resettable for FltSpec {}
    }
    #[doc = "IE (rw) register accessor: Timer Interrupt Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie`] module"]
    #[doc(alias = "IE")]
    pub type Ie = crate::Reg<ie::IeSpec>;
    #[doc = "Timer Interrupt Enable"]
    pub mod ie {
        #[doc = "Register `IE` reader"]
        pub type R = crate::R<IeSpec>;
        #[doc = "Register `IE` writer"]
        pub type W = crate::W<IeSpec>;
        #[doc = "Field `CH0_IE` reader - ch0 cmp/cap interrupt request enable"]
        pub type Ch0IeR = crate::BitReader;
        #[doc = "Field `CH0_IE` writer - ch0 cmp/cap interrupt request enable"]
        pub type Ch0IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_IE` reader - ch1 cmp/cap interrupt request enable"]
        pub type Ch1IeR = crate::BitReader;
        #[doc = "Field `CH1_IE` writer - ch1 cmp/cap interrupt request enable"]
        pub type Ch1IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ZC_IE` reader - Zero cross interrupt request enable"]
        pub type ZcIeR = crate::BitReader;
        #[doc = "Field `ZC_IE` writer - Zero cross interrupt request enable"]
        pub type ZcIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0_RE` reader - ch0 cmp/cap dma request enable"]
        pub type Ch0ReR = crate::BitReader;
        #[doc = "Field `CH0_RE` writer - ch0 cmp/cap dma request enable"]
        pub type Ch0ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_RE` reader - ch1 cmp/cap dma request enable"]
        pub type Ch1ReR = crate::BitReader;
        #[doc = "Field `CH1_RE` writer - ch1 cmp/cap dma request enable"]
        pub type Ch1ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ZC_RE` reader - Zero cross DMA request enable"]
        pub type ZcReR = crate::BitReader;
        #[doc = "Field `ZC_RE` writer - Zero cross DMA request enable"]
        pub type ZcReW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - ch0 cmp/cap interrupt request enable"]
            #[inline(always)]
            pub fn ch0_ie(&self) -> Ch0IeR {
                Ch0IeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - ch1 cmp/cap interrupt request enable"]
            #[inline(always)]
            pub fn ch1_ie(&self) -> Ch1IeR {
                Ch1IeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Zero cross interrupt request enable"]
            #[inline(always)]
            pub fn zc_ie(&self) -> ZcIeR {
                ZcIeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 8 - ch0 cmp/cap dma request enable"]
            #[inline(always)]
            pub fn ch0_re(&self) -> Ch0ReR {
                Ch0ReR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - ch1 cmp/cap dma request enable"]
            #[inline(always)]
            pub fn ch1_re(&self) -> Ch1ReR {
                Ch1ReR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Zero cross DMA request enable"]
            #[inline(always)]
            pub fn zc_re(&self) -> ZcReR {
                ZcReR::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ch0 cmp/cap interrupt request enable"]
            #[inline(always)]
            pub fn ch0_ie(&mut self) -> Ch0IeW<IeSpec> {
                Ch0IeW::new(self, 0)
            }
            #[doc = "Bit 1 - ch1 cmp/cap interrupt request enable"]
            #[inline(always)]
            pub fn ch1_ie(&mut self) -> Ch1IeW<IeSpec> {
                Ch1IeW::new(self, 1)
            }
            #[doc = "Bit 2 - Zero cross interrupt request enable"]
            #[inline(always)]
            pub fn zc_ie(&mut self) -> ZcIeW<IeSpec> {
                ZcIeW::new(self, 2)
            }
            #[doc = "Bit 8 - ch0 cmp/cap dma request enable"]
            #[inline(always)]
            pub fn ch0_re(&mut self) -> Ch0ReW<IeSpec> {
                Ch0ReW::new(self, 8)
            }
            #[doc = "Bit 9 - ch1 cmp/cap dma request enable"]
            #[inline(always)]
            pub fn ch1_re(&mut self) -> Ch1ReW<IeSpec> {
                Ch1ReW::new(self, 9)
            }
            #[doc = "Bit 10 - Zero cross DMA request enable"]
            #[inline(always)]
            pub fn zc_re(&mut self) -> ZcReW<IeSpec> {
                ZcReW::new(self, 10)
            }
        }
        #[doc = "Timer Interrupt Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IeSpec;
        impl crate::RegisterSpec for IeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ie::R`](R) reader structure"]
        impl crate::Readable for IeSpec {}
        #[doc = "`write(|w| ..)` method takes [`ie::W`](W) writer structure"]
        impl crate::Writable for IeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE to value 0"]
        impl crate::Resettable for IeSpec {}
    }
    #[doc = "IF (rw) register accessor: Timer Interrupt Flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@if_`] module"]
    #[doc(alias = "IF")]
    pub type If = crate::Reg<if_::IfSpec>;
    #[doc = "Timer Interrupt Flag"]
    pub mod if_ {
        #[doc = "Register `IF` reader"]
        pub type R = crate::R<IfSpec>;
        #[doc = "Register `IF` writer"]
        pub type W = crate::W<IfSpec>;
        #[doc = "Field `T0_CH0_IF` reader - ch0 cmp/cap interrupt flag"]
        pub type T0Ch0IfR = crate::BitReader;
        #[doc = "Field `T0_CH0_IF` writer - ch0 cmp/cap interrupt flag"]
        pub type T0Ch0IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `T0_CH1_IF` reader - ch1 cmp/cap interrupt flag"]
        pub type T0Ch1IfR = crate::BitReader;
        #[doc = "Field `T0_CH1_IF` writer - ch1 cmp/cap interrupt flag"]
        pub type T0Ch1IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ZC_IF` reader - Zero cross interrupt flag"]
        pub type ZcIfR = crate::BitReader;
        #[doc = "Field `ZC_IF` writer - Zero cross interrupt flag"]
        pub type ZcIfW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - ch0 cmp/cap interrupt flag"]
            #[inline(always)]
            pub fn t0_ch0_if(&self) -> T0Ch0IfR {
                T0Ch0IfR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - ch1 cmp/cap interrupt flag"]
            #[inline(always)]
            pub fn t0_ch1_if(&self) -> T0Ch1IfR {
                T0Ch1IfR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Zero cross interrupt flag"]
            #[inline(always)]
            pub fn zc_if(&self) -> ZcIfR {
                ZcIfR::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ch0 cmp/cap interrupt flag"]
            #[inline(always)]
            pub fn t0_ch0_if(&mut self) -> T0Ch0IfW<IfSpec> {
                T0Ch0IfW::new(self, 0)
            }
            #[doc = "Bit 1 - ch1 cmp/cap interrupt flag"]
            #[inline(always)]
            pub fn t0_ch1_if(&mut self) -> T0Ch1IfW<IfSpec> {
                T0Ch1IfW::new(self, 1)
            }
            #[doc = "Bit 2 - Zero cross interrupt flag"]
            #[inline(always)]
            pub fn zc_if(&mut self) -> ZcIfW<IfSpec> {
                ZcIfW::new(self, 2)
            }
        }
        #[doc = "Timer Interrupt Flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IfSpec;
        impl crate::RegisterSpec for IfSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`if_::R`](R) reader structure"]
        impl crate::Readable for IfSpec {}
        #[doc = "`write(|w| ..)` method takes [`if_::W`](W) writer structure"]
        impl crate::Writable for IfSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IF to value 0"]
        impl crate::Resettable for IfSpec {}
    }
}
#[doc = "MCPWM registers"]
pub type Mcpwm = crate::Periph<mcpwm::RegisterBlock, 0x4001_0700>;
impl core::fmt::Debug for Mcpwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcpwm").finish()
    }
}
#[doc = "MCPWM registers"]
pub mod mcpwm {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        th00: Th00,
        th01: Th01,
        th10: Th10,
        th11: Th11,
        th20: Th20,
        th21: Th21,
        th30: Th30,
        th31: Th31,
        tmr0: Tmr0,
        tmr1: Tmr1,
        tmr2: Tmr2,
        tmr3: Tmr3,
        th0: Th0,
        th1: Th1,
        cnt0: Cnt0,
        cnt1: Cnt1,
        update: Update,
        fcnt: Fcnt,
        evt0: Evt0,
        evt1: Evt1,
        dth0: Dth0,
        dth1: Dth1,
        _reserved22: [u8; 0x18],
        flt: Flt,
        sdcfg: Sdcfg,
        auen: Auen,
        tclk: Tclk,
        ie0: Ie0,
        if0: If0,
        ie1: Ie1,
        if1: If1,
        eie: Eie,
        eif: Eif,
        re: Re,
        pp: Pp,
        io01: Io01,
        io23: Io23,
        fail012: Fail012,
        fail3: Fail3,
        prt: Prt,
        swap: Swap,
        chmsk: Chmsk,
    }
    impl RegisterBlock {
        #[doc = "0x00 - CH0 P 16-bit Threshold Value"]
        #[inline(always)]
        pub const fn th00(&self) -> &Th00 {
            &self.th00
        }
        #[doc = "0x04 - CH0 N 16-bit Threshold Value"]
        #[inline(always)]
        pub const fn th01(&self) -> &Th01 {
            &self.th01
        }
        #[doc = "0x08 - CH1 P 16-bit Threshold Value"]
        #[inline(always)]
        pub const fn th10(&self) -> &Th10 {
            &self.th10
        }
        #[doc = "0x0c - CH1 N 16-bit Threshold Value"]
        #[inline(always)]
        pub const fn th11(&self) -> &Th11 {
            &self.th11
        }
        #[doc = "0x10 - CH2 P 16-bit Threshold Value"]
        #[inline(always)]
        pub const fn th20(&self) -> &Th20 {
            &self.th20
        }
        #[doc = "0x14 - CH2 N 16-bit Threshold Value"]
        #[inline(always)]
        pub const fn th21(&self) -> &Th21 {
            &self.th21
        }
        #[doc = "0x18 - CH3 P 16-bit Threshold Value"]
        #[inline(always)]
        pub const fn th30(&self) -> &Th30 {
            &self.th30
        }
        #[doc = "0x1c - CH3 N 16-bit Threshold Value"]
        #[inline(always)]
        pub const fn th31(&self) -> &Th31 {
            &self.th31
        }
        #[doc = "0x20 - ADC Trigger time 0"]
        #[inline(always)]
        pub const fn tmr0(&self) -> &Tmr0 {
            &self.tmr0
        }
        #[doc = "0x24 - ADC Trigger time 1"]
        #[inline(always)]
        pub const fn tmr1(&self) -> &Tmr1 {
            &self.tmr1
        }
        #[doc = "0x28 - ADC Trigger time 2"]
        #[inline(always)]
        pub const fn tmr2(&self) -> &Tmr2 {
            &self.tmr2
        }
        #[doc = "0x2c - ADC Trigger time 3"]
        #[inline(always)]
        pub const fn tmr3(&self) -> &Tmr3 {
            &self.tmr3
        }
        #[doc = "0x30 - Base Counter 0 15-bit Unsigned Threshold Value"]
        #[inline(always)]
        pub const fn th0(&self) -> &Th0 {
            &self.th0
        }
        #[doc = "0x34 - Base Counter 1 15-bit Unsigned Threshold Value"]
        #[inline(always)]
        pub const fn th1(&self) -> &Th1 {
            &self.th1
        }
        #[doc = "0x38 - Base 0 Counter 16-bit Signed Threshold Value"]
        #[inline(always)]
        pub const fn cnt0(&self) -> &Cnt0 {
            &self.cnt0
        }
        #[doc = "0x3c - Base 1 Counter 16-bit Signed Value"]
        #[inline(always)]
        pub const fn cnt1(&self) -> &Cnt1 {
            &self.cnt1
        }
        #[doc = "0x40 - Mask Registers Manual Reload Configuration"]
        #[inline(always)]
        pub const fn update(&self) -> &Update {
            &self.update
        }
        #[doc = "0x44 - If MCPWM_FAIL012\\[15\\] = 1, when fail0/1 occure, store MCPWM_CNT0 to MCPWM_FCNT. If MCPWM_FAIL3\\[15\\] = 1, when fail2/3 occure, store MCPWM_CNT0 to MCPWM_FCNT."]
        #[inline(always)]
        pub const fn fcnt(&self) -> &Fcnt {
            &self.fcnt
        }
        #[doc = "0x48 - MCPWM Base 0 External Trigger Register"]
        #[inline(always)]
        pub const fn evt0(&self) -> &Evt0 {
            &self.evt0
        }
        #[doc = "0x4c - MCPWM Base 1 External Trigger Register"]
        #[inline(always)]
        pub const fn evt1(&self) -> &Evt1 {
            &self.evt1
        }
        #[doc = "0x50 - Channelx N Dead Zone Control Register, 10-bit Unsigned"]
        #[inline(always)]
        pub const fn dth0(&self) -> &Dth0 {
            &self.dth0
        }
        #[doc = "0x54 - Channelx P Dead Zone Control Register, 10-bit Unsigned"]
        #[inline(always)]
        pub const fn dth1(&self) -> &Dth1 {
            &self.dth1
        }
        #[doc = "0x70 - FAIL signal filter config"]
        #[inline(always)]
        pub const fn flt(&self) -> &Flt {
            &self.flt
        }
        #[doc = "0x74 - Shadow Registers Reload Configuration"]
        #[inline(always)]
        pub const fn sdcfg(&self) -> &Sdcfg {
            &self.sdcfg
        }
        #[doc = "0x78 - Auto update enable"]
        #[inline(always)]
        pub const fn auen(&self) -> &Auen {
            &self.auen
        }
        #[doc = "0x7c - MCPWM Clock Configuration Register"]
        #[inline(always)]
        pub const fn tclk(&self) -> &Tclk {
            &self.tclk
        }
        #[doc = "0x80 - Counter0 based Interrupt Sources Enable"]
        #[inline(always)]
        pub const fn ie0(&self) -> &Ie0 {
            &self.ie0
        }
        #[doc = "0x84 - Counter0 based Interrupt Flags"]
        #[inline(always)]
        pub const fn if0(&self) -> &If0 {
            &self.if0
        }
        #[doc = "0x88 - Counter1 based Interrupt Sources Enable"]
        #[inline(always)]
        pub const fn ie1(&self) -> &Ie1 {
            &self.ie1
        }
        #[doc = "0x8c - Counter1 based Interrupt Flags"]
        #[inline(always)]
        pub const fn if1(&self) -> &If1 {
            &self.if1
        }
        #[doc = "0x90 - Error Interrupt Sources Enable"]
        #[inline(always)]
        pub const fn eie(&self) -> &Eie {
            &self.eie
        }
        #[doc = "0x94 - Error Interrupt Flags"]
        #[inline(always)]
        pub const fn eif(&self) -> &Eif {
            &self.eif
        }
        #[doc = "0x98 - DMA request enable"]
        #[inline(always)]
        pub const fn re(&self) -> &Re {
            &self.re
        }
        #[doc = "0x9c - Push-Pull configuration"]
        #[inline(always)]
        pub const fn pp(&self) -> &Pp {
            &self.pp
        }
        #[doc = "0xa0 - Channel 0/1 Setting"]
        #[inline(always)]
        pub const fn io01(&self) -> &Io01 {
            &self.io01
        }
        #[doc = "0xa4 - Channel 2/3 Setting"]
        #[inline(always)]
        pub const fn io23(&self) -> &Io23 {
            &self.io23
        }
        #[doc = "0xa8 - MCPWM Channel 012 Short Control Register"]
        #[inline(always)]
        pub const fn fail012(&self) -> &Fail012 {
            &self.fail012
        }
        #[doc = "0xac - MCPWM Channel 3 Short Control Register"]
        #[inline(always)]
        pub const fn fail3(&self) -> &Fail3 {
            &self.fail3
        }
        #[doc = "0xb0 - MCPWM Register Protection.Write 0xDEAD to unlock Protect"]
        #[inline(always)]
        pub const fn prt(&self) -> &Prt {
            &self.prt
        }
        #[doc = "0xb4 - MCPWM channel swap"]
        #[inline(always)]
        pub const fn swap(&self) -> &Swap {
            &self.swap
        }
        #[doc = "0xb8 - MCPWM channel mask"]
        #[inline(always)]
        pub const fn chmsk(&self) -> &Chmsk {
            &self.chmsk
        }
    }
    #[doc = "TH00 (rw) register accessor: CH0 P 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th00::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th00::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th00`] module"]
    #[doc(alias = "TH00")]
    pub type Th00 = crate::Reg<th00::Th00Spec>;
    #[doc = "CH0 P 16-bit Threshold Value"]
    pub mod th00 {
        #[doc = "Register `TH00` reader"]
        pub type R = crate::R<Th00Spec>;
        #[doc = "Register `TH00` writer"]
        pub type W = crate::W<Th00Spec>;
        #[doc = "Field `TH00` reader - Channel0 P-side threshold"]
        pub type Th00R = crate::FieldReader<u16>;
        #[doc = "Field `TH00` writer - Channel0 P-side threshold"]
        pub type Th00W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Channel0 P-side threshold"]
            #[inline(always)]
            pub fn th00(&self) -> Th00R {
                Th00R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Channel0 P-side threshold"]
            #[inline(always)]
            pub fn th00(&mut self) -> Th00W<Th00Spec> {
                Th00W::new(self, 0)
            }
        }
        #[doc = "CH0 P 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th00::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th00::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Th00Spec;
        impl crate::RegisterSpec for Th00Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th00::R`](R) reader structure"]
        impl crate::Readable for Th00Spec {}
        #[doc = "`write(|w| ..)` method takes [`th00::W`](W) writer structure"]
        impl crate::Writable for Th00Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH00 to value 0"]
        impl crate::Resettable for Th00Spec {}
    }
    #[doc = "TH01 (rw) register accessor: CH0 N 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th01::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th01::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th01`] module"]
    #[doc(alias = "TH01")]
    pub type Th01 = crate::Reg<th01::Th01Spec>;
    #[doc = "CH0 N 16-bit Threshold Value"]
    pub mod th01 {
        #[doc = "Register `TH01` reader"]
        pub type R = crate::R<Th01Spec>;
        #[doc = "Register `TH01` writer"]
        pub type W = crate::W<Th01Spec>;
        #[doc = "Field `TH01` reader - Channel0 N-side threshold"]
        pub type Th01R = crate::FieldReader<u16>;
        #[doc = "Field `TH01` writer - Channel0 N-side threshold"]
        pub type Th01W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Channel0 N-side threshold"]
            #[inline(always)]
            pub fn th01(&self) -> Th01R {
                Th01R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Channel0 N-side threshold"]
            #[inline(always)]
            pub fn th01(&mut self) -> Th01W<Th01Spec> {
                Th01W::new(self, 0)
            }
        }
        #[doc = "CH0 N 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th01::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th01::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Th01Spec;
        impl crate::RegisterSpec for Th01Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th01::R`](R) reader structure"]
        impl crate::Readable for Th01Spec {}
        #[doc = "`write(|w| ..)` method takes [`th01::W`](W) writer structure"]
        impl crate::Writable for Th01Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH01 to value 0"]
        impl crate::Resettable for Th01Spec {}
    }
    #[doc = "TH10 (rw) register accessor: CH1 P 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th10::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th10::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th10`] module"]
    #[doc(alias = "TH10")]
    pub type Th10 = crate::Reg<th10::Th10Spec>;
    #[doc = "CH1 P 16-bit Threshold Value"]
    pub mod th10 {
        #[doc = "Register `TH10` reader"]
        pub type R = crate::R<Th10Spec>;
        #[doc = "Register `TH10` writer"]
        pub type W = crate::W<Th10Spec>;
        #[doc = "Field `TH10` reader - Channel1 P-side threshold"]
        pub type Th10R = crate::FieldReader<u16>;
        #[doc = "Field `TH10` writer - Channel1 P-side threshold"]
        pub type Th10W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Channel1 P-side threshold"]
            #[inline(always)]
            pub fn th10(&self) -> Th10R {
                Th10R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Channel1 P-side threshold"]
            #[inline(always)]
            pub fn th10(&mut self) -> Th10W<Th10Spec> {
                Th10W::new(self, 0)
            }
        }
        #[doc = "CH1 P 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th10::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th10::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Th10Spec;
        impl crate::RegisterSpec for Th10Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th10::R`](R) reader structure"]
        impl crate::Readable for Th10Spec {}
        #[doc = "`write(|w| ..)` method takes [`th10::W`](W) writer structure"]
        impl crate::Writable for Th10Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH10 to value 0"]
        impl crate::Resettable for Th10Spec {}
    }
    #[doc = "TH11 (rw) register accessor: CH1 N 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th11::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th11::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th11`] module"]
    #[doc(alias = "TH11")]
    pub type Th11 = crate::Reg<th11::Th11Spec>;
    #[doc = "CH1 N 16-bit Threshold Value"]
    pub mod th11 {
        #[doc = "Register `TH11` reader"]
        pub type R = crate::R<Th11Spec>;
        #[doc = "Register `TH11` writer"]
        pub type W = crate::W<Th11Spec>;
        #[doc = "Field `TH11` reader - Channel1 N-side threshold"]
        pub type Th11R = crate::FieldReader<u16>;
        #[doc = "Field `TH11` writer - Channel1 N-side threshold"]
        pub type Th11W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Channel1 N-side threshold"]
            #[inline(always)]
            pub fn th11(&self) -> Th11R {
                Th11R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Channel1 N-side threshold"]
            #[inline(always)]
            pub fn th11(&mut self) -> Th11W<Th11Spec> {
                Th11W::new(self, 0)
            }
        }
        #[doc = "CH1 N 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th11::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th11::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Th11Spec;
        impl crate::RegisterSpec for Th11Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th11::R`](R) reader structure"]
        impl crate::Readable for Th11Spec {}
        #[doc = "`write(|w| ..)` method takes [`th11::W`](W) writer structure"]
        impl crate::Writable for Th11Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH11 to value 0"]
        impl crate::Resettable for Th11Spec {}
    }
    #[doc = "TH20 (rw) register accessor: CH2 P 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th20::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th20::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th20`] module"]
    #[doc(alias = "TH20")]
    pub type Th20 = crate::Reg<th20::Th20Spec>;
    #[doc = "CH2 P 16-bit Threshold Value"]
    pub mod th20 {
        #[doc = "Register `TH20` reader"]
        pub type R = crate::R<Th20Spec>;
        #[doc = "Register `TH20` writer"]
        pub type W = crate::W<Th20Spec>;
        #[doc = "Field `TH20` reader - Channel2 P-side threshold"]
        pub type Th20R = crate::FieldReader<u16>;
        #[doc = "Field `TH20` writer - Channel2 P-side threshold"]
        pub type Th20W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Channel2 P-side threshold"]
            #[inline(always)]
            pub fn th20(&self) -> Th20R {
                Th20R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Channel2 P-side threshold"]
            #[inline(always)]
            pub fn th20(&mut self) -> Th20W<Th20Spec> {
                Th20W::new(self, 0)
            }
        }
        #[doc = "CH2 P 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th20::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th20::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Th20Spec;
        impl crate::RegisterSpec for Th20Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th20::R`](R) reader structure"]
        impl crate::Readable for Th20Spec {}
        #[doc = "`write(|w| ..)` method takes [`th20::W`](W) writer structure"]
        impl crate::Writable for Th20Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH20 to value 0"]
        impl crate::Resettable for Th20Spec {}
    }
    #[doc = "TH21 (rw) register accessor: CH2 N 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th21::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th21::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th21`] module"]
    #[doc(alias = "TH21")]
    pub type Th21 = crate::Reg<th21::Th21Spec>;
    #[doc = "CH2 N 16-bit Threshold Value"]
    pub mod th21 {
        #[doc = "Register `TH21` reader"]
        pub type R = crate::R<Th21Spec>;
        #[doc = "Register `TH21` writer"]
        pub type W = crate::W<Th21Spec>;
        #[doc = "Field `TH21` reader - Channel2 N-side threshold"]
        pub type Th21R = crate::FieldReader<u16>;
        #[doc = "Field `TH21` writer - Channel2 N-side threshold"]
        pub type Th21W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Channel2 N-side threshold"]
            #[inline(always)]
            pub fn th21(&self) -> Th21R {
                Th21R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Channel2 N-side threshold"]
            #[inline(always)]
            pub fn th21(&mut self) -> Th21W<Th21Spec> {
                Th21W::new(self, 0)
            }
        }
        #[doc = "CH2 N 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th21::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th21::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Th21Spec;
        impl crate::RegisterSpec for Th21Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th21::R`](R) reader structure"]
        impl crate::Readable for Th21Spec {}
        #[doc = "`write(|w| ..)` method takes [`th21::W`](W) writer structure"]
        impl crate::Writable for Th21Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH21 to value 0"]
        impl crate::Resettable for Th21Spec {}
    }
    #[doc = "TH30 (rw) register accessor: CH3 P 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th30::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th30::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th30`] module"]
    #[doc(alias = "TH30")]
    pub type Th30 = crate::Reg<th30::Th30Spec>;
    #[doc = "CH3 P 16-bit Threshold Value"]
    pub mod th30 {
        #[doc = "Register `TH30` reader"]
        pub type R = crate::R<Th30Spec>;
        #[doc = "Register `TH30` writer"]
        pub type W = crate::W<Th30Spec>;
        #[doc = "Field `TH30` reader - Channel3 P-side threshold"]
        pub type Th30R = crate::FieldReader<u16>;
        #[doc = "Field `TH30` writer - Channel3 P-side threshold"]
        pub type Th30W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Channel3 P-side threshold"]
            #[inline(always)]
            pub fn th30(&self) -> Th30R {
                Th30R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Channel3 P-side threshold"]
            #[inline(always)]
            pub fn th30(&mut self) -> Th30W<Th30Spec> {
                Th30W::new(self, 0)
            }
        }
        #[doc = "CH3 P 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th30::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th30::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Th30Spec;
        impl crate::RegisterSpec for Th30Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th30::R`](R) reader structure"]
        impl crate::Readable for Th30Spec {}
        #[doc = "`write(|w| ..)` method takes [`th30::W`](W) writer structure"]
        impl crate::Writable for Th30Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH30 to value 0"]
        impl crate::Resettable for Th30Spec {}
    }
    #[doc = "TH31 (rw) register accessor: CH3 N 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th31::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th31::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th31`] module"]
    #[doc(alias = "TH31")]
    pub type Th31 = crate::Reg<th31::Th31Spec>;
    #[doc = "CH3 N 16-bit Threshold Value"]
    pub mod th31 {
        #[doc = "Register `TH31` reader"]
        pub type R = crate::R<Th31Spec>;
        #[doc = "Register `TH31` writer"]
        pub type W = crate::W<Th31Spec>;
        #[doc = "Field `TH31` reader - Channel3 N-side threshold"]
        pub type Th31R = crate::FieldReader<u16>;
        #[doc = "Field `TH31` writer - Channel3 N-side threshold"]
        pub type Th31W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Channel3 N-side threshold"]
            #[inline(always)]
            pub fn th31(&self) -> Th31R {
                Th31R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Channel3 N-side threshold"]
            #[inline(always)]
            pub fn th31(&mut self) -> Th31W<Th31Spec> {
                Th31W::new(self, 0)
            }
        }
        #[doc = "CH3 N 16-bit Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th31::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th31::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Th31Spec;
        impl crate::RegisterSpec for Th31Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th31::R`](R) reader structure"]
        impl crate::Readable for Th31Spec {}
        #[doc = "`write(|w| ..)` method takes [`th31::W`](W) writer structure"]
        impl crate::Writable for Th31Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH31 to value 0"]
        impl crate::Resettable for Th31Spec {}
    }
    #[doc = "TMR0 (rw) register accessor: ADC Trigger time 0\n\nYou can [`read`](crate::Reg::read) this register and get [`tmr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tmr0`] module"]
    #[doc(alias = "TMR0")]
    pub type Tmr0 = crate::Reg<tmr0::Tmr0Spec>;
    #[doc = "ADC Trigger time 0"]
    pub mod tmr0 {
        #[doc = "Register `TMR0` reader"]
        pub type R = crate::R<Tmr0Spec>;
        #[doc = "Register `TMR0` writer"]
        pub type W = crate::W<Tmr0Spec>;
        #[doc = "Field `TMR0` reader - ADC Trigger time 0 counter value"]
        pub type Tmr0R = crate::FieldReader<u16>;
        #[doc = "Field `TMR0` writer - ADC Trigger time 0 counter value"]
        pub type Tmr0W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC Trigger time 0 counter value"]
            #[inline(always)]
            pub fn tmr0(&self) -> Tmr0R {
                Tmr0R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC Trigger time 0 counter value"]
            #[inline(always)]
            pub fn tmr0(&mut self) -> Tmr0W<Tmr0Spec> {
                Tmr0W::new(self, 0)
            }
        }
        #[doc = "ADC Trigger time 0\n\nYou can [`read`](crate::Reg::read) this register and get [`tmr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Tmr0Spec;
        impl crate::RegisterSpec for Tmr0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tmr0::R`](R) reader structure"]
        impl crate::Readable for Tmr0Spec {}
        #[doc = "`write(|w| ..)` method takes [`tmr0::W`](W) writer structure"]
        impl crate::Writable for Tmr0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TMR0 to value 0x7fff"]
        impl crate::Resettable for Tmr0Spec {
            const RESET_VALUE: u32 = 0x7fff;
        }
    }
    #[doc = "TMR1 (rw) register accessor: ADC Trigger time 1\n\nYou can [`read`](crate::Reg::read) this register and get [`tmr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tmr1`] module"]
    #[doc(alias = "TMR1")]
    pub type Tmr1 = crate::Reg<tmr1::Tmr1Spec>;
    #[doc = "ADC Trigger time 1"]
    pub mod tmr1 {
        #[doc = "Register `TMR1` reader"]
        pub type R = crate::R<Tmr1Spec>;
        #[doc = "Register `TMR1` writer"]
        pub type W = crate::W<Tmr1Spec>;
        #[doc = "Field `TMR1` reader - ADC Trigger time 1 counter value"]
        pub type Tmr1R = crate::FieldReader<u16>;
        #[doc = "Field `TMR1` writer - ADC Trigger time 1 counter value"]
        pub type Tmr1W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC Trigger time 1 counter value"]
            #[inline(always)]
            pub fn tmr1(&self) -> Tmr1R {
                Tmr1R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC Trigger time 1 counter value"]
            #[inline(always)]
            pub fn tmr1(&mut self) -> Tmr1W<Tmr1Spec> {
                Tmr1W::new(self, 0)
            }
        }
        #[doc = "ADC Trigger time 1\n\nYou can [`read`](crate::Reg::read) this register and get [`tmr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Tmr1Spec;
        impl crate::RegisterSpec for Tmr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tmr1::R`](R) reader structure"]
        impl crate::Readable for Tmr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`tmr1::W`](W) writer structure"]
        impl crate::Writable for Tmr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TMR1 to value 0x7fff"]
        impl crate::Resettable for Tmr1Spec {
            const RESET_VALUE: u32 = 0x7fff;
        }
    }
    #[doc = "TMR2 (rw) register accessor: ADC Trigger time 2\n\nYou can [`read`](crate::Reg::read) this register and get [`tmr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tmr2`] module"]
    #[doc(alias = "TMR2")]
    pub type Tmr2 = crate::Reg<tmr2::Tmr2Spec>;
    #[doc = "ADC Trigger time 2"]
    pub mod tmr2 {
        #[doc = "Register `TMR2` reader"]
        pub type R = crate::R<Tmr2Spec>;
        #[doc = "Register `TMR2` writer"]
        pub type W = crate::W<Tmr2Spec>;
        #[doc = "Field `TMR2` reader - ADC Trigger time 2 counter value"]
        pub type Tmr2R = crate::FieldReader<u16>;
        #[doc = "Field `TMR2` writer - ADC Trigger time 2 counter value"]
        pub type Tmr2W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC Trigger time 2 counter value"]
            #[inline(always)]
            pub fn tmr2(&self) -> Tmr2R {
                Tmr2R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC Trigger time 2 counter value"]
            #[inline(always)]
            pub fn tmr2(&mut self) -> Tmr2W<Tmr2Spec> {
                Tmr2W::new(self, 0)
            }
        }
        #[doc = "ADC Trigger time 2\n\nYou can [`read`](crate::Reg::read) this register and get [`tmr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Tmr2Spec;
        impl crate::RegisterSpec for Tmr2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tmr2::R`](R) reader structure"]
        impl crate::Readable for Tmr2Spec {}
        #[doc = "`write(|w| ..)` method takes [`tmr2::W`](W) writer structure"]
        impl crate::Writable for Tmr2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TMR2 to value 0x7fff"]
        impl crate::Resettable for Tmr2Spec {
            const RESET_VALUE: u32 = 0x7fff;
        }
    }
    #[doc = "TMR3 (rw) register accessor: ADC Trigger time 3\n\nYou can [`read`](crate::Reg::read) this register and get [`tmr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tmr3`] module"]
    #[doc(alias = "TMR3")]
    pub type Tmr3 = crate::Reg<tmr3::Tmr3Spec>;
    #[doc = "ADC Trigger time 3"]
    pub mod tmr3 {
        #[doc = "Register `TMR3` reader"]
        pub type R = crate::R<Tmr3Spec>;
        #[doc = "Register `TMR3` writer"]
        pub type W = crate::W<Tmr3Spec>;
        #[doc = "Field `TMR3` reader - ADC Trigger time 3 counter value"]
        pub type Tmr3R = crate::FieldReader<u16>;
        #[doc = "Field `TMR3` writer - ADC Trigger time 3 counter value"]
        pub type Tmr3W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - ADC Trigger time 3 counter value"]
            #[inline(always)]
            pub fn tmr3(&self) -> Tmr3R {
                Tmr3R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC Trigger time 3 counter value"]
            #[inline(always)]
            pub fn tmr3(&mut self) -> Tmr3W<Tmr3Spec> {
                Tmr3W::new(self, 0)
            }
        }
        #[doc = "ADC Trigger time 3\n\nYou can [`read`](crate::Reg::read) this register and get [`tmr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Tmr3Spec;
        impl crate::RegisterSpec for Tmr3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tmr3::R`](R) reader structure"]
        impl crate::Readable for Tmr3Spec {}
        #[doc = "`write(|w| ..)` method takes [`tmr3::W`](W) writer structure"]
        impl crate::Writable for Tmr3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TMR3 to value 0x7fff"]
        impl crate::Resettable for Tmr3Spec {
            const RESET_VALUE: u32 = 0x7fff;
        }
    }
    #[doc = "TH0 (rw) register accessor: Base Counter 0 15-bit Unsigned Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th0`] module"]
    #[doc(alias = "TH0")]
    pub type Th0 = crate::Reg<th0::Th0Spec>;
    #[doc = "Base Counter 0 15-bit Unsigned Threshold Value"]
    pub mod th0 {
        #[doc = "Register `TH0` reader"]
        pub type R = crate::R<Th0Spec>;
        #[doc = "Register `TH0` writer"]
        pub type W = crate::W<Th0Spec>;
        #[doc = "Field `TH0` reader - MCPWM Counter 0 TH"]
        pub type Th0R = crate::FieldReader<u16>;
        #[doc = "Field `TH0` writer - MCPWM Counter 0 TH"]
        pub type Th0W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            #[doc = "Bits 0:14 - MCPWM Counter 0 TH"]
            #[inline(always)]
            pub fn th0(&self) -> Th0R {
                Th0R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:14 - MCPWM Counter 0 TH"]
            #[inline(always)]
            pub fn th0(&mut self) -> Th0W<Th0Spec> {
                Th0W::new(self, 0)
            }
        }
        #[doc = "Base Counter 0 15-bit Unsigned Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Th0Spec;
        impl crate::RegisterSpec for Th0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th0::R`](R) reader structure"]
        impl crate::Readable for Th0Spec {}
        #[doc = "`write(|w| ..)` method takes [`th0::W`](W) writer structure"]
        impl crate::Writable for Th0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH0 to value 0"]
        impl crate::Resettable for Th0Spec {}
    }
    #[doc = "TH1 (rw) register accessor: Base Counter 1 15-bit Unsigned Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@th1`] module"]
    #[doc(alias = "TH1")]
    pub type Th1 = crate::Reg<th1::Th1Spec>;
    #[doc = "Base Counter 1 15-bit Unsigned Threshold Value"]
    pub mod th1 {
        #[doc = "Register `TH1` reader"]
        pub type R = crate::R<Th1Spec>;
        #[doc = "Register `TH1` writer"]
        pub type W = crate::W<Th1Spec>;
        #[doc = "Field `TH1` reader - MCPWM Counter 1 TH"]
        pub type Th1R = crate::FieldReader<u16>;
        #[doc = "Field `TH1` writer - MCPWM Counter 1 TH"]
        pub type Th1W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            #[doc = "Bits 0:14 - MCPWM Counter 1 TH"]
            #[inline(always)]
            pub fn th1(&self) -> Th1R {
                Th1R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:14 - MCPWM Counter 1 TH"]
            #[inline(always)]
            pub fn th1(&mut self) -> Th1W<Th1Spec> {
                Th1W::new(self, 0)
            }
        }
        #[doc = "Base Counter 1 15-bit Unsigned Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`th1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`th1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Th1Spec;
        impl crate::RegisterSpec for Th1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`th1::R`](R) reader structure"]
        impl crate::Readable for Th1Spec {}
        #[doc = "`write(|w| ..)` method takes [`th1::W`](W) writer structure"]
        impl crate::Writable for Th1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TH1 to value 0"]
        impl crate::Resettable for Th1Spec {}
    }
    #[doc = "CNT0 (rw) register accessor: Base 0 Counter 16-bit Signed Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt0`] module"]
    #[doc(alias = "CNT0")]
    pub type Cnt0 = crate::Reg<cnt0::Cnt0Spec>;
    #[doc = "Base 0 Counter 16-bit Signed Threshold Value"]
    pub mod cnt0 {
        #[doc = "Register `CNT0` reader"]
        pub type R = crate::R<Cnt0Spec>;
        #[doc = "Register `CNT0` writer"]
        pub type W = crate::W<Cnt0Spec>;
        #[doc = "Field `CNT0` reader - MCPWM Counter 0 Value"]
        pub type Cnt0R = crate::FieldReader<u16>;
        #[doc = "Field `CNT0` writer - MCPWM Counter 0 Value"]
        pub type Cnt0W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - MCPWM Counter 0 Value"]
            #[inline(always)]
            pub fn cnt0(&self) -> Cnt0R {
                Cnt0R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - MCPWM Counter 0 Value"]
            #[inline(always)]
            pub fn cnt0(&mut self) -> Cnt0W<Cnt0Spec> {
                Cnt0W::new(self, 0)
            }
        }
        #[doc = "Base 0 Counter 16-bit Signed Threshold Value\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Cnt0Spec;
        impl crate::RegisterSpec for Cnt0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt0::R`](R) reader structure"]
        impl crate::Readable for Cnt0Spec {}
        #[doc = "`write(|w| ..)` method takes [`cnt0::W`](W) writer structure"]
        impl crate::Writable for Cnt0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CNT0 to value 0"]
        impl crate::Resettable for Cnt0Spec {}
    }
    #[doc = "CNT1 (rw) register accessor: Base 1 Counter 16-bit Signed Value\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt1`] module"]
    #[doc(alias = "CNT1")]
    pub type Cnt1 = crate::Reg<cnt1::Cnt1Spec>;
    #[doc = "Base 1 Counter 16-bit Signed Value"]
    pub mod cnt1 {
        #[doc = "Register `CNT1` reader"]
        pub type R = crate::R<Cnt1Spec>;
        #[doc = "Register `CNT1` writer"]
        pub type W = crate::W<Cnt1Spec>;
        #[doc = "Field `CNT1` reader - MCPWM Counter 1 Value"]
        pub type Cnt1R = crate::FieldReader<u16>;
        #[doc = "Field `CNT1` writer - MCPWM Counter 1 Value"]
        pub type Cnt1W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - MCPWM Counter 1 Value"]
            #[inline(always)]
            pub fn cnt1(&self) -> Cnt1R {
                Cnt1R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - MCPWM Counter 1 Value"]
            #[inline(always)]
            pub fn cnt1(&mut self) -> Cnt1W<Cnt1Spec> {
                Cnt1W::new(self, 0)
            }
        }
        #[doc = "Base 1 Counter 16-bit Signed Value\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Cnt1Spec;
        impl crate::RegisterSpec for Cnt1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt1::R`](R) reader structure"]
        impl crate::Readable for Cnt1Spec {}
        #[doc = "`write(|w| ..)` method takes [`cnt1::W`](W) writer structure"]
        impl crate::Writable for Cnt1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CNT1 to value 0"]
        impl crate::Resettable for Cnt1Spec {}
    }
    #[doc = "UPDATE (w) register accessor: Mask Registers Manual Reload Configuration\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`update::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@update`] module"]
    #[doc(alias = "UPDATE")]
    pub type Update = crate::Reg<update::UpdateSpec>;
    #[doc = "Mask Registers Manual Reload Configuration"]
    pub mod update {
        #[doc = "Register `UPDATE` writer"]
        pub type W = crate::W<UpdateSpec>;
        #[doc = "Field `TH00_UPDATE` writer - Write 1 to Trig TH00 Update Forcely"]
        pub type Th00UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH01_UPDATE` writer - Write 1 to Trig TH01 Update Forcely"]
        pub type Th01UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH10_UPDATE` writer - Write 1 to Trig TH10 Update Forcely"]
        pub type Th10UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH11_UPDATE` writer - Write 1 to Trig TH11 Update Forcely"]
        pub type Th11UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH20_UPDATE` writer - Write 1 to Trig TH20 Update Forcely"]
        pub type Th20UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH21_UPDATE` writer - Write 1 to Trig TH21 Update Forcely"]
        pub type Th21UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH30_UPDATE` writer - Write 1 to Trig TH30 Update Forcely"]
        pub type Th30UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH31_UPDATE` writer - Write 1 to Trig TH31 Update Forcely"]
        pub type Th31UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR0_UPDATE` writer - Write 1 to Trig TMR0 Update Forcely"]
        pub type Tmr0UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR1_UPDATE` writer - Write 1 to Trig TMR1 Update Forcely"]
        pub type Tmr1UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR2_UPDATE` writer - Write 1 to Trig TMR2 Update Forcely"]
        pub type Tmr2UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR3_UPDATE` writer - Write 1 to Trig TMR3 Update Forcely"]
        pub type Tmr3UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH0_UPDATE` writer - Write 1 to Trig TH0 Update Forcely"]
        pub type Th0UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH1_UPDATE` writer - Write 1 to Trig TH1 Update Forcely"]
        pub type Th1UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CNT0_UPDATE` writer - Write 1 to Trig CNT0 Update Forcely"]
        pub type Cnt0UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CNT1_UPDATE` writer - Write 1 to Trig CNT1 Update Forcely"]
        pub type Cnt1UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            #[doc = "Bit 0 - Write 1 to Trig TH00 Update Forcely"]
            #[inline(always)]
            pub fn th00_update(&mut self) -> Th00UpdateW<UpdateSpec> {
                Th00UpdateW::new(self, 0)
            }
            #[doc = "Bit 1 - Write 1 to Trig TH01 Update Forcely"]
            #[inline(always)]
            pub fn th01_update(&mut self) -> Th01UpdateW<UpdateSpec> {
                Th01UpdateW::new(self, 1)
            }
            #[doc = "Bit 2 - Write 1 to Trig TH10 Update Forcely"]
            #[inline(always)]
            pub fn th10_update(&mut self) -> Th10UpdateW<UpdateSpec> {
                Th10UpdateW::new(self, 2)
            }
            #[doc = "Bit 3 - Write 1 to Trig TH11 Update Forcely"]
            #[inline(always)]
            pub fn th11_update(&mut self) -> Th11UpdateW<UpdateSpec> {
                Th11UpdateW::new(self, 3)
            }
            #[doc = "Bit 4 - Write 1 to Trig TH20 Update Forcely"]
            #[inline(always)]
            pub fn th20_update(&mut self) -> Th20UpdateW<UpdateSpec> {
                Th20UpdateW::new(self, 4)
            }
            #[doc = "Bit 5 - Write 1 to Trig TH21 Update Forcely"]
            #[inline(always)]
            pub fn th21_update(&mut self) -> Th21UpdateW<UpdateSpec> {
                Th21UpdateW::new(self, 5)
            }
            #[doc = "Bit 6 - Write 1 to Trig TH30 Update Forcely"]
            #[inline(always)]
            pub fn th30_update(&mut self) -> Th30UpdateW<UpdateSpec> {
                Th30UpdateW::new(self, 6)
            }
            #[doc = "Bit 7 - Write 1 to Trig TH31 Update Forcely"]
            #[inline(always)]
            pub fn th31_update(&mut self) -> Th31UpdateW<UpdateSpec> {
                Th31UpdateW::new(self, 7)
            }
            #[doc = "Bit 8 - Write 1 to Trig TMR0 Update Forcely"]
            #[inline(always)]
            pub fn tmr0_update(&mut self) -> Tmr0UpdateW<UpdateSpec> {
                Tmr0UpdateW::new(self, 8)
            }
            #[doc = "Bit 9 - Write 1 to Trig TMR1 Update Forcely"]
            #[inline(always)]
            pub fn tmr1_update(&mut self) -> Tmr1UpdateW<UpdateSpec> {
                Tmr1UpdateW::new(self, 9)
            }
            #[doc = "Bit 10 - Write 1 to Trig TMR2 Update Forcely"]
            #[inline(always)]
            pub fn tmr2_update(&mut self) -> Tmr2UpdateW<UpdateSpec> {
                Tmr2UpdateW::new(self, 10)
            }
            #[doc = "Bit 11 - Write 1 to Trig TMR3 Update Forcely"]
            #[inline(always)]
            pub fn tmr3_update(&mut self) -> Tmr3UpdateW<UpdateSpec> {
                Tmr3UpdateW::new(self, 11)
            }
            #[doc = "Bit 12 - Write 1 to Trig TH0 Update Forcely"]
            #[inline(always)]
            pub fn th0_update(&mut self) -> Th0UpdateW<UpdateSpec> {
                Th0UpdateW::new(self, 12)
            }
            #[doc = "Bit 13 - Write 1 to Trig TH1 Update Forcely"]
            #[inline(always)]
            pub fn th1_update(&mut self) -> Th1UpdateW<UpdateSpec> {
                Th1UpdateW::new(self, 13)
            }
            #[doc = "Bit 14 - Write 1 to Trig CNT0 Update Forcely"]
            #[inline(always)]
            pub fn cnt0_update(&mut self) -> Cnt0UpdateW<UpdateSpec> {
                Cnt0UpdateW::new(self, 14)
            }
            #[doc = "Bit 15 - Write 1 to Trig CNT1 Update Forcely"]
            #[inline(always)]
            pub fn cnt1_update(&mut self) -> Cnt1UpdateW<UpdateSpec> {
                Cnt1UpdateW::new(self, 15)
            }
        }
        #[doc = "Mask Registers Manual Reload Configuration\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`update::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UpdateSpec;
        impl crate::RegisterSpec for UpdateSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`update::W`](W) writer structure"]
        impl crate::Writable for UpdateSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UPDATE to value 0"]
        impl crate::Resettable for UpdateSpec {}
    }
    #[doc = "FCNT (rw) register accessor: If MCPWM_FAIL012\\[15\\] = 1, when fail0/1 occure, store MCPWM_CNT0 to MCPWM_FCNT. If MCPWM_FAIL3\\[15\\] = 1, when fail2/3 occure, store MCPWM_CNT0 to MCPWM_FCNT.\n\nYou can [`read`](crate::Reg::read) this register and get [`fcnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcnt`] module"]
    #[doc(alias = "FCNT")]
    pub type Fcnt = crate::Reg<fcnt::FcntSpec>;
    #[doc = "If MCPWM_FAIL012\\[15\\] = 1, when fail0/1 occure, store MCPWM_CNT0 to MCPWM_FCNT. If MCPWM_FAIL3\\[15\\] = 1, when fail2/3 occure, store MCPWM_CNT0 to MCPWM_FCNT."]
    pub mod fcnt {
        #[doc = "Register `FCNT` reader"]
        pub type R = crate::R<FcntSpec>;
        #[doc = "Register `FCNT` writer"]
        pub type W = crate::W<FcntSpec>;
        #[doc = "Field `FCNT` reader - Counter Value when failure event happens"]
        pub type FcntR = crate::FieldReader<u16>;
        #[doc = "Field `FCNT` writer - Counter Value when failure event happens"]
        pub type FcntW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Counter Value when failure event happens"]
            #[inline(always)]
            pub fn fcnt(&self) -> FcntR {
                FcntR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Counter Value when failure event happens"]
            #[inline(always)]
            pub fn fcnt(&mut self) -> FcntW<FcntSpec> {
                FcntW::new(self, 0)
            }
        }
        #[doc = "If MCPWM_FAIL012\\[15\\] = 1, when fail0/1 occure, store MCPWM_CNT0 to MCPWM_FCNT. If MCPWM_FAIL3\\[15\\] = 1, when fail2/3 occure, store MCPWM_CNT0 to MCPWM_FCNT.\n\nYou can [`read`](crate::Reg::read) this register and get [`fcnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FcntSpec;
        impl crate::RegisterSpec for FcntSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fcnt::R`](R) reader structure"]
        impl crate::Readable for FcntSpec {}
        #[doc = "`write(|w| ..)` method takes [`fcnt::W`](W) writer structure"]
        impl crate::Writable for FcntSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FCNT to value 0"]
        impl crate::Resettable for FcntSpec {}
    }
    #[doc = "EVT0 (rw) register accessor: MCPWM Base 0 External Trigger Register\n\nYou can [`read`](crate::Reg::read) this register and get [`evt0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evt0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@evt0`] module"]
    #[doc(alias = "EVT0")]
    pub type Evt0 = crate::Reg<evt0::Evt0Spec>;
    #[doc = "MCPWM Base 0 External Trigger Register"]
    pub mod evt0 {
        #[doc = "Register `EVT0` reader"]
        pub type R = crate::R<Evt0Spec>;
        #[doc = "Register `EVT0` writer"]
        pub type W = crate::W<Evt0Spec>;
        #[doc = "Field `MCPWM0_TMR0` reader - MCPWM0 TMR0 base 0 Trigger"]
        pub type Mcpwm0Tmr0R = crate::BitReader;
        #[doc = "Field `MCPWM0_TMR0` writer - MCPWM0 TMR0 base 0 Trigger"]
        pub type Mcpwm0Tmr0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCPWM0_TMR1` reader - MCPWM0 TMR1 base 0 Trigger"]
        pub type Mcpwm0Tmr1R = crate::BitReader;
        #[doc = "Field `MCPWM0_TMR1` writer - MCPWM0 TMR1 base 0 Trigger"]
        pub type Mcpwm0Tmr1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCPWM0_TMR2` reader - MCPWM0 TMR2 base 0 Trigger"]
        pub type Mcpwm0Tmr2R = crate::BitReader;
        #[doc = "Field `MCPWM0_TMR2` writer - MCPWM0 TMR2 base 0 Trigger"]
        pub type Mcpwm0Tmr2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCPWM0_TMR3` reader - MCPWM0 TMR3 base 0 Trigger"]
        pub type Mcpwm0Tmr3R = crate::BitReader;
        #[doc = "Field `MCPWM0_TMR3` writer - MCPWM0 TMR3 base 0 Trigger"]
        pub type Mcpwm0Tmr3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER0_CMP0` reader - TIMER0 CMP0 base 0 Trigger"]
        pub type Timer0Cmp0R = crate::BitReader;
        #[doc = "Field `TIMER0_CMP0` writer - TIMER0 CMP0 base 0 Trigger"]
        pub type Timer0Cmp0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER0_CMP1` reader - TIMER0 CMP1 base 0 Trigger"]
        pub type Timer0Cmp1R = crate::BitReader;
        #[doc = "Field `TIMER0_CMP1` writer - TIMER0 CMP1 base 0 Trigger"]
        pub type Timer0Cmp1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER1_CMP0` reader - TIMER1 CMP0 base 0 Trigger"]
        pub type Timer1Cmp0R = crate::BitReader;
        #[doc = "Field `TIMER1_CMP0` writer - TIMER1 CMP0 base 0 Trigger"]
        pub type Timer1Cmp0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER1_CMP1` reader - TIMER1 CMP1 base 0 Trigger"]
        pub type Timer1Cmp1R = crate::BitReader;
        #[doc = "Field `TIMER1_CMP1` writer - TIMER1 CMP1 base 0 Trigger"]
        pub type Timer1Cmp1W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - MCPWM0 TMR0 base 0 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr0(&self) -> Mcpwm0Tmr0R {
                Mcpwm0Tmr0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - MCPWM0 TMR1 base 0 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr1(&self) -> Mcpwm0Tmr1R {
                Mcpwm0Tmr1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - MCPWM0 TMR2 base 0 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr2(&self) -> Mcpwm0Tmr2R {
                Mcpwm0Tmr2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - MCPWM0 TMR3 base 0 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr3(&self) -> Mcpwm0Tmr3R {
                Mcpwm0Tmr3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 8 - TIMER0 CMP0 base 0 Trigger"]
            #[inline(always)]
            pub fn timer0_cmp0(&self) -> Timer0Cmp0R {
                Timer0Cmp0R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - TIMER0 CMP1 base 0 Trigger"]
            #[inline(always)]
            pub fn timer0_cmp1(&self) -> Timer0Cmp1R {
                Timer0Cmp1R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - TIMER1 CMP0 base 0 Trigger"]
            #[inline(always)]
            pub fn timer1_cmp0(&self) -> Timer1Cmp0R {
                Timer1Cmp0R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - TIMER1 CMP1 base 0 Trigger"]
            #[inline(always)]
            pub fn timer1_cmp1(&self) -> Timer1Cmp1R {
                Timer1Cmp1R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - MCPWM0 TMR0 base 0 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr0(&mut self) -> Mcpwm0Tmr0W<Evt0Spec> {
                Mcpwm0Tmr0W::new(self, 0)
            }
            #[doc = "Bit 1 - MCPWM0 TMR1 base 0 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr1(&mut self) -> Mcpwm0Tmr1W<Evt0Spec> {
                Mcpwm0Tmr1W::new(self, 1)
            }
            #[doc = "Bit 2 - MCPWM0 TMR2 base 0 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr2(&mut self) -> Mcpwm0Tmr2W<Evt0Spec> {
                Mcpwm0Tmr2W::new(self, 2)
            }
            #[doc = "Bit 3 - MCPWM0 TMR3 base 0 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr3(&mut self) -> Mcpwm0Tmr3W<Evt0Spec> {
                Mcpwm0Tmr3W::new(self, 3)
            }
            #[doc = "Bit 8 - TIMER0 CMP0 base 0 Trigger"]
            #[inline(always)]
            pub fn timer0_cmp0(&mut self) -> Timer0Cmp0W<Evt0Spec> {
                Timer0Cmp0W::new(self, 8)
            }
            #[doc = "Bit 9 - TIMER0 CMP1 base 0 Trigger"]
            #[inline(always)]
            pub fn timer0_cmp1(&mut self) -> Timer0Cmp1W<Evt0Spec> {
                Timer0Cmp1W::new(self, 9)
            }
            #[doc = "Bit 10 - TIMER1 CMP0 base 0 Trigger"]
            #[inline(always)]
            pub fn timer1_cmp0(&mut self) -> Timer1Cmp0W<Evt0Spec> {
                Timer1Cmp0W::new(self, 10)
            }
            #[doc = "Bit 11 - TIMER1 CMP1 base 0 Trigger"]
            #[inline(always)]
            pub fn timer1_cmp1(&mut self) -> Timer1Cmp1W<Evt0Spec> {
                Timer1Cmp1W::new(self, 11)
            }
        }
        #[doc = "MCPWM Base 0 External Trigger Register\n\nYou can [`read`](crate::Reg::read) this register and get [`evt0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evt0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Evt0Spec;
        impl crate::RegisterSpec for Evt0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`evt0::R`](R) reader structure"]
        impl crate::Readable for Evt0Spec {}
        #[doc = "`write(|w| ..)` method takes [`evt0::W`](W) writer structure"]
        impl crate::Writable for Evt0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets EVT0 to value 0"]
        impl crate::Resettable for Evt0Spec {}
    }
    #[doc = "EVT1 (rw) register accessor: MCPWM Base 1 External Trigger Register\n\nYou can [`read`](crate::Reg::read) this register and get [`evt1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evt1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@evt1`] module"]
    #[doc(alias = "EVT1")]
    pub type Evt1 = crate::Reg<evt1::Evt1Spec>;
    #[doc = "MCPWM Base 1 External Trigger Register"]
    pub mod evt1 {
        #[doc = "Register `EVT1` reader"]
        pub type R = crate::R<Evt1Spec>;
        #[doc = "Register `EVT1` writer"]
        pub type W = crate::W<Evt1Spec>;
        #[doc = "Field `MCPWM0_TMR0` reader - MCPWM0 TMR0 base 1 Trigger"]
        pub type Mcpwm0Tmr0R = crate::BitReader;
        #[doc = "Field `MCPWM0_TMR0` writer - MCPWM0 TMR0 base 1 Trigger"]
        pub type Mcpwm0Tmr0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCPWM0_TMR1` reader - MCPWM0 TMR1 base 1 Trigger"]
        pub type Mcpwm0Tmr1R = crate::BitReader;
        #[doc = "Field `MCPWM0_TMR1` writer - MCPWM0 TMR1 base 1 Trigger"]
        pub type Mcpwm0Tmr1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCPWM0_TMR2` reader - MCPWM0 TMR2 base 1 Trigger"]
        pub type Mcpwm0Tmr2R = crate::BitReader;
        #[doc = "Field `MCPWM0_TMR2` writer - MCPWM0 TMR2 base 1 Trigger"]
        pub type Mcpwm0Tmr2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCPWM0_TMR3` reader - MCPWM0 TMR3 base 1 Trigger"]
        pub type Mcpwm0Tmr3R = crate::BitReader;
        #[doc = "Field `MCPWM0_TMR3` writer - MCPWM0 TMR3 base 1 Trigger"]
        pub type Mcpwm0Tmr3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER0_CMP0` reader - TIMER0 CMP0 base 1 Trigger"]
        pub type Timer0Cmp0R = crate::BitReader;
        #[doc = "Field `TIMER0_CMP0` writer - TIMER0 CMP0 base 1 Trigger"]
        pub type Timer0Cmp0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER0_CMP1` reader - TIMER0 CMP1 base 1 Trigger"]
        pub type Timer0Cmp1R = crate::BitReader;
        #[doc = "Field `TIMER0_CMP1` writer - TIMER0 CMP1 base 1 Trigger"]
        pub type Timer0Cmp1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER1_CMP0` reader - TIMER1 CMP0 base 1 Trigger"]
        pub type Timer1Cmp0R = crate::BitReader;
        #[doc = "Field `TIMER1_CMP0` writer - TIMER1 CMP0 base 1 Trigger"]
        pub type Timer1Cmp0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER1_CMP1` reader - TIMER1 CMP1 base 1 Trigger"]
        pub type Timer1Cmp1R = crate::BitReader;
        #[doc = "Field `TIMER1_CMP1` writer - TIMER1 CMP1 base 1 Trigger"]
        pub type Timer1Cmp1W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - MCPWM0 TMR0 base 1 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr0(&self) -> Mcpwm0Tmr0R {
                Mcpwm0Tmr0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - MCPWM0 TMR1 base 1 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr1(&self) -> Mcpwm0Tmr1R {
                Mcpwm0Tmr1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - MCPWM0 TMR2 base 1 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr2(&self) -> Mcpwm0Tmr2R {
                Mcpwm0Tmr2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - MCPWM0 TMR3 base 1 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr3(&self) -> Mcpwm0Tmr3R {
                Mcpwm0Tmr3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 8 - TIMER0 CMP0 base 1 Trigger"]
            #[inline(always)]
            pub fn timer0_cmp0(&self) -> Timer0Cmp0R {
                Timer0Cmp0R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - TIMER0 CMP1 base 1 Trigger"]
            #[inline(always)]
            pub fn timer0_cmp1(&self) -> Timer0Cmp1R {
                Timer0Cmp1R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - TIMER1 CMP0 base 1 Trigger"]
            #[inline(always)]
            pub fn timer1_cmp0(&self) -> Timer1Cmp0R {
                Timer1Cmp0R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - TIMER1 CMP1 base 1 Trigger"]
            #[inline(always)]
            pub fn timer1_cmp1(&self) -> Timer1Cmp1R {
                Timer1Cmp1R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - MCPWM0 TMR0 base 1 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr0(&mut self) -> Mcpwm0Tmr0W<Evt1Spec> {
                Mcpwm0Tmr0W::new(self, 0)
            }
            #[doc = "Bit 1 - MCPWM0 TMR1 base 1 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr1(&mut self) -> Mcpwm0Tmr1W<Evt1Spec> {
                Mcpwm0Tmr1W::new(self, 1)
            }
            #[doc = "Bit 2 - MCPWM0 TMR2 base 1 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr2(&mut self) -> Mcpwm0Tmr2W<Evt1Spec> {
                Mcpwm0Tmr2W::new(self, 2)
            }
            #[doc = "Bit 3 - MCPWM0 TMR3 base 1 Trigger"]
            #[inline(always)]
            pub fn mcpwm0_tmr3(&mut self) -> Mcpwm0Tmr3W<Evt1Spec> {
                Mcpwm0Tmr3W::new(self, 3)
            }
            #[doc = "Bit 8 - TIMER0 CMP0 base 1 Trigger"]
            #[inline(always)]
            pub fn timer0_cmp0(&mut self) -> Timer0Cmp0W<Evt1Spec> {
                Timer0Cmp0W::new(self, 8)
            }
            #[doc = "Bit 9 - TIMER0 CMP1 base 1 Trigger"]
            #[inline(always)]
            pub fn timer0_cmp1(&mut self) -> Timer0Cmp1W<Evt1Spec> {
                Timer0Cmp1W::new(self, 9)
            }
            #[doc = "Bit 10 - TIMER1 CMP0 base 1 Trigger"]
            #[inline(always)]
            pub fn timer1_cmp0(&mut self) -> Timer1Cmp0W<Evt1Spec> {
                Timer1Cmp0W::new(self, 10)
            }
            #[doc = "Bit 11 - TIMER1 CMP1 base 1 Trigger"]
            #[inline(always)]
            pub fn timer1_cmp1(&mut self) -> Timer1Cmp1W<Evt1Spec> {
                Timer1Cmp1W::new(self, 11)
            }
        }
        #[doc = "MCPWM Base 1 External Trigger Register\n\nYou can [`read`](crate::Reg::read) this register and get [`evt1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evt1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Evt1Spec;
        impl crate::RegisterSpec for Evt1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`evt1::R`](R) reader structure"]
        impl crate::Readable for Evt1Spec {}
        #[doc = "`write(|w| ..)` method takes [`evt1::W`](W) writer structure"]
        impl crate::Writable for Evt1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets EVT1 to value 0"]
        impl crate::Resettable for Evt1Spec {}
    }
    #[doc = "DTH0 (rw) register accessor: Channelx N Dead Zone Control Register, 10-bit Unsigned\n\nYou can [`read`](crate::Reg::read) this register and get [`dth0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dth0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dth0`] module"]
    #[doc(alias = "DTH0")]
    pub type Dth0 = crate::Reg<dth0::Dth0Spec>;
    #[doc = "Channelx N Dead Zone Control Register, 10-bit Unsigned"]
    pub mod dth0 {
        #[doc = "Register `DTH0` reader"]
        pub type R = crate::R<Dth0Spec>;
        #[doc = "Register `DTH0` writer"]
        pub type W = crate::W<Dth0Spec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Channelx N Dead Zone Control Register, 10-bit Unsigned\n\nYou can [`read`](crate::Reg::read) this register and get [`dth0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dth0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dth0Spec;
        impl crate::RegisterSpec for Dth0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dth0::R`](R) reader structure"]
        impl crate::Readable for Dth0Spec {}
        #[doc = "`write(|w| ..)` method takes [`dth0::W`](W) writer structure"]
        impl crate::Writable for Dth0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DTH0 to value 0"]
        impl crate::Resettable for Dth0Spec {}
    }
    #[doc = "DTH1 (rw) register accessor: Channelx P Dead Zone Control Register, 10-bit Unsigned\n\nYou can [`read`](crate::Reg::read) this register and get [`dth1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dth1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dth1`] module"]
    #[doc(alias = "DTH1")]
    pub type Dth1 = crate::Reg<dth1::Dth1Spec>;
    #[doc = "Channelx P Dead Zone Control Register, 10-bit Unsigned"]
    pub mod dth1 {
        #[doc = "Register `DTH1` reader"]
        pub type R = crate::R<Dth1Spec>;
        #[doc = "Register `DTH1` writer"]
        pub type W = crate::W<Dth1Spec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Channelx P Dead Zone Control Register, 10-bit Unsigned\n\nYou can [`read`](crate::Reg::read) this register and get [`dth1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dth1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dth1Spec;
        impl crate::RegisterSpec for Dth1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dth1::R`](R) reader structure"]
        impl crate::Readable for Dth1Spec {}
        #[doc = "`write(|w| ..)` method takes [`dth1::W`](W) writer structure"]
        impl crate::Writable for Dth1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DTH1 to value 0"]
        impl crate::Resettable for Dth1Spec {}
    }
    #[doc = "FLT (rw) register accessor: FAIL signal filter config\n\nYou can [`read`](crate::Reg::read) this register and get [`flt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@flt`] module"]
    #[doc(alias = "FLT")]
    pub type Flt = crate::Reg<flt::FltSpec>;
    #[doc = "FAIL signal filter config"]
    pub mod flt {
        #[doc = "Register `FLT` reader"]
        pub type R = crate::R<FltSpec>;
        #[doc = "Register `FLT` writer"]
        pub type W = crate::W<FltSpec>;
        #[doc = "Field `IO_FLT_CLKDIV` reader - Clock Source is System Clock, Divide Range is 1 to 256"]
        pub type IoFltClkdivR = crate::FieldReader;
        #[doc = "Field `IO_FLT_CLKDIV` writer - Clock Source is System Clock, Divide Range is 1 to 256"]
        pub type IoFltClkdivW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `CMP_FLT_CLKDIV` reader - Clock Source is System Clock, Divide Range is 1 to 256"]
        pub type CmpFltClkdivR = crate::FieldReader;
        #[doc = "Field `CMP_FLT_CLKDIV` writer - Clock Source is System Clock, Divide Range is 1 to 256"]
        pub type CmpFltClkdivW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Clock Source is System Clock, Divide Range is 1 to 256"]
            #[inline(always)]
            pub fn io_flt_clkdiv(&self) -> IoFltClkdivR {
                IoFltClkdivR::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - Clock Source is System Clock, Divide Range is 1 to 256"]
            #[inline(always)]
            pub fn cmp_flt_clkdiv(&self) -> CmpFltClkdivR {
                CmpFltClkdivR::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Clock Source is System Clock, Divide Range is 1 to 256"]
            #[inline(always)]
            pub fn io_flt_clkdiv(&mut self) -> IoFltClkdivW<FltSpec> {
                IoFltClkdivW::new(self, 0)
            }
            #[doc = "Bits 8:15 - Clock Source is System Clock, Divide Range is 1 to 256"]
            #[inline(always)]
            pub fn cmp_flt_clkdiv(&mut self) -> CmpFltClkdivW<FltSpec> {
                CmpFltClkdivW::new(self, 8)
            }
        }
        #[doc = "FAIL signal filter config\n\nYou can [`read`](crate::Reg::read) this register and get [`flt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FltSpec;
        impl crate::RegisterSpec for FltSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`flt::R`](R) reader structure"]
        impl crate::Readable for FltSpec {}
        #[doc = "`write(|w| ..)` method takes [`flt::W`](W) writer structure"]
        impl crate::Writable for FltSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FLT to value 0"]
        impl crate::Resettable for FltSpec {}
    }
    #[doc = "SDCFG (rw) register accessor: Shadow Registers Reload Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`sdcfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sdcfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sdcfg`] module"]
    #[doc(alias = "SDCFG")]
    pub type Sdcfg = crate::Reg<sdcfg::SdcfgSpec>;
    #[doc = "Shadow Registers Reload Configuration"]
    pub mod sdcfg {
        #[doc = "Register `SDCFG` reader"]
        pub type R = crate::R<SdcfgSpec>;
        #[doc = "Register `SDCFG` writer"]
        pub type W = crate::W<SdcfgSpec>;
        #[doc = "Field `TR0_UP_INTV` reader - Counter0 based Shadow Register Auto Update Interval"]
        pub type Tr0UpIntvR = crate::FieldReader;
        #[doc = "Field `TR0_UP_INTV` writer - Counter0 based Shadow Register Auto Update Interval"]
        pub type Tr0UpIntvW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `TR0_T0_UPDATE` reader - Update counter0 based shadow registers @ T0 event"]
        pub type Tr0T0UpdateR = crate::BitReader;
        #[doc = "Field `TR0_T0_UPDATE` writer - Update counter0 based shadow registers @ T0 event"]
        pub type Tr0T0UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TR0_T1_UPDATE` reader - Update counter0 based shadow registers @ T1 event"]
        pub type Tr0T1UpdateR = crate::BitReader;
        #[doc = "Field `TR0_T1_UPDATE` writer - Update counter0 based shadow registers @ T1 event"]
        pub type Tr0T1UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TR0_AEC` reader - Set MCPWM_FAIL012.MOE upon update events or not"]
        pub type Tr0AecR = crate::BitReader;
        #[doc = "Field `TR0_AEC` writer - Set MCPWM_FAIL012.MOE upon update events or not"]
        pub type Tr0AecW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TR1_UP_INTV` reader - Counter1 based Shadow Register Auto Update Interval"]
        pub type Tr1UpIntvR = crate::FieldReader;
        #[doc = "Field `TR1_UP_INTV` writer - Counter1 based Shadow Register Auto Update Interval"]
        pub type Tr1UpIntvW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `TR1_T0_UPDATE` reader - Update counter1 based shadow registers @ T0 event"]
        pub type Tr1T0UpdateR = crate::BitReader;
        #[doc = "Field `TR1_T0_UPDATE` writer - Update counter1 based shadow registers @ T0 event"]
        pub type Tr1T0UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TR1_T1_UPDATE` reader - Update counter1 based shadow registers @ T1 event"]
        pub type Tr1T1UpdateR = crate::BitReader;
        #[doc = "Field `TR1_T1_UPDATE` writer - Update counter1 based shadow registers @ T1 event"]
        pub type Tr1T1UpdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TR1_AEC` reader - Set MCPWM_FAIL3.MOE upon update events or not"]
        pub type Tr1AecR = crate::BitReader;
        #[doc = "Field `TR1_AEC` writer - Set MCPWM_FAIL3.MOE upon update events or not"]
        pub type Tr1AecW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:3 - Counter0 based Shadow Register Auto Update Interval"]
            #[inline(always)]
            pub fn tr0_up_intv(&self) -> Tr0UpIntvR {
                Tr0UpIntvR::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bit 4 - Update counter0 based shadow registers @ T0 event"]
            #[inline(always)]
            pub fn tr0_t0_update(&self) -> Tr0T0UpdateR {
                Tr0T0UpdateR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Update counter0 based shadow registers @ T1 event"]
            #[inline(always)]
            pub fn tr0_t1_update(&self) -> Tr0T1UpdateR {
                Tr0T1UpdateR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Set MCPWM_FAIL012.MOE upon update events or not"]
            #[inline(always)]
            pub fn tr0_aec(&self) -> Tr0AecR {
                Tr0AecR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bits 8:11 - Counter1 based Shadow Register Auto Update Interval"]
            #[inline(always)]
            pub fn tr1_up_intv(&self) -> Tr1UpIntvR {
                Tr1UpIntvR::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 12 - Update counter1 based shadow registers @ T0 event"]
            #[inline(always)]
            pub fn tr1_t0_update(&self) -> Tr1T0UpdateR {
                Tr1T0UpdateR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Update counter1 based shadow registers @ T1 event"]
            #[inline(always)]
            pub fn tr1_t1_update(&self) -> Tr1T1UpdateR {
                Tr1T1UpdateR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Set MCPWM_FAIL3.MOE upon update events or not"]
            #[inline(always)]
            pub fn tr1_aec(&self) -> Tr1AecR {
                Tr1AecR::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Counter0 based Shadow Register Auto Update Interval"]
            #[inline(always)]
            pub fn tr0_up_intv(&mut self) -> Tr0UpIntvW<SdcfgSpec> {
                Tr0UpIntvW::new(self, 0)
            }
            #[doc = "Bit 4 - Update counter0 based shadow registers @ T0 event"]
            #[inline(always)]
            pub fn tr0_t0_update(&mut self) -> Tr0T0UpdateW<SdcfgSpec> {
                Tr0T0UpdateW::new(self, 4)
            }
            #[doc = "Bit 5 - Update counter0 based shadow registers @ T1 event"]
            #[inline(always)]
            pub fn tr0_t1_update(&mut self) -> Tr0T1UpdateW<SdcfgSpec> {
                Tr0T1UpdateW::new(self, 5)
            }
            #[doc = "Bit 6 - Set MCPWM_FAIL012.MOE upon update events or not"]
            #[inline(always)]
            pub fn tr0_aec(&mut self) -> Tr0AecW<SdcfgSpec> {
                Tr0AecW::new(self, 6)
            }
            #[doc = "Bits 8:11 - Counter1 based Shadow Register Auto Update Interval"]
            #[inline(always)]
            pub fn tr1_up_intv(&mut self) -> Tr1UpIntvW<SdcfgSpec> {
                Tr1UpIntvW::new(self, 8)
            }
            #[doc = "Bit 12 - Update counter1 based shadow registers @ T0 event"]
            #[inline(always)]
            pub fn tr1_t0_update(&mut self) -> Tr1T0UpdateW<SdcfgSpec> {
                Tr1T0UpdateW::new(self, 12)
            }
            #[doc = "Bit 13 - Update counter1 based shadow registers @ T1 event"]
            #[inline(always)]
            pub fn tr1_t1_update(&mut self) -> Tr1T1UpdateW<SdcfgSpec> {
                Tr1T1UpdateW::new(self, 13)
            }
            #[doc = "Bit 14 - Set MCPWM_FAIL3.MOE upon update events or not"]
            #[inline(always)]
            pub fn tr1_aec(&mut self) -> Tr1AecW<SdcfgSpec> {
                Tr1AecW::new(self, 14)
            }
        }
        #[doc = "Shadow Registers Reload Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`sdcfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sdcfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SdcfgSpec;
        impl crate::RegisterSpec for SdcfgSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sdcfg::R`](R) reader structure"]
        impl crate::Readable for SdcfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`sdcfg::W`](W) writer structure"]
        impl crate::Writable for SdcfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SDCFG to value 0"]
        impl crate::Resettable for SdcfgSpec {}
    }
    #[doc = "AUEN (rw) register accessor: Auto update enable\n\nYou can [`read`](crate::Reg::read) this register and get [`auen::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`auen::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@auen`] module"]
    #[doc(alias = "AUEN")]
    pub type Auen = crate::Reg<auen::AuenSpec>;
    #[doc = "Auto update enable"]
    pub mod auen {
        #[doc = "Register `AUEN` reader"]
        pub type R = crate::R<AuenSpec>;
        #[doc = "Register `AUEN` writer"]
        pub type W = crate::W<AuenSpec>;
        #[doc = "Field `TH00_AUPDATE` reader - MCPWM_TH00 auto update enable"]
        pub type Th00AupdateR = crate::BitReader;
        #[doc = "Field `TH00_AUPDATE` writer - MCPWM_TH00 auto update enable"]
        pub type Th00AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH01_AUPDATE` reader - MCPWM_TH01 auto update enable"]
        pub type Th01AupdateR = crate::BitReader;
        #[doc = "Field `TH01_AUPDATE` writer - MCPWM_TH01 auto update enable"]
        pub type Th01AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH10_AUPDATE` reader - MCPWM_TH10 auto update enable"]
        pub type Th10AupdateR = crate::BitReader;
        #[doc = "Field `TH10_AUPDATE` writer - MCPWM_TH10 auto update enable"]
        pub type Th10AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH11_AUPDATE` reader - MCPWM_TH11 auto update enable"]
        pub type Th11AupdateR = crate::BitReader;
        #[doc = "Field `TH11_AUPDATE` writer - MCPWM_TH11 auto update enable"]
        pub type Th11AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH20_AUPDATE` reader - MCPWM_TH20 auto update enable"]
        pub type Th20AupdateR = crate::BitReader;
        #[doc = "Field `TH20_AUPDATE` writer - MCPWM_TH20 auto update enable"]
        pub type Th20AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH21_AUPDATE` reader - MCPWM_TH21 auto update enable"]
        pub type Th21AupdateR = crate::BitReader;
        #[doc = "Field `TH21_AUPDATE` writer - MCPWM_TH21 auto update enable"]
        pub type Th21AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH30_AUPDATE` reader - MCPWM_TH30 auto update enable"]
        pub type Th30AupdateR = crate::BitReader;
        #[doc = "Field `TH30_AUPDATE` writer - MCPWM_TH30 auto update enable"]
        pub type Th30AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH31_AUPDATE` reader - MCPWM_TH31 auto update enable"]
        pub type Th31AupdateR = crate::BitReader;
        #[doc = "Field `TH31_AUPDATE` writer - MCPWM_TH31 auto update enable"]
        pub type Th31AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR0_AUPDATE` reader - MCPWM_TMR0 auto update enable"]
        pub type Tmr0AupdateR = crate::BitReader;
        #[doc = "Field `TMR0_AUPDATE` writer - MCPWM_TMR0 auto update enable"]
        pub type Tmr0AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR1_AUPDATE` reader - MCPWM_TMR1 auto update enable"]
        pub type Tmr1AupdateR = crate::BitReader;
        #[doc = "Field `TMR1_AUPDATE` writer - MCPWM_TMR1 auto update enable"]
        pub type Tmr1AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR2_AUPDATE` reader - MCPWM_TMR2 auto update enable"]
        pub type Tmr2AupdateR = crate::BitReader;
        #[doc = "Field `TMR2_AUPDATE` writer - MCPWM_TMR2 auto update enable"]
        pub type Tmr2AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR3_AUPDATE` reader - MCPWM_TMR3 auto update enable"]
        pub type Tmr3AupdateR = crate::BitReader;
        #[doc = "Field `TMR3_AUPDATE` writer - MCPWM_TMR3 auto update enable"]
        pub type Tmr3AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH0_AUPDATE` reader - MCPWM_TH0 auto update enable"]
        pub type Th0AupdateR = crate::BitReader;
        #[doc = "Field `TH0_AUPDATE` writer - MCPWM_TH0 auto update enable"]
        pub type Th0AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH1_AUPDATE` reader - MCPWM_TH1 auto update enable"]
        pub type Th1AupdateR = crate::BitReader;
        #[doc = "Field `TH1_AUPDATE` writer - MCPWM_TH1 auto update enable"]
        pub type Th1AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CNT0_AUPDATE` reader - MCPWM_CNT0 auto update enable"]
        pub type Cnt0AupdateR = crate::BitReader;
        #[doc = "Field `CNT0_AUPDATE` writer - MCPWM_CNT0 auto update enable"]
        pub type Cnt0AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CNT1_AUPDATE` reader - MCPWM_CNT1 auto update enable"]
        pub type Cnt1AupdateR = crate::BitReader;
        #[doc = "Field `CNT1_AUPDATE` writer - MCPWM_CNT1 auto update enable"]
        pub type Cnt1AupdateW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - MCPWM_TH00 auto update enable"]
            #[inline(always)]
            pub fn th00_aupdate(&self) -> Th00AupdateR {
                Th00AupdateR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - MCPWM_TH01 auto update enable"]
            #[inline(always)]
            pub fn th01_aupdate(&self) -> Th01AupdateR {
                Th01AupdateR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - MCPWM_TH10 auto update enable"]
            #[inline(always)]
            pub fn th10_aupdate(&self) -> Th10AupdateR {
                Th10AupdateR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - MCPWM_TH11 auto update enable"]
            #[inline(always)]
            pub fn th11_aupdate(&self) -> Th11AupdateR {
                Th11AupdateR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - MCPWM_TH20 auto update enable"]
            #[inline(always)]
            pub fn th20_aupdate(&self) -> Th20AupdateR {
                Th20AupdateR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - MCPWM_TH21 auto update enable"]
            #[inline(always)]
            pub fn th21_aupdate(&self) -> Th21AupdateR {
                Th21AupdateR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - MCPWM_TH30 auto update enable"]
            #[inline(always)]
            pub fn th30_aupdate(&self) -> Th30AupdateR {
                Th30AupdateR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - MCPWM_TH31 auto update enable"]
            #[inline(always)]
            pub fn th31_aupdate(&self) -> Th31AupdateR {
                Th31AupdateR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - MCPWM_TMR0 auto update enable"]
            #[inline(always)]
            pub fn tmr0_aupdate(&self) -> Tmr0AupdateR {
                Tmr0AupdateR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - MCPWM_TMR1 auto update enable"]
            #[inline(always)]
            pub fn tmr1_aupdate(&self) -> Tmr1AupdateR {
                Tmr1AupdateR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - MCPWM_TMR2 auto update enable"]
            #[inline(always)]
            pub fn tmr2_aupdate(&self) -> Tmr2AupdateR {
                Tmr2AupdateR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - MCPWM_TMR3 auto update enable"]
            #[inline(always)]
            pub fn tmr3_aupdate(&self) -> Tmr3AupdateR {
                Tmr3AupdateR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - MCPWM_TH0 auto update enable"]
            #[inline(always)]
            pub fn th0_aupdate(&self) -> Th0AupdateR {
                Th0AupdateR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - MCPWM_TH1 auto update enable"]
            #[inline(always)]
            pub fn th1_aupdate(&self) -> Th1AupdateR {
                Th1AupdateR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - MCPWM_CNT0 auto update enable"]
            #[inline(always)]
            pub fn cnt0_aupdate(&self) -> Cnt0AupdateR {
                Cnt0AupdateR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - MCPWM_CNT1 auto update enable"]
            #[inline(always)]
            pub fn cnt1_aupdate(&self) -> Cnt1AupdateR {
                Cnt1AupdateR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - MCPWM_TH00 auto update enable"]
            #[inline(always)]
            pub fn th00_aupdate(&mut self) -> Th00AupdateW<AuenSpec> {
                Th00AupdateW::new(self, 0)
            }
            #[doc = "Bit 1 - MCPWM_TH01 auto update enable"]
            #[inline(always)]
            pub fn th01_aupdate(&mut self) -> Th01AupdateW<AuenSpec> {
                Th01AupdateW::new(self, 1)
            }
            #[doc = "Bit 2 - MCPWM_TH10 auto update enable"]
            #[inline(always)]
            pub fn th10_aupdate(&mut self) -> Th10AupdateW<AuenSpec> {
                Th10AupdateW::new(self, 2)
            }
            #[doc = "Bit 3 - MCPWM_TH11 auto update enable"]
            #[inline(always)]
            pub fn th11_aupdate(&mut self) -> Th11AupdateW<AuenSpec> {
                Th11AupdateW::new(self, 3)
            }
            #[doc = "Bit 4 - MCPWM_TH20 auto update enable"]
            #[inline(always)]
            pub fn th20_aupdate(&mut self) -> Th20AupdateW<AuenSpec> {
                Th20AupdateW::new(self, 4)
            }
            #[doc = "Bit 5 - MCPWM_TH21 auto update enable"]
            #[inline(always)]
            pub fn th21_aupdate(&mut self) -> Th21AupdateW<AuenSpec> {
                Th21AupdateW::new(self, 5)
            }
            #[doc = "Bit 6 - MCPWM_TH30 auto update enable"]
            #[inline(always)]
            pub fn th30_aupdate(&mut self) -> Th30AupdateW<AuenSpec> {
                Th30AupdateW::new(self, 6)
            }
            #[doc = "Bit 7 - MCPWM_TH31 auto update enable"]
            #[inline(always)]
            pub fn th31_aupdate(&mut self) -> Th31AupdateW<AuenSpec> {
                Th31AupdateW::new(self, 7)
            }
            #[doc = "Bit 8 - MCPWM_TMR0 auto update enable"]
            #[inline(always)]
            pub fn tmr0_aupdate(&mut self) -> Tmr0AupdateW<AuenSpec> {
                Tmr0AupdateW::new(self, 8)
            }
            #[doc = "Bit 9 - MCPWM_TMR1 auto update enable"]
            #[inline(always)]
            pub fn tmr1_aupdate(&mut self) -> Tmr1AupdateW<AuenSpec> {
                Tmr1AupdateW::new(self, 9)
            }
            #[doc = "Bit 10 - MCPWM_TMR2 auto update enable"]
            #[inline(always)]
            pub fn tmr2_aupdate(&mut self) -> Tmr2AupdateW<AuenSpec> {
                Tmr2AupdateW::new(self, 10)
            }
            #[doc = "Bit 11 - MCPWM_TMR3 auto update enable"]
            #[inline(always)]
            pub fn tmr3_aupdate(&mut self) -> Tmr3AupdateW<AuenSpec> {
                Tmr3AupdateW::new(self, 11)
            }
            #[doc = "Bit 12 - MCPWM_TH0 auto update enable"]
            #[inline(always)]
            pub fn th0_aupdate(&mut self) -> Th0AupdateW<AuenSpec> {
                Th0AupdateW::new(self, 12)
            }
            #[doc = "Bit 13 - MCPWM_TH1 auto update enable"]
            #[inline(always)]
            pub fn th1_aupdate(&mut self) -> Th1AupdateW<AuenSpec> {
                Th1AupdateW::new(self, 13)
            }
            #[doc = "Bit 14 - MCPWM_CNT0 auto update enable"]
            #[inline(always)]
            pub fn cnt0_aupdate(&mut self) -> Cnt0AupdateW<AuenSpec> {
                Cnt0AupdateW::new(self, 14)
            }
            #[doc = "Bit 15 - MCPWM_CNT1 auto update enable"]
            #[inline(always)]
            pub fn cnt1_aupdate(&mut self) -> Cnt1AupdateW<AuenSpec> {
                Cnt1AupdateW::new(self, 15)
            }
        }
        #[doc = "Auto update enable\n\nYou can [`read`](crate::Reg::read) this register and get [`auen::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`auen::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AuenSpec;
        impl crate::RegisterSpec for AuenSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`auen::R`](R) reader structure"]
        impl crate::Readable for AuenSpec {}
        #[doc = "`write(|w| ..)` method takes [`auen::W`](W) writer structure"]
        impl crate::Writable for AuenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AUEN to value 0"]
        impl crate::Resettable for AuenSpec {}
    }
    #[doc = "TCLK (rw) register accessor: MCPWM Clock Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tclk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tclk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tclk`] module"]
    #[doc(alias = "TCLK")]
    pub type Tclk = crate::Reg<tclk::TclkSpec>;
    #[doc = "MCPWM Clock Configuration Register"]
    pub mod tclk {
        #[doc = "Register `TCLK` reader"]
        pub type R = crate::R<TclkSpec>;
        #[doc = "Register `TCLK` writer"]
        pub type W = crate::W<TclkSpec>;
        #[doc = "Module Clock Divider Setting, Clock Source is System Clock\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ClkDiv {
            #[doc = "0: Main clock is not divided"]
            Div1 = 0,
            #[doc = "1: Main clock is divided by 2"]
            Div2 = 1,
            #[doc = "2: Main clock is divided by 4"]
            Div4 = 2,
            #[doc = "3: Main clock is divided by 8"]
            Div8 = 3,
        }
        impl From<ClkDiv> for u8 {
            #[inline(always)]
            fn from(variant: ClkDiv) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ClkDiv {
            type Ux = u8;
        }
        impl crate::IsEnum for ClkDiv {}
        #[doc = "Field `CLK_DIV` reader - Module Clock Divider Setting, Clock Source is System Clock"]
        pub type ClkDivR = crate::FieldReader<ClkDiv>;
        impl ClkDivR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ClkDiv {
                match self.bits {
                    0 => ClkDiv::Div1,
                    1 => ClkDiv::Div2,
                    2 => ClkDiv::Div4,
                    3 => ClkDiv::Div8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Main clock is not divided"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == ClkDiv::Div1
            }
            #[doc = "Main clock is divided by 2"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ClkDiv::Div2
            }
            #[doc = "Main clock is divided by 4"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ClkDiv::Div4
            }
            #[doc = "Main clock is divided by 8"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ClkDiv::Div8
            }
        }
        #[doc = "Field `CLK_DIV` writer - Module Clock Divider Setting, Clock Source is System Clock"]
        pub type ClkDivW<'a, REG> = crate::FieldWriter<'a, REG, 2, ClkDiv, crate::Safe>;
        impl<'a, REG> ClkDivW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Main clock is not divided"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div1)
            }
            #[doc = "Main clock is divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div2)
            }
            #[doc = "Main clock is divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div4)
            }
            #[doc = "Main clock is divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut crate::W<REG> {
                self.variant(ClkDiv::Div8)
            }
        }
        #[doc = "Field `CLK_EN` reader - Module Clock Enable or Not"]
        pub type ClkEnR = crate::BitReader;
        #[doc = "Field `CLK_EN` writer - Module Clock Enable or Not"]
        pub type ClkEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "TMR2 base counter select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tmr2Tb {
            #[doc = "0: Base Counter0"]
            Cnt0 = 0,
            #[doc = "1: Base Counter1"]
            Cnt1 = 1,
        }
        impl From<Tmr2Tb> for bool {
            #[inline(always)]
            fn from(variant: Tmr2Tb) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TMR2_TB` reader - TMR2 base counter select"]
        pub type Tmr2TbR = crate::BitReader<Tmr2Tb>;
        impl Tmr2TbR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tmr2Tb {
                match self.bits {
                    false => Tmr2Tb::Cnt0,
                    true => Tmr2Tb::Cnt1,
                }
            }
            #[doc = "Base Counter0"]
            #[inline(always)]
            pub fn is_cnt0(&self) -> bool {
                *self == Tmr2Tb::Cnt0
            }
            #[doc = "Base Counter1"]
            #[inline(always)]
            pub fn is_cnt1(&self) -> bool {
                *self == Tmr2Tb::Cnt1
            }
        }
        #[doc = "Field `TMR2_TB` writer - TMR2 base counter select"]
        pub type Tmr2TbW<'a, REG> = crate::BitWriter<'a, REG, Tmr2Tb>;
        impl<'a, REG> Tmr2TbW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Base Counter0"]
            #[inline(always)]
            pub fn cnt0(self) -> &'a mut crate::W<REG> {
                self.variant(Tmr2Tb::Cnt0)
            }
            #[doc = "Base Counter1"]
            #[inline(always)]
            pub fn cnt1(self) -> &'a mut crate::W<REG> {
                self.variant(Tmr2Tb::Cnt1)
            }
        }
        #[doc = "TMR3 base counter select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tmr3Tb {
            #[doc = "0: Base Counter0"]
            Cnt0 = 0,
            #[doc = "1: Base Counter1"]
            Cnt1 = 1,
        }
        impl From<Tmr3Tb> for bool {
            #[inline(always)]
            fn from(variant: Tmr3Tb) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TMR3_TB` reader - TMR3 base counter select"]
        pub type Tmr3TbR = crate::BitReader<Tmr3Tb>;
        impl Tmr3TbR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tmr3Tb {
                match self.bits {
                    false => Tmr3Tb::Cnt0,
                    true => Tmr3Tb::Cnt1,
                }
            }
            #[doc = "Base Counter0"]
            #[inline(always)]
            pub fn is_cnt0(&self) -> bool {
                *self == Tmr3Tb::Cnt0
            }
            #[doc = "Base Counter1"]
            #[inline(always)]
            pub fn is_cnt1(&self) -> bool {
                *self == Tmr3Tb::Cnt1
            }
        }
        #[doc = "Field `TMR3_TB` writer - TMR3 base counter select"]
        pub type Tmr3TbW<'a, REG> = crate::BitWriter<'a, REG, Tmr3Tb>;
        impl<'a, REG> Tmr3TbW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Base Counter0"]
            #[inline(always)]
            pub fn cnt0(self) -> &'a mut crate::W<REG> {
                self.variant(Tmr3Tb::Cnt0)
            }
            #[doc = "Base Counter1"]
            #[inline(always)]
            pub fn cnt1(self) -> &'a mut crate::W<REG> {
                self.variant(Tmr3Tb::Cnt1)
            }
        }
        #[doc = "Field `BASE0_CNT_EN` reader - Base Counter0 Enable"]
        pub type Base0CntEnR = crate::BitReader;
        #[doc = "Field `BASE0_CNT_EN` writer - Base Counter0 Enable"]
        pub type Base0CntEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BASE1_CNT_EN` reader - Base Counter1 Enable"]
        pub type Base1CntEnR = crate::BitReader;
        #[doc = "Field `BASE1_CNT_EN` writer - Base Counter1 Enable"]
        pub type Base1CntEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EVT_CNT0_EN` reader - Base Counter0 external trigger enable"]
        pub type EvtCnt0EnR = crate::BitReader;
        #[doc = "Field `EVT_CNT0_EN` writer - Base Counter0 external trigger enable"]
        pub type EvtCnt0EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EVT_CNT1_EN` reader - Base Counter1 external trigger enable"]
        pub type EvtCnt1EnR = crate::BitReader;
        #[doc = "Field `EVT_CNT1_EN` writer - Base Counter1 external trigger enable"]
        pub type EvtCnt1EnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - Module Clock Divider Setting, Clock Source is System Clock"]
            #[inline(always)]
            pub fn clk_div(&self) -> ClkDivR {
                ClkDivR::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - Module Clock Enable or Not"]
            #[inline(always)]
            pub fn clk_en(&self) -> ClkEnR {
                ClkEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - TMR2 base counter select"]
            #[inline(always)]
            pub fn tmr2_tb(&self) -> Tmr2TbR {
                Tmr2TbR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TMR3 base counter select"]
            #[inline(always)]
            pub fn tmr3_tb(&self) -> Tmr3TbR {
                Tmr3TbR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Base Counter0 Enable"]
            #[inline(always)]
            pub fn base0_cnt_en(&self) -> Base0CntEnR {
                Base0CntEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Base Counter1 Enable"]
            #[inline(always)]
            pub fn base1_cnt_en(&self) -> Base1CntEnR {
                Base1CntEnR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Base Counter0 external trigger enable"]
            #[inline(always)]
            pub fn evt_cnt0_en(&self) -> EvtCnt0EnR {
                EvtCnt0EnR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Base Counter1 external trigger enable"]
            #[inline(always)]
            pub fn evt_cnt1_en(&self) -> EvtCnt1EnR {
                EvtCnt1EnR::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Module Clock Divider Setting, Clock Source is System Clock"]
            #[inline(always)]
            pub fn clk_div(&mut self) -> ClkDivW<TclkSpec> {
                ClkDivW::new(self, 0)
            }
            #[doc = "Bit 2 - Module Clock Enable or Not"]
            #[inline(always)]
            pub fn clk_en(&mut self) -> ClkEnW<TclkSpec> {
                ClkEnW::new(self, 2)
            }
            #[doc = "Bit 4 - TMR2 base counter select"]
            #[inline(always)]
            pub fn tmr2_tb(&mut self) -> Tmr2TbW<TclkSpec> {
                Tmr2TbW::new(self, 4)
            }
            #[doc = "Bit 5 - TMR3 base counter select"]
            #[inline(always)]
            pub fn tmr3_tb(&mut self) -> Tmr3TbW<TclkSpec> {
                Tmr3TbW::new(self, 5)
            }
            #[doc = "Bit 6 - Base Counter0 Enable"]
            #[inline(always)]
            pub fn base0_cnt_en(&mut self) -> Base0CntEnW<TclkSpec> {
                Base0CntEnW::new(self, 6)
            }
            #[doc = "Bit 7 - Base Counter1 Enable"]
            #[inline(always)]
            pub fn base1_cnt_en(&mut self) -> Base1CntEnW<TclkSpec> {
                Base1CntEnW::new(self, 7)
            }
            #[doc = "Bit 8 - Base Counter0 external trigger enable"]
            #[inline(always)]
            pub fn evt_cnt0_en(&mut self) -> EvtCnt0EnW<TclkSpec> {
                EvtCnt0EnW::new(self, 8)
            }
            #[doc = "Bit 9 - Base Counter1 external trigger enable"]
            #[inline(always)]
            pub fn evt_cnt1_en(&mut self) -> EvtCnt1EnW<TclkSpec> {
                EvtCnt1EnW::new(self, 9)
            }
        }
        #[doc = "MCPWM Clock Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tclk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tclk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TclkSpec;
        impl crate::RegisterSpec for TclkSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tclk::R`](R) reader structure"]
        impl crate::Readable for TclkSpec {}
        #[doc = "`write(|w| ..)` method takes [`tclk::W`](W) writer structure"]
        impl crate::Writable for TclkSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TCLK to value 0"]
        impl crate::Resettable for TclkSpec {}
    }
    #[doc = "IE0 (rw) register accessor: Counter0 based Interrupt Sources Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie0`] module"]
    #[doc(alias = "IE0")]
    pub type Ie0 = crate::Reg<ie0::Ie0Spec>;
    #[doc = "Counter0 based Interrupt Sources Enable"]
    pub mod ie0 {
        #[doc = "Register `IE0` reader"]
        pub type R = crate::R<Ie0Spec>;
        #[doc = "Register `IE0` writer"]
        pub type W = crate::W<Ie0Spec>;
        #[doc = "Field `T0_IE` reader - Counter0 Return to -TH Interrupt Enable"]
        pub type T0IeR = crate::BitReader;
        #[doc = "Field `T0_IE` writer - Counter0 Return to -TH Interrupt Enable"]
        pub type T0IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `T1_IE` reader - Counter0 is equal to 0 Interrupt Enable"]
        pub type T1IeR = crate::BitReader;
        #[doc = "Field `T1_IE` writer - Counter0 is equal to 0 Interrupt Enable"]
        pub type T1IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH00_IE` reader - Counter0 is equal to TH00 Interrupt Enable"]
        pub type Th00IeR = crate::BitReader;
        #[doc = "Field `TH00_IE` writer - Counter0 is equal to TH00 Interrupt Enable"]
        pub type Th00IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH01_IE` reader - Counter0 is equal to TH01 Interrupt Enable"]
        pub type Th01IeR = crate::BitReader;
        #[doc = "Field `TH01_IE` writer - Counter0 is equal to TH01 Interrupt Enable"]
        pub type Th01IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH10_IE` reader - Counter0 is equal to TH10 Interrupt Enable"]
        pub type Th10IeR = crate::BitReader;
        #[doc = "Field `TH10_IE` writer - Counter0 is equal to TH10 Interrupt Enable"]
        pub type Th10IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH11_IE` reader - Counter0 is equal to TH11 Interrupt Enable"]
        pub type Th11IeR = crate::BitReader;
        #[doc = "Field `TH11_IE` writer - Counter0 is equal to TH11 Interrupt Enable"]
        pub type Th11IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH20_IE` reader - Counter0 is equal to TH20 Interrupt Enable"]
        pub type Th20IeR = crate::BitReader;
        #[doc = "Field `TH20_IE` writer - Counter0 is equal to TH20 Interrupt Enable"]
        pub type Th20IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH21_IE` reader - Counter0 is equal to TH21 Interrupt Enable"]
        pub type Th21IeR = crate::BitReader;
        #[doc = "Field `TH21_IE` writer - Counter0 is equal to TH21 Interrupt Enable"]
        pub type Th21IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR0_IE` reader - Counter0 is equal to TMR0 Interrupt Enable"]
        pub type Tmr0IeR = crate::BitReader;
        #[doc = "Field `TMR0_IE` writer - Counter0 is equal to TMR0 Interrupt Enable"]
        pub type Tmr0IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR1_IE` reader - Counter0 is equal to TMR1 Interrupt Enable"]
        pub type Tmr1IeR = crate::BitReader;
        #[doc = "Field `TMR1_IE` writer - Counter0 is equal to TMR1 Interrupt Enable"]
        pub type Tmr1IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR2_IE` reader - Counter0 is equal to TMR2 Interrupt Enable"]
        pub type Tmr2IeR = crate::BitReader;
        #[doc = "Field `TMR2_IE` writer - Counter0 is equal to TMR2 Interrupt Enable"]
        pub type Tmr2IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR3_IE` reader - Counter0 is equal to TMR3 Interrupt Enable"]
        pub type Tmr3IeR = crate::BitReader;
        #[doc = "Field `TMR3_IE` writer - Counter0 is equal to TMR3 Interrupt Enable"]
        pub type Tmr3IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UP_IE` reader - Shade Register Update Interrupt Enable"]
        pub type UpIeR = crate::BitReader;
        #[doc = "Field `UP_IE` writer - Shade Register Update Interrupt Enable"]
        pub type UpIeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Counter0 Return to -TH Interrupt Enable"]
            #[inline(always)]
            pub fn t0_ie(&self) -> T0IeR {
                T0IeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Counter0 is equal to 0 Interrupt Enable"]
            #[inline(always)]
            pub fn t1_ie(&self) -> T1IeR {
                T1IeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Counter0 is equal to TH00 Interrupt Enable"]
            #[inline(always)]
            pub fn th00_ie(&self) -> Th00IeR {
                Th00IeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Counter0 is equal to TH01 Interrupt Enable"]
            #[inline(always)]
            pub fn th01_ie(&self) -> Th01IeR {
                Th01IeR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Counter0 is equal to TH10 Interrupt Enable"]
            #[inline(always)]
            pub fn th10_ie(&self) -> Th10IeR {
                Th10IeR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Counter0 is equal to TH11 Interrupt Enable"]
            #[inline(always)]
            pub fn th11_ie(&self) -> Th11IeR {
                Th11IeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Counter0 is equal to TH20 Interrupt Enable"]
            #[inline(always)]
            pub fn th20_ie(&self) -> Th20IeR {
                Th20IeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Counter0 is equal to TH21 Interrupt Enable"]
            #[inline(always)]
            pub fn th21_ie(&self) -> Th21IeR {
                Th21IeR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 10 - Counter0 is equal to TMR0 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr0_ie(&self) -> Tmr0IeR {
                Tmr0IeR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Counter0 is equal to TMR1 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr1_ie(&self) -> Tmr1IeR {
                Tmr1IeR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Counter0 is equal to TMR2 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr2_ie(&self) -> Tmr2IeR {
                Tmr2IeR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Counter0 is equal to TMR3 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr3_ie(&self) -> Tmr3IeR {
                Tmr3IeR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Shade Register Update Interrupt Enable"]
            #[inline(always)]
            pub fn up_ie(&self) -> UpIeR {
                UpIeR::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Counter0 Return to -TH Interrupt Enable"]
            #[inline(always)]
            pub fn t0_ie(&mut self) -> T0IeW<Ie0Spec> {
                T0IeW::new(self, 0)
            }
            #[doc = "Bit 1 - Counter0 is equal to 0 Interrupt Enable"]
            #[inline(always)]
            pub fn t1_ie(&mut self) -> T1IeW<Ie0Spec> {
                T1IeW::new(self, 1)
            }
            #[doc = "Bit 2 - Counter0 is equal to TH00 Interrupt Enable"]
            #[inline(always)]
            pub fn th00_ie(&mut self) -> Th00IeW<Ie0Spec> {
                Th00IeW::new(self, 2)
            }
            #[doc = "Bit 3 - Counter0 is equal to TH01 Interrupt Enable"]
            #[inline(always)]
            pub fn th01_ie(&mut self) -> Th01IeW<Ie0Spec> {
                Th01IeW::new(self, 3)
            }
            #[doc = "Bit 4 - Counter0 is equal to TH10 Interrupt Enable"]
            #[inline(always)]
            pub fn th10_ie(&mut self) -> Th10IeW<Ie0Spec> {
                Th10IeW::new(self, 4)
            }
            #[doc = "Bit 5 - Counter0 is equal to TH11 Interrupt Enable"]
            #[inline(always)]
            pub fn th11_ie(&mut self) -> Th11IeW<Ie0Spec> {
                Th11IeW::new(self, 5)
            }
            #[doc = "Bit 6 - Counter0 is equal to TH20 Interrupt Enable"]
            #[inline(always)]
            pub fn th20_ie(&mut self) -> Th20IeW<Ie0Spec> {
                Th20IeW::new(self, 6)
            }
            #[doc = "Bit 7 - Counter0 is equal to TH21 Interrupt Enable"]
            #[inline(always)]
            pub fn th21_ie(&mut self) -> Th21IeW<Ie0Spec> {
                Th21IeW::new(self, 7)
            }
            #[doc = "Bit 10 - Counter0 is equal to TMR0 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr0_ie(&mut self) -> Tmr0IeW<Ie0Spec> {
                Tmr0IeW::new(self, 10)
            }
            #[doc = "Bit 11 - Counter0 is equal to TMR1 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr1_ie(&mut self) -> Tmr1IeW<Ie0Spec> {
                Tmr1IeW::new(self, 11)
            }
            #[doc = "Bit 12 - Counter0 is equal to TMR2 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr2_ie(&mut self) -> Tmr2IeW<Ie0Spec> {
                Tmr2IeW::new(self, 12)
            }
            #[doc = "Bit 13 - Counter0 is equal to TMR3 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr3_ie(&mut self) -> Tmr3IeW<Ie0Spec> {
                Tmr3IeW::new(self, 13)
            }
            #[doc = "Bit 14 - Shade Register Update Interrupt Enable"]
            #[inline(always)]
            pub fn up_ie(&mut self) -> UpIeW<Ie0Spec> {
                UpIeW::new(self, 14)
            }
        }
        #[doc = "Counter0 based Interrupt Sources Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ie0Spec;
        impl crate::RegisterSpec for Ie0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ie0::R`](R) reader structure"]
        impl crate::Readable for Ie0Spec {}
        #[doc = "`write(|w| ..)` method takes [`ie0::W`](W) writer structure"]
        impl crate::Writable for Ie0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE0 to value 0"]
        impl crate::Resettable for Ie0Spec {}
    }
    #[doc = "IF0 (rw) register accessor: Counter0 based Interrupt Flags\n\nYou can [`read`](crate::Reg::read) this register and get [`if0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@if0`] module"]
    #[doc(alias = "IF0")]
    pub type If0 = crate::Reg<if0::If0Spec>;
    #[doc = "Counter0 based Interrupt Flags"]
    pub mod if0 {
        #[doc = "Register `IF0` reader"]
        pub type R = crate::R<If0Spec>;
        #[doc = "Register `IF0` writer"]
        pub type W = crate::W<If0Spec>;
        #[doc = "Field `T0_IF` reader - T0 Interrupt Flag,Counter0 Return to -TH"]
        pub type T0IfR = crate::BitReader;
        #[doc = "Field `T0_IF` writer - T0 Interrupt Flag,Counter0 Return to -TH"]
        pub type T0IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `T1_IF` reader - T1 Interrupt Flag,Counter0 Return to -TH"]
        pub type T1IfR = crate::BitReader;
        #[doc = "Field `T1_IF` writer - T1 Interrupt Flag,Counter0 Return to -TH"]
        pub type T1IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH00_IF` reader - TH00 Interrupt Flag,Counter0 is equal to TH00"]
        pub type Th00IfR = crate::BitReader;
        #[doc = "Field `TH00_IF` writer - TH00 Interrupt Flag,Counter0 is equal to TH00"]
        pub type Th00IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH01_IF` reader - TH01 Interrupt Flag,Counter0 is equal to TH01"]
        pub type Th01IfR = crate::BitReader;
        #[doc = "Field `TH01_IF` writer - TH01 Interrupt Flag,Counter0 is equal to TH01"]
        pub type Th01IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH10_IF` reader - TH10 Interrupt Flag,Counter0 is equal to TH10"]
        pub type Th10IfR = crate::BitReader;
        #[doc = "Field `TH10_IF` writer - TH10 Interrupt Flag,Counter0 is equal to TH10"]
        pub type Th10IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH11_IF` reader - TH11 Interrupt Flag,Counter0 is equal to TH11"]
        pub type Th11IfR = crate::BitReader;
        #[doc = "Field `TH11_IF` writer - TH11 Interrupt Flag,Counter0 is equal to TH11"]
        pub type Th11IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH20_IF` reader - TH20 Interrupt Flag,Counter0 is equal to TH20"]
        pub type Th20IfR = crate::BitReader;
        #[doc = "Field `TH20_IF` writer - TH20 Interrupt Flag,Counter0 is equal to TH20"]
        pub type Th20IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH21_IF` reader - TH21 Interrupt Flag,Counter0 is equal to TH21"]
        pub type Th21IfR = crate::BitReader;
        #[doc = "Field `TH21_IF` writer - TH21 Interrupt Flag,Counter0 is equal to TH21"]
        pub type Th21IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR0_IF` reader - TMR0 Interrupt Flag,Counter0 is equal to TMR0"]
        pub type Tmr0IfR = crate::BitReader;
        #[doc = "Field `TMR0_IF` writer - TMR0 Interrupt Flag,Counter0 is equal to TMR0"]
        pub type Tmr0IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR1_IF` reader - TMR1 Interrupt Flag,Counter0 is equal to TMR1"]
        pub type Tmr1IfR = crate::BitReader;
        #[doc = "Field `TMR1_IF` writer - TMR1 Interrupt Flag,Counter0 is equal to TMR1"]
        pub type Tmr1IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR2_IF` reader - TMR2 Interrupt Flag,Counter0 is equal to TMR2"]
        pub type Tmr2IfR = crate::BitReader;
        #[doc = "Field `TMR2_IF` writer - TMR2 Interrupt Flag,Counter0 is equal to TMR2"]
        pub type Tmr2IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR3_IF` reader - TMR3 Interrupt Flag,Counter0 is equal to TMR3"]
        pub type Tmr3IfR = crate::BitReader;
        #[doc = "Field `TMR3_IF` writer - TMR3 Interrupt Flag,Counter0 is equal to TMR3"]
        pub type Tmr3IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UP_IF` reader - Shade Register Update Interrupt Flag"]
        pub type UpIfR = crate::BitReader;
        #[doc = "Field `UP_IF` writer - Shade Register Update Interrupt Flag"]
        pub type UpIfW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - T0 Interrupt Flag,Counter0 Return to -TH"]
            #[inline(always)]
            pub fn t0_if(&self) -> T0IfR {
                T0IfR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - T1 Interrupt Flag,Counter0 Return to -TH"]
            #[inline(always)]
            pub fn t1_if(&self) -> T1IfR {
                T1IfR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - TH00 Interrupt Flag,Counter0 is equal to TH00"]
            #[inline(always)]
            pub fn th00_if(&self) -> Th00IfR {
                Th00IfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - TH01 Interrupt Flag,Counter0 is equal to TH01"]
            #[inline(always)]
            pub fn th01_if(&self) -> Th01IfR {
                Th01IfR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - TH10 Interrupt Flag,Counter0 is equal to TH10"]
            #[inline(always)]
            pub fn th10_if(&self) -> Th10IfR {
                Th10IfR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TH11 Interrupt Flag,Counter0 is equal to TH11"]
            #[inline(always)]
            pub fn th11_if(&self) -> Th11IfR {
                Th11IfR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - TH20 Interrupt Flag,Counter0 is equal to TH20"]
            #[inline(always)]
            pub fn th20_if(&self) -> Th20IfR {
                Th20IfR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - TH21 Interrupt Flag,Counter0 is equal to TH21"]
            #[inline(always)]
            pub fn th21_if(&self) -> Th21IfR {
                Th21IfR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 10 - TMR0 Interrupt Flag,Counter0 is equal to TMR0"]
            #[inline(always)]
            pub fn tmr0_if(&self) -> Tmr0IfR {
                Tmr0IfR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - TMR1 Interrupt Flag,Counter0 is equal to TMR1"]
            #[inline(always)]
            pub fn tmr1_if(&self) -> Tmr1IfR {
                Tmr1IfR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - TMR2 Interrupt Flag,Counter0 is equal to TMR2"]
            #[inline(always)]
            pub fn tmr2_if(&self) -> Tmr2IfR {
                Tmr2IfR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - TMR3 Interrupt Flag,Counter0 is equal to TMR3"]
            #[inline(always)]
            pub fn tmr3_if(&self) -> Tmr3IfR {
                Tmr3IfR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Shade Register Update Interrupt Flag"]
            #[inline(always)]
            pub fn up_if(&self) -> UpIfR {
                UpIfR::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - T0 Interrupt Flag,Counter0 Return to -TH"]
            #[inline(always)]
            pub fn t0_if(&mut self) -> T0IfW<If0Spec> {
                T0IfW::new(self, 0)
            }
            #[doc = "Bit 1 - T1 Interrupt Flag,Counter0 Return to -TH"]
            #[inline(always)]
            pub fn t1_if(&mut self) -> T1IfW<If0Spec> {
                T1IfW::new(self, 1)
            }
            #[doc = "Bit 2 - TH00 Interrupt Flag,Counter0 is equal to TH00"]
            #[inline(always)]
            pub fn th00_if(&mut self) -> Th00IfW<If0Spec> {
                Th00IfW::new(self, 2)
            }
            #[doc = "Bit 3 - TH01 Interrupt Flag,Counter0 is equal to TH01"]
            #[inline(always)]
            pub fn th01_if(&mut self) -> Th01IfW<If0Spec> {
                Th01IfW::new(self, 3)
            }
            #[doc = "Bit 4 - TH10 Interrupt Flag,Counter0 is equal to TH10"]
            #[inline(always)]
            pub fn th10_if(&mut self) -> Th10IfW<If0Spec> {
                Th10IfW::new(self, 4)
            }
            #[doc = "Bit 5 - TH11 Interrupt Flag,Counter0 is equal to TH11"]
            #[inline(always)]
            pub fn th11_if(&mut self) -> Th11IfW<If0Spec> {
                Th11IfW::new(self, 5)
            }
            #[doc = "Bit 6 - TH20 Interrupt Flag,Counter0 is equal to TH20"]
            #[inline(always)]
            pub fn th20_if(&mut self) -> Th20IfW<If0Spec> {
                Th20IfW::new(self, 6)
            }
            #[doc = "Bit 7 - TH21 Interrupt Flag,Counter0 is equal to TH21"]
            #[inline(always)]
            pub fn th21_if(&mut self) -> Th21IfW<If0Spec> {
                Th21IfW::new(self, 7)
            }
            #[doc = "Bit 10 - TMR0 Interrupt Flag,Counter0 is equal to TMR0"]
            #[inline(always)]
            pub fn tmr0_if(&mut self) -> Tmr0IfW<If0Spec> {
                Tmr0IfW::new(self, 10)
            }
            #[doc = "Bit 11 - TMR1 Interrupt Flag,Counter0 is equal to TMR1"]
            #[inline(always)]
            pub fn tmr1_if(&mut self) -> Tmr1IfW<If0Spec> {
                Tmr1IfW::new(self, 11)
            }
            #[doc = "Bit 12 - TMR2 Interrupt Flag,Counter0 is equal to TMR2"]
            #[inline(always)]
            pub fn tmr2_if(&mut self) -> Tmr2IfW<If0Spec> {
                Tmr2IfW::new(self, 12)
            }
            #[doc = "Bit 13 - TMR3 Interrupt Flag,Counter0 is equal to TMR3"]
            #[inline(always)]
            pub fn tmr3_if(&mut self) -> Tmr3IfW<If0Spec> {
                Tmr3IfW::new(self, 13)
            }
            #[doc = "Bit 14 - Shade Register Update Interrupt Flag"]
            #[inline(always)]
            pub fn up_if(&mut self) -> UpIfW<If0Spec> {
                UpIfW::new(self, 14)
            }
        }
        #[doc = "Counter0 based Interrupt Flags\n\nYou can [`read`](crate::Reg::read) this register and get [`if0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct If0Spec;
        impl crate::RegisterSpec for If0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`if0::R`](R) reader structure"]
        impl crate::Readable for If0Spec {}
        #[doc = "`write(|w| ..)` method takes [`if0::W`](W) writer structure"]
        impl crate::Writable for If0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IF0 to value 0"]
        impl crate::Resettable for If0Spec {}
    }
    #[doc = "IE1 (rw) register accessor: Counter1 based Interrupt Sources Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie1`] module"]
    #[doc(alias = "IE1")]
    pub type Ie1 = crate::Reg<ie1::Ie1Spec>;
    #[doc = "Counter1 based Interrupt Sources Enable"]
    pub mod ie1 {
        #[doc = "Register `IE1` reader"]
        pub type R = crate::R<Ie1Spec>;
        #[doc = "Register `IE1` writer"]
        pub type W = crate::W<Ie1Spec>;
        #[doc = "Field `T0_IE` reader - Counter1 Return to -TH Interrupt Enable"]
        pub type T0IeR = crate::BitReader;
        #[doc = "Field `T0_IE` writer - Counter1 Return to -TH Interrupt Enable"]
        pub type T0IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `T1_IE` reader - Counter1 is equal to 0 Interrupt Enable"]
        pub type T1IeR = crate::BitReader;
        #[doc = "Field `T1_IE` writer - Counter1 is equal to 0 Interrupt Enable"]
        pub type T1IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH30_IE` reader - Counter1 is equal to TH30 Interrupt Enable"]
        pub type Th30IeR = crate::BitReader;
        #[doc = "Field `TH30_IE` writer - Counter1 is equal to TH30 Interrupt Enable"]
        pub type Th30IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH31_IE` reader - Counter1 is equal to TH31 Interrupt Enable"]
        pub type Th31IeR = crate::BitReader;
        #[doc = "Field `TH31_IE` writer - Counter1 is equal to TH31 Interrupt Enable"]
        pub type Th31IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR2_IE` reader - Counter1 is equal to TMR2 Interrupt Enable"]
        pub type Tmr2IeR = crate::BitReader;
        #[doc = "Field `TMR2_IE` writer - Counter1 is equal to TMR2 Interrupt Enable"]
        pub type Tmr2IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR3_IE` reader - Counter1 is equal to TMR3 Interrupt Enable"]
        pub type Tmr3IeR = crate::BitReader;
        #[doc = "Field `TMR3_IE` writer - Counter1 is equal to TMR3 Interrupt Enable"]
        pub type Tmr3IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UP_IE` reader - Shade Register Update Interrupt Enable"]
        pub type UpIeR = crate::BitReader;
        #[doc = "Field `UP_IE` writer - Shade Register Update Interrupt Enable"]
        pub type UpIeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Counter1 Return to -TH Interrupt Enable"]
            #[inline(always)]
            pub fn t0_ie(&self) -> T0IeR {
                T0IeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Counter1 is equal to 0 Interrupt Enable"]
            #[inline(always)]
            pub fn t1_ie(&self) -> T1IeR {
                T1IeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 8 - Counter1 is equal to TH30 Interrupt Enable"]
            #[inline(always)]
            pub fn th30_ie(&self) -> Th30IeR {
                Th30IeR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Counter1 is equal to TH31 Interrupt Enable"]
            #[inline(always)]
            pub fn th31_ie(&self) -> Th31IeR {
                Th31IeR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 12 - Counter1 is equal to TMR2 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr2_ie(&self) -> Tmr2IeR {
                Tmr2IeR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Counter1 is equal to TMR3 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr3_ie(&self) -> Tmr3IeR {
                Tmr3IeR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Shade Register Update Interrupt Enable"]
            #[inline(always)]
            pub fn up_ie(&self) -> UpIeR {
                UpIeR::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Counter1 Return to -TH Interrupt Enable"]
            #[inline(always)]
            pub fn t0_ie(&mut self) -> T0IeW<Ie1Spec> {
                T0IeW::new(self, 0)
            }
            #[doc = "Bit 1 - Counter1 is equal to 0 Interrupt Enable"]
            #[inline(always)]
            pub fn t1_ie(&mut self) -> T1IeW<Ie1Spec> {
                T1IeW::new(self, 1)
            }
            #[doc = "Bit 8 - Counter1 is equal to TH30 Interrupt Enable"]
            #[inline(always)]
            pub fn th30_ie(&mut self) -> Th30IeW<Ie1Spec> {
                Th30IeW::new(self, 8)
            }
            #[doc = "Bit 9 - Counter1 is equal to TH31 Interrupt Enable"]
            #[inline(always)]
            pub fn th31_ie(&mut self) -> Th31IeW<Ie1Spec> {
                Th31IeW::new(self, 9)
            }
            #[doc = "Bit 12 - Counter1 is equal to TMR2 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr2_ie(&mut self) -> Tmr2IeW<Ie1Spec> {
                Tmr2IeW::new(self, 12)
            }
            #[doc = "Bit 13 - Counter1 is equal to TMR3 Interrupt Enable"]
            #[inline(always)]
            pub fn tmr3_ie(&mut self) -> Tmr3IeW<Ie1Spec> {
                Tmr3IeW::new(self, 13)
            }
            #[doc = "Bit 14 - Shade Register Update Interrupt Enable"]
            #[inline(always)]
            pub fn up_ie(&mut self) -> UpIeW<Ie1Spec> {
                UpIeW::new(self, 14)
            }
        }
        #[doc = "Counter1 based Interrupt Sources Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ie1Spec;
        impl crate::RegisterSpec for Ie1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ie1::R`](R) reader structure"]
        impl crate::Readable for Ie1Spec {}
        #[doc = "`write(|w| ..)` method takes [`ie1::W`](W) writer structure"]
        impl crate::Writable for Ie1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE1 to value 0"]
        impl crate::Resettable for Ie1Spec {}
    }
    #[doc = "IF1 (rw) register accessor: Counter1 based Interrupt Flags\n\nYou can [`read`](crate::Reg::read) this register and get [`if1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@if1`] module"]
    #[doc(alias = "IF1")]
    pub type If1 = crate::Reg<if1::If1Spec>;
    #[doc = "Counter1 based Interrupt Flags"]
    pub mod if1 {
        #[doc = "Register `IF1` reader"]
        pub type R = crate::R<If1Spec>;
        #[doc = "Register `IF1` writer"]
        pub type W = crate::W<If1Spec>;
        #[doc = "Field `T0_IF` reader - T0 Interrupt Flag,Counter1 Return to -TH"]
        pub type T0IfR = crate::BitReader;
        #[doc = "Field `T0_IF` writer - T0 Interrupt Flag,Counter1 Return to -TH"]
        pub type T0IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `T1_IF` reader - T1 Interrupt Flag,Counter1 Return to -TH"]
        pub type T1IfR = crate::BitReader;
        #[doc = "Field `T1_IF` writer - T1 Interrupt Flag,Counter1 Return to -TH"]
        pub type T1IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH30_IF` reader - TH30 Interrupt Flag,Counter1 is equal to TH30"]
        pub type Th30IfR = crate::BitReader;
        #[doc = "Field `TH30_IF` writer - TH30 Interrupt Flag,Counter1 is equal to TH30"]
        pub type Th30IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TH31_IF` reader - TH31 Interrupt Flag,Counter1 is equal to TH31"]
        pub type Th31IfR = crate::BitReader;
        #[doc = "Field `TH31_IF` writer - TH31 Interrupt Flag,Counter1 is equal to TH31"]
        pub type Th31IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR2_IF` reader - TMR2 Interrupt Flag,Counter1 is equal to TMR2"]
        pub type Tmr2IfR = crate::BitReader;
        #[doc = "Field `TMR2_IF` writer - TMR2 Interrupt Flag,Counter1 is equal to TMR2"]
        pub type Tmr2IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR3_IF` reader - TMR3 Interrupt Flag,Counter1 is equal to TMR3"]
        pub type Tmr3IfR = crate::BitReader;
        #[doc = "Field `TMR3_IF` writer - TMR3 Interrupt Flag,Counter1 is equal to TMR3"]
        pub type Tmr3IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UP_IF` reader - Shade Register Update Interrupt Flag"]
        pub type UpIfR = crate::BitReader;
        #[doc = "Field `UP_IF` writer - Shade Register Update Interrupt Flag"]
        pub type UpIfW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - T0 Interrupt Flag,Counter1 Return to -TH"]
            #[inline(always)]
            pub fn t0_if(&self) -> T0IfR {
                T0IfR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - T1 Interrupt Flag,Counter1 Return to -TH"]
            #[inline(always)]
            pub fn t1_if(&self) -> T1IfR {
                T1IfR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 8 - TH30 Interrupt Flag,Counter1 is equal to TH30"]
            #[inline(always)]
            pub fn th30_if(&self) -> Th30IfR {
                Th30IfR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - TH31 Interrupt Flag,Counter1 is equal to TH31"]
            #[inline(always)]
            pub fn th31_if(&self) -> Th31IfR {
                Th31IfR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 12 - TMR2 Interrupt Flag,Counter1 is equal to TMR2"]
            #[inline(always)]
            pub fn tmr2_if(&self) -> Tmr2IfR {
                Tmr2IfR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - TMR3 Interrupt Flag,Counter1 is equal to TMR3"]
            #[inline(always)]
            pub fn tmr3_if(&self) -> Tmr3IfR {
                Tmr3IfR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Shade Register Update Interrupt Flag"]
            #[inline(always)]
            pub fn up_if(&self) -> UpIfR {
                UpIfR::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - T0 Interrupt Flag,Counter1 Return to -TH"]
            #[inline(always)]
            pub fn t0_if(&mut self) -> T0IfW<If1Spec> {
                T0IfW::new(self, 0)
            }
            #[doc = "Bit 1 - T1 Interrupt Flag,Counter1 Return to -TH"]
            #[inline(always)]
            pub fn t1_if(&mut self) -> T1IfW<If1Spec> {
                T1IfW::new(self, 1)
            }
            #[doc = "Bit 8 - TH30 Interrupt Flag,Counter1 is equal to TH30"]
            #[inline(always)]
            pub fn th30_if(&mut self) -> Th30IfW<If1Spec> {
                Th30IfW::new(self, 8)
            }
            #[doc = "Bit 9 - TH31 Interrupt Flag,Counter1 is equal to TH31"]
            #[inline(always)]
            pub fn th31_if(&mut self) -> Th31IfW<If1Spec> {
                Th31IfW::new(self, 9)
            }
            #[doc = "Bit 12 - TMR2 Interrupt Flag,Counter1 is equal to TMR2"]
            #[inline(always)]
            pub fn tmr2_if(&mut self) -> Tmr2IfW<If1Spec> {
                Tmr2IfW::new(self, 12)
            }
            #[doc = "Bit 13 - TMR3 Interrupt Flag,Counter1 is equal to TMR3"]
            #[inline(always)]
            pub fn tmr3_if(&mut self) -> Tmr3IfW<If1Spec> {
                Tmr3IfW::new(self, 13)
            }
            #[doc = "Bit 14 - Shade Register Update Interrupt Flag"]
            #[inline(always)]
            pub fn up_if(&mut self) -> UpIfW<If1Spec> {
                UpIfW::new(self, 14)
            }
        }
        #[doc = "Counter1 based Interrupt Flags\n\nYou can [`read`](crate::Reg::read) this register and get [`if1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct If1Spec;
        impl crate::RegisterSpec for If1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`if1::R`](R) reader structure"]
        impl crate::Readable for If1Spec {}
        #[doc = "`write(|w| ..)` method takes [`if1::W`](W) writer structure"]
        impl crate::Writable for If1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IF1 to value 0"]
        impl crate::Resettable for If1Spec {}
    }
    #[doc = "EIE (rw) register accessor: Error Interrupt Sources Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`eie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eie`] module"]
    #[doc(alias = "EIE")]
    pub type Eie = crate::Reg<eie::EieSpec>;
    #[doc = "Error Interrupt Sources Enable"]
    pub mod eie {
        #[doc = "Register `EIE` reader"]
        pub type R = crate::R<EieSpec>;
        #[doc = "Register `EIE` writer"]
        pub type W = crate::W<EieSpec>;
        #[doc = "Field `FAIL0_IE` reader - FAIL0 Interrupt"]
        pub type Fail0IeR = crate::BitReader;
        #[doc = "Field `FAIL0_IE` writer - FAIL0 Interrupt"]
        pub type Fail0IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL1_IE` reader - FAIL1 Interrupt"]
        pub type Fail1IeR = crate::BitReader;
        #[doc = "Field `FAIL1_IE` writer - FAIL1 Interrupt"]
        pub type Fail1IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL2_IE` reader - FAIL2 Interrupt"]
        pub type Fail2IeR = crate::BitReader;
        #[doc = "Field `FAIL2_IE` writer - FAIL2 Interrupt"]
        pub type Fail2IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL3_IE` reader - FAIL3 Interrupt"]
        pub type Fail3IeR = crate::BitReader;
        #[doc = "Field `FAIL3_IE` writer - FAIL3 Interrupt"]
        pub type Fail3IeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 4 - FAIL0 Interrupt"]
            #[inline(always)]
            pub fn fail0_ie(&self) -> Fail0IeR {
                Fail0IeR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - FAIL1 Interrupt"]
            #[inline(always)]
            pub fn fail1_ie(&self) -> Fail1IeR {
                Fail1IeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - FAIL2 Interrupt"]
            #[inline(always)]
            pub fn fail2_ie(&self) -> Fail2IeR {
                Fail2IeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - FAIL3 Interrupt"]
            #[inline(always)]
            pub fn fail3_ie(&self) -> Fail3IeR {
                Fail3IeR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 4 - FAIL0 Interrupt"]
            #[inline(always)]
            pub fn fail0_ie(&mut self) -> Fail0IeW<EieSpec> {
                Fail0IeW::new(self, 4)
            }
            #[doc = "Bit 5 - FAIL1 Interrupt"]
            #[inline(always)]
            pub fn fail1_ie(&mut self) -> Fail1IeW<EieSpec> {
                Fail1IeW::new(self, 5)
            }
            #[doc = "Bit 6 - FAIL2 Interrupt"]
            #[inline(always)]
            pub fn fail2_ie(&mut self) -> Fail2IeW<EieSpec> {
                Fail2IeW::new(self, 6)
            }
            #[doc = "Bit 7 - FAIL3 Interrupt"]
            #[inline(always)]
            pub fn fail3_ie(&mut self) -> Fail3IeW<EieSpec> {
                Fail3IeW::new(self, 7)
            }
        }
        #[doc = "Error Interrupt Sources Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`eie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EieSpec;
        impl crate::RegisterSpec for EieSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`eie::R`](R) reader structure"]
        impl crate::Readable for EieSpec {}
        #[doc = "`write(|w| ..)` method takes [`eie::W`](W) writer structure"]
        impl crate::Writable for EieSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets EIE to value 0"]
        impl crate::Resettable for EieSpec {}
    }
    #[doc = "EIF (rw) register accessor: Error Interrupt Flags\n\nYou can [`read`](crate::Reg::read) this register and get [`eif::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eif::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eif`] module"]
    #[doc(alias = "EIF")]
    pub type Eif = crate::Reg<eif::EifSpec>;
    #[doc = "Error Interrupt Flags"]
    pub mod eif {
        #[doc = "Register `EIF` reader"]
        pub type R = crate::R<EifSpec>;
        #[doc = "Register `EIF` writer"]
        pub type W = crate::W<EifSpec>;
        #[doc = "Field `FAIL0_IF` reader - FAIL0 Interrupt Flag"]
        pub type Fail0IfR = crate::BitReader;
        #[doc = "Field `FAIL0_IF` writer - FAIL0 Interrupt Flag"]
        pub type Fail0IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL1_IF` reader - FAIL1 Interrupt Flag"]
        pub type Fail1IfR = crate::BitReader;
        #[doc = "Field `FAIL1_IF` writer - FAIL1 Interrupt Flag"]
        pub type Fail1IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL2_IF` reader - FAIL2 Interrupt Flag"]
        pub type Fail2IfR = crate::BitReader;
        #[doc = "Field `FAIL2_IF` writer - FAIL2 Interrupt Flag"]
        pub type Fail2IfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL3_IF` reader - FAIL3 Interrupt Flag"]
        pub type Fail3IfR = crate::BitReader;
        #[doc = "Field `FAIL3_IF` writer - FAIL3 Interrupt Flag"]
        pub type Fail3IfW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 4 - FAIL0 Interrupt Flag"]
            #[inline(always)]
            pub fn fail0_if(&self) -> Fail0IfR {
                Fail0IfR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - FAIL1 Interrupt Flag"]
            #[inline(always)]
            pub fn fail1_if(&self) -> Fail1IfR {
                Fail1IfR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - FAIL2 Interrupt Flag"]
            #[inline(always)]
            pub fn fail2_if(&self) -> Fail2IfR {
                Fail2IfR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - FAIL3 Interrupt Flag"]
            #[inline(always)]
            pub fn fail3_if(&self) -> Fail3IfR {
                Fail3IfR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 4 - FAIL0 Interrupt Flag"]
            #[inline(always)]
            pub fn fail0_if(&mut self) -> Fail0IfW<EifSpec> {
                Fail0IfW::new(self, 4)
            }
            #[doc = "Bit 5 - FAIL1 Interrupt Flag"]
            #[inline(always)]
            pub fn fail1_if(&mut self) -> Fail1IfW<EifSpec> {
                Fail1IfW::new(self, 5)
            }
            #[doc = "Bit 6 - FAIL2 Interrupt Flag"]
            #[inline(always)]
            pub fn fail2_if(&mut self) -> Fail2IfW<EifSpec> {
                Fail2IfW::new(self, 6)
            }
            #[doc = "Bit 7 - FAIL3 Interrupt Flag"]
            #[inline(always)]
            pub fn fail3_if(&mut self) -> Fail3IfW<EifSpec> {
                Fail3IfW::new(self, 7)
            }
        }
        #[doc = "Error Interrupt Flags\n\nYou can [`read`](crate::Reg::read) this register and get [`eif::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eif::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EifSpec;
        impl crate::RegisterSpec for EifSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`eif::R`](R) reader structure"]
        impl crate::Readable for EifSpec {}
        #[doc = "`write(|w| ..)` method takes [`eif::W`](W) writer structure"]
        impl crate::Writable for EifSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets EIF to value 0"]
        impl crate::Resettable for EifSpec {}
    }
    #[doc = "RE (rw) register accessor: DMA request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`re::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`re::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@re`] module"]
    #[doc(alias = "RE")]
    pub type Re = crate::Reg<re::ReSpec>;
    #[doc = "DMA request enable"]
    pub mod re {
        #[doc = "Register `RE` reader"]
        pub type R = crate::R<ReSpec>;
        #[doc = "Register `RE` writer"]
        pub type W = crate::W<ReSpec>;
        #[doc = "Field `TMR0_RE` reader - ADC trigger 0 DMA request enable"]
        pub type Tmr0ReR = crate::BitReader;
        #[doc = "Field `TMR0_RE` writer - ADC trigger 0 DMA request enable"]
        pub type Tmr0ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR1_RE` reader - ADC trigger 1 DMA request enable"]
        pub type Tmr1ReR = crate::BitReader;
        #[doc = "Field `TMR1_RE` writer - ADC trigger 1 DMA request enable"]
        pub type Tmr1ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR2_RE` reader - ADC trigger 2 DMA request enable"]
        pub type Tmr2ReR = crate::BitReader;
        #[doc = "Field `TMR2_RE` writer - ADC trigger 2 DMA request enable"]
        pub type Tmr2ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TMR3_RE` reader - ADC trigger 3 DMA request enable"]
        pub type Tmr3ReR = crate::BitReader;
        #[doc = "Field `TMR3_RE` writer - ADC trigger 3 DMA request enable"]
        pub type Tmr3ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TR0_T0_RE` reader - Counter0 Start Over Event DMA request enable"]
        pub type Tr0T0ReR = crate::BitReader;
        #[doc = "Field `TR0_T0_RE` writer - Counter0 Start Over Event DMA request enable"]
        pub type Tr0T0ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TR0_T1_RE` reader - Counter0 Crossing Zero Event DMA request enable"]
        pub type Tr0T1ReR = crate::BitReader;
        #[doc = "Field `TR0_T1_RE` writer - Counter0 Crossing Zero Event DMA request enable"]
        pub type Tr0T1ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TR1_T0_RE` reader - Counter1 Start Over Event DMA request enable"]
        pub type Tr1T0ReR = crate::BitReader;
        #[doc = "Field `TR1_T0_RE` writer - Counter1 Start Over Event DMA request enable"]
        pub type Tr1T0ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TR1_T1_RE` reader - Counter1 Crossing Zero Event DMA request enable"]
        pub type Tr1T1ReR = crate::BitReader;
        #[doc = "Field `TR1_T1_RE` writer - Counter1 Crossing Zero Event DMA request enable"]
        pub type Tr1T1ReW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - ADC trigger 0 DMA request enable"]
            #[inline(always)]
            pub fn tmr0_re(&self) -> Tmr0ReR {
                Tmr0ReR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - ADC trigger 1 DMA request enable"]
            #[inline(always)]
            pub fn tmr1_re(&self) -> Tmr1ReR {
                Tmr1ReR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - ADC trigger 2 DMA request enable"]
            #[inline(always)]
            pub fn tmr2_re(&self) -> Tmr2ReR {
                Tmr2ReR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - ADC trigger 3 DMA request enable"]
            #[inline(always)]
            pub fn tmr3_re(&self) -> Tmr3ReR {
                Tmr3ReR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Counter0 Start Over Event DMA request enable"]
            #[inline(always)]
            pub fn tr0_t0_re(&self) -> Tr0T0ReR {
                Tr0T0ReR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Counter0 Crossing Zero Event DMA request enable"]
            #[inline(always)]
            pub fn tr0_t1_re(&self) -> Tr0T1ReR {
                Tr0T1ReR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Counter1 Start Over Event DMA request enable"]
            #[inline(always)]
            pub fn tr1_t0_re(&self) -> Tr1T0ReR {
                Tr1T0ReR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Counter1 Crossing Zero Event DMA request enable"]
            #[inline(always)]
            pub fn tr1_t1_re(&self) -> Tr1T1ReR {
                Tr1T1ReR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ADC trigger 0 DMA request enable"]
            #[inline(always)]
            pub fn tmr0_re(&mut self) -> Tmr0ReW<ReSpec> {
                Tmr0ReW::new(self, 0)
            }
            #[doc = "Bit 1 - ADC trigger 1 DMA request enable"]
            #[inline(always)]
            pub fn tmr1_re(&mut self) -> Tmr1ReW<ReSpec> {
                Tmr1ReW::new(self, 1)
            }
            #[doc = "Bit 2 - ADC trigger 2 DMA request enable"]
            #[inline(always)]
            pub fn tmr2_re(&mut self) -> Tmr2ReW<ReSpec> {
                Tmr2ReW::new(self, 2)
            }
            #[doc = "Bit 3 - ADC trigger 3 DMA request enable"]
            #[inline(always)]
            pub fn tmr3_re(&mut self) -> Tmr3ReW<ReSpec> {
                Tmr3ReW::new(self, 3)
            }
            #[doc = "Bit 4 - Counter0 Start Over Event DMA request enable"]
            #[inline(always)]
            pub fn tr0_t0_re(&mut self) -> Tr0T0ReW<ReSpec> {
                Tr0T0ReW::new(self, 4)
            }
            #[doc = "Bit 5 - Counter0 Crossing Zero Event DMA request enable"]
            #[inline(always)]
            pub fn tr0_t1_re(&mut self) -> Tr0T1ReW<ReSpec> {
                Tr0T1ReW::new(self, 5)
            }
            #[doc = "Bit 6 - Counter1 Start Over Event DMA request enable"]
            #[inline(always)]
            pub fn tr1_t0_re(&mut self) -> Tr1T0ReW<ReSpec> {
                Tr1T0ReW::new(self, 6)
            }
            #[doc = "Bit 7 - Counter1 Crossing Zero Event DMA request enable"]
            #[inline(always)]
            pub fn tr1_t1_re(&mut self) -> Tr1T1ReW<ReSpec> {
                Tr1T1ReW::new(self, 7)
            }
        }
        #[doc = "DMA request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`re::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`re::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ReSpec;
        impl crate::RegisterSpec for ReSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`re::R`](R) reader structure"]
        impl crate::Readable for ReSpec {}
        #[doc = "`write(|w| ..)` method takes [`re::W`](W) writer structure"]
        impl crate::Writable for ReSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets RE to value 0"]
        impl crate::Resettable for ReSpec {}
    }
    #[doc = "PP (rw) register accessor: Push-Pull configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`pp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pp`] module"]
    #[doc(alias = "PP")]
    pub type Pp = crate::Reg<pp::PpSpec>;
    #[doc = "Push-Pull configuration"]
    pub mod pp {
        #[doc = "Register `PP` reader"]
        pub type R = crate::R<PpSpec>;
        #[doc = "Register `PP` writer"]
        pub type W = crate::W<PpSpec>;
        #[doc = "Field `IO0_PPE` reader - IO0 Push-Pull mode enable"]
        pub type Io0PpeR = crate::BitReader;
        #[doc = "Field `IO0_PPE` writer - IO0 Push-Pull mode enable"]
        pub type Io0PpeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IO1_PPE` reader - IO1 Push-Pull mode enable"]
        pub type Io1PpeR = crate::BitReader;
        #[doc = "Field `IO1_PPE` writer - IO1 Push-Pull mode enable"]
        pub type Io1PpeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IO2_PPE` reader - IO2 Push-Pull mode enable"]
        pub type Io2PpeR = crate::BitReader;
        #[doc = "Field `IO2_PPE` writer - IO2 Push-Pull mode enable"]
        pub type Io2PpeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IO3_PPE` reader - IO3 Push-Pull mode enable"]
        pub type Io3PpeR = crate::BitReader;
        #[doc = "Field `IO3_PPE` writer - IO3 Push-Pull mode enable"]
        pub type Io3PpeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - IO0 Push-Pull mode enable"]
            #[inline(always)]
            pub fn io0_ppe(&self) -> Io0PpeR {
                Io0PpeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - IO1 Push-Pull mode enable"]
            #[inline(always)]
            pub fn io1_ppe(&self) -> Io1PpeR {
                Io1PpeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - IO2 Push-Pull mode enable"]
            #[inline(always)]
            pub fn io2_ppe(&self) -> Io2PpeR {
                Io2PpeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - IO3 Push-Pull mode enable"]
            #[inline(always)]
            pub fn io3_ppe(&self) -> Io3PpeR {
                Io3PpeR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - IO0 Push-Pull mode enable"]
            #[inline(always)]
            pub fn io0_ppe(&mut self) -> Io0PpeW<PpSpec> {
                Io0PpeW::new(self, 0)
            }
            #[doc = "Bit 1 - IO1 Push-Pull mode enable"]
            #[inline(always)]
            pub fn io1_ppe(&mut self) -> Io1PpeW<PpSpec> {
                Io1PpeW::new(self, 1)
            }
            #[doc = "Bit 2 - IO2 Push-Pull mode enable"]
            #[inline(always)]
            pub fn io2_ppe(&mut self) -> Io2PpeW<PpSpec> {
                Io2PpeW::new(self, 2)
            }
            #[doc = "Bit 3 - IO3 Push-Pull mode enable"]
            #[inline(always)]
            pub fn io3_ppe(&mut self) -> Io3PpeW<PpSpec> {
                Io3PpeW::new(self, 3)
            }
        }
        #[doc = "Push-Pull configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`pp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PpSpec;
        impl crate::RegisterSpec for PpSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pp::R`](R) reader structure"]
        impl crate::Readable for PpSpec {}
        #[doc = "`write(|w| ..)` method takes [`pp::W`](W) writer structure"]
        impl crate::Writable for PpSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PP to value 0"]
        impl crate::Resettable for PpSpec {}
    }
    #[doc = "IO01 (rw) register accessor: Channel 0/1 Setting\n\nYou can [`read`](crate::Reg::read) this register and get [`io01::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`io01::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@io01`] module"]
    #[doc(alias = "IO01")]
    pub type Io01 = crate::Reg<io01::Io01Spec>;
    #[doc = "Channel 0/1 Setting"]
    pub mod io01 {
        #[doc = "Register `IO01` reader"]
        pub type R = crate::R<Io01Spec>;
        #[doc = "Register `IO01` writer"]
        pub type W = crate::W<Io01Spec>;
        #[doc = "Field `CH0_NP` reader - Channel_0 N Polarity"]
        pub type Ch0NpR = crate::BitReader;
        #[doc = "Field `CH0_NP` writer - Channel_0 N Polarity"]
        pub type Ch0NpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0_PP` reader - Channel_0 P Polarity"]
        pub type Ch0PpR = crate::BitReader;
        #[doc = "Field `CH0_PP` writer - Channel_0 P Polarity"]
        pub type Ch0PpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0_NS` reader - Channel_0 N Source"]
        pub type Ch0NsR = crate::BitReader;
        #[doc = "Field `CH0_NS` writer - Channel_0 N Source"]
        pub type Ch0NsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0_PS` reader - Channel_0 P Source"]
        pub type Ch0PsR = crate::BitReader;
        #[doc = "Field `CH0_PS` writer - Channel_0 P Source"]
        pub type Ch0PsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0_SCTRLN` reader - Channel_0 SoftCtrlN"]
        pub type Ch0SctrlnR = crate::BitReader;
        #[doc = "Field `CH0_SCTRLN` writer - Channel_0 SoftCtrlN"]
        pub type Ch0SctrlnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0_SCTRLP` reader - Channel_0 SoftCtrlP"]
        pub type Ch0SctrlpR = crate::BitReader;
        #[doc = "Field `CH0_SCTRLP` writer - Channel_0 SoftCtrlP"]
        pub type Ch0SctrlpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0_PN_SW` reader - Channel_0 P/N Switch"]
        pub type Ch0PnSwR = crate::BitReader;
        #[doc = "Field `CH0_PN_SW` writer - Channel_0 P/N Switch"]
        pub type Ch0PnSwW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0_WM` reader - Channel_0 WorkMode"]
        pub type Ch0WmR = crate::BitReader;
        #[doc = "Field `CH0_WM` writer - Channel_0 WorkMode"]
        pub type Ch0WmW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_NP` reader - Channel_1 N Polarity"]
        pub type Ch1NpR = crate::BitReader;
        #[doc = "Field `CH1_NP` writer - Channel_1 N Polarity"]
        pub type Ch1NpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_PP` reader - Channel_1 P Polarity"]
        pub type Ch1PpR = crate::BitReader;
        #[doc = "Field `CH1_PP` writer - Channel_1 P Polarity"]
        pub type Ch1PpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_NS` reader - Channel_1 N Source"]
        pub type Ch1NsR = crate::BitReader;
        #[doc = "Field `CH1_NS` writer - Channel_1 N Source"]
        pub type Ch1NsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_PS` reader - Channel_1 P Source"]
        pub type Ch1PsR = crate::BitReader;
        #[doc = "Field `CH1_PS` writer - Channel_1 P Source"]
        pub type Ch1PsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_SCTRLN` reader - Channel_1 SoftCtrlN"]
        pub type Ch1SctrlnR = crate::BitReader;
        #[doc = "Field `CH1_SCTRLN` writer - Channel_1 SoftCtrlN"]
        pub type Ch1SctrlnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_SCTRLP` reader - Channel_1 SoftCtrlP"]
        pub type Ch1SctrlpR = crate::BitReader;
        #[doc = "Field `CH1_SCTRLP` writer - Channel_1 SoftCtrlP"]
        pub type Ch1SctrlpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_PN_SW` reader - Channel_1 P/N Switch"]
        pub type Ch1PnSwR = crate::BitReader;
        #[doc = "Field `CH1_PN_SW` writer - Channel_1 P/N Switch"]
        pub type Ch1PnSwW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_WM` reader - Channel_1 WorkMode"]
        pub type Ch1WmR = crate::BitReader;
        #[doc = "Field `CH1_WM` writer - Channel_1 WorkMode"]
        pub type Ch1WmW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Channel_0 N Polarity"]
            #[inline(always)]
            pub fn ch0_np(&self) -> Ch0NpR {
                Ch0NpR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Channel_0 P Polarity"]
            #[inline(always)]
            pub fn ch0_pp(&self) -> Ch0PpR {
                Ch0PpR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Channel_0 N Source"]
            #[inline(always)]
            pub fn ch0_ns(&self) -> Ch0NsR {
                Ch0NsR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Channel_0 P Source"]
            #[inline(always)]
            pub fn ch0_ps(&self) -> Ch0PsR {
                Ch0PsR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Channel_0 SoftCtrlN"]
            #[inline(always)]
            pub fn ch0_sctrln(&self) -> Ch0SctrlnR {
                Ch0SctrlnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Channel_0 SoftCtrlP"]
            #[inline(always)]
            pub fn ch0_sctrlp(&self) -> Ch0SctrlpR {
                Ch0SctrlpR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Channel_0 P/N Switch"]
            #[inline(always)]
            pub fn ch0_pn_sw(&self) -> Ch0PnSwR {
                Ch0PnSwR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Channel_0 WorkMode"]
            #[inline(always)]
            pub fn ch0_wm(&self) -> Ch0WmR {
                Ch0WmR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Channel_1 N Polarity"]
            #[inline(always)]
            pub fn ch1_np(&self) -> Ch1NpR {
                Ch1NpR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Channel_1 P Polarity"]
            #[inline(always)]
            pub fn ch1_pp(&self) -> Ch1PpR {
                Ch1PpR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Channel_1 N Source"]
            #[inline(always)]
            pub fn ch1_ns(&self) -> Ch1NsR {
                Ch1NsR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Channel_1 P Source"]
            #[inline(always)]
            pub fn ch1_ps(&self) -> Ch1PsR {
                Ch1PsR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Channel_1 SoftCtrlN"]
            #[inline(always)]
            pub fn ch1_sctrln(&self) -> Ch1SctrlnR {
                Ch1SctrlnR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Channel_1 SoftCtrlP"]
            #[inline(always)]
            pub fn ch1_sctrlp(&self) -> Ch1SctrlpR {
                Ch1SctrlpR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Channel_1 P/N Switch"]
            #[inline(always)]
            pub fn ch1_pn_sw(&self) -> Ch1PnSwR {
                Ch1PnSwR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Channel_1 WorkMode"]
            #[inline(always)]
            pub fn ch1_wm(&self) -> Ch1WmR {
                Ch1WmR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Channel_0 N Polarity"]
            #[inline(always)]
            pub fn ch0_np(&mut self) -> Ch0NpW<Io01Spec> {
                Ch0NpW::new(self, 0)
            }
            #[doc = "Bit 1 - Channel_0 P Polarity"]
            #[inline(always)]
            pub fn ch0_pp(&mut self) -> Ch0PpW<Io01Spec> {
                Ch0PpW::new(self, 1)
            }
            #[doc = "Bit 2 - Channel_0 N Source"]
            #[inline(always)]
            pub fn ch0_ns(&mut self) -> Ch0NsW<Io01Spec> {
                Ch0NsW::new(self, 2)
            }
            #[doc = "Bit 3 - Channel_0 P Source"]
            #[inline(always)]
            pub fn ch0_ps(&mut self) -> Ch0PsW<Io01Spec> {
                Ch0PsW::new(self, 3)
            }
            #[doc = "Bit 4 - Channel_0 SoftCtrlN"]
            #[inline(always)]
            pub fn ch0_sctrln(&mut self) -> Ch0SctrlnW<Io01Spec> {
                Ch0SctrlnW::new(self, 4)
            }
            #[doc = "Bit 5 - Channel_0 SoftCtrlP"]
            #[inline(always)]
            pub fn ch0_sctrlp(&mut self) -> Ch0SctrlpW<Io01Spec> {
                Ch0SctrlpW::new(self, 5)
            }
            #[doc = "Bit 6 - Channel_0 P/N Switch"]
            #[inline(always)]
            pub fn ch0_pn_sw(&mut self) -> Ch0PnSwW<Io01Spec> {
                Ch0PnSwW::new(self, 6)
            }
            #[doc = "Bit 7 - Channel_0 WorkMode"]
            #[inline(always)]
            pub fn ch0_wm(&mut self) -> Ch0WmW<Io01Spec> {
                Ch0WmW::new(self, 7)
            }
            #[doc = "Bit 8 - Channel_1 N Polarity"]
            #[inline(always)]
            pub fn ch1_np(&mut self) -> Ch1NpW<Io01Spec> {
                Ch1NpW::new(self, 8)
            }
            #[doc = "Bit 9 - Channel_1 P Polarity"]
            #[inline(always)]
            pub fn ch1_pp(&mut self) -> Ch1PpW<Io01Spec> {
                Ch1PpW::new(self, 9)
            }
            #[doc = "Bit 10 - Channel_1 N Source"]
            #[inline(always)]
            pub fn ch1_ns(&mut self) -> Ch1NsW<Io01Spec> {
                Ch1NsW::new(self, 10)
            }
            #[doc = "Bit 11 - Channel_1 P Source"]
            #[inline(always)]
            pub fn ch1_ps(&mut self) -> Ch1PsW<Io01Spec> {
                Ch1PsW::new(self, 11)
            }
            #[doc = "Bit 12 - Channel_1 SoftCtrlN"]
            #[inline(always)]
            pub fn ch1_sctrln(&mut self) -> Ch1SctrlnW<Io01Spec> {
                Ch1SctrlnW::new(self, 12)
            }
            #[doc = "Bit 13 - Channel_1 SoftCtrlP"]
            #[inline(always)]
            pub fn ch1_sctrlp(&mut self) -> Ch1SctrlpW<Io01Spec> {
                Ch1SctrlpW::new(self, 13)
            }
            #[doc = "Bit 14 - Channel_1 P/N Switch"]
            #[inline(always)]
            pub fn ch1_pn_sw(&mut self) -> Ch1PnSwW<Io01Spec> {
                Ch1PnSwW::new(self, 14)
            }
            #[doc = "Bit 15 - Channel_1 WorkMode"]
            #[inline(always)]
            pub fn ch1_wm(&mut self) -> Ch1WmW<Io01Spec> {
                Ch1WmW::new(self, 15)
            }
        }
        #[doc = "Channel 0/1 Setting\n\nYou can [`read`](crate::Reg::read) this register and get [`io01::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`io01::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Io01Spec;
        impl crate::RegisterSpec for Io01Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`io01::R`](R) reader structure"]
        impl crate::Readable for Io01Spec {}
        #[doc = "`write(|w| ..)` method takes [`io01::W`](W) writer structure"]
        impl crate::Writable for Io01Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IO01 to value 0"]
        impl crate::Resettable for Io01Spec {}
    }
    #[doc = "IO23 (rw) register accessor: Channel 2/3 Setting\n\nYou can [`read`](crate::Reg::read) this register and get [`io23::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`io23::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@io23`] module"]
    #[doc(alias = "IO23")]
    pub type Io23 = crate::Reg<io23::Io23Spec>;
    #[doc = "Channel 2/3 Setting"]
    pub mod io23 {
        #[doc = "Register `IO23` reader"]
        pub type R = crate::R<Io23Spec>;
        #[doc = "Register `IO23` writer"]
        pub type W = crate::W<Io23Spec>;
        #[doc = "Field `CH2_NP` reader - Channel_2 N Polarity"]
        pub type Ch2NpR = crate::BitReader;
        #[doc = "Field `CH2_NP` writer - Channel_2 N Polarity"]
        pub type Ch2NpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2_PP` reader - Channel_2 P Polarity"]
        pub type Ch2PpR = crate::BitReader;
        #[doc = "Field `CH2_PP` writer - Channel_2 P Polarity"]
        pub type Ch2PpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2_NS` reader - Channel_2 N Source"]
        pub type Ch2NsR = crate::BitReader;
        #[doc = "Field `CH2_NS` writer - Channel_2 N Source"]
        pub type Ch2NsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2_PS` reader - Channel_2 P Source"]
        pub type Ch2PsR = crate::BitReader;
        #[doc = "Field `CH2_PS` writer - Channel_2 P Source"]
        pub type Ch2PsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2_SCTRLN` reader - Channel_2 SoftCtrlN"]
        pub type Ch2SctrlnR = crate::BitReader;
        #[doc = "Field `CH2_SCTRLN` writer - Channel_2 SoftCtrlN"]
        pub type Ch2SctrlnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2_SCTRLP` reader - Channel_2 SoftCtrlP"]
        pub type Ch2SctrlpR = crate::BitReader;
        #[doc = "Field `CH2_SCTRLP` writer - Channel_2 SoftCtrlP"]
        pub type Ch2SctrlpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2_PN_SW` reader - Channel_2 P/N Switch"]
        pub type Ch2PnSwR = crate::BitReader;
        #[doc = "Field `CH2_PN_SW` writer - Channel_2 P/N Switch"]
        pub type Ch2PnSwW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2_WM` reader - Channel_2 WorkMode"]
        pub type Ch2WmR = crate::BitReader;
        #[doc = "Field `CH2_WM` writer - Channel_2 WorkMode"]
        pub type Ch2WmW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3_NP` reader - Channel_3 N Polarity"]
        pub type Ch3NpR = crate::BitReader;
        #[doc = "Field `CH3_NP` writer - Channel_3 N Polarity"]
        pub type Ch3NpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3_PP` reader - Channel_3 P Polarity"]
        pub type Ch3PpR = crate::BitReader;
        #[doc = "Field `CH3_PP` writer - Channel_3 P Polarity"]
        pub type Ch3PpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3_NS` reader - Channel_3 N Source"]
        pub type Ch3NsR = crate::BitReader;
        #[doc = "Field `CH3_NS` writer - Channel_3 N Source"]
        pub type Ch3NsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3_PS` reader - Channel_3 P Source"]
        pub type Ch3PsR = crate::BitReader;
        #[doc = "Field `CH3_PS` writer - Channel_3 P Source"]
        pub type Ch3PsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3_SCTRLN` reader - Channel_3 SoftCtrlN"]
        pub type Ch3SctrlnR = crate::BitReader;
        #[doc = "Field `CH3_SCTRLN` writer - Channel_3 SoftCtrlN"]
        pub type Ch3SctrlnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3_SCTRLP` reader - Channel_3 SoftCtrlP"]
        pub type Ch3SctrlpR = crate::BitReader;
        #[doc = "Field `CH3_SCTRLP` writer - Channel_3 SoftCtrlP"]
        pub type Ch3SctrlpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3_PN_SW` reader - Channel_3 P/N Switch"]
        pub type Ch3PnSwR = crate::BitReader;
        #[doc = "Field `CH3_PN_SW` writer - Channel_3 P/N Switch"]
        pub type Ch3PnSwW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3_WM` reader - Channel_3 WorkMode"]
        pub type Ch3WmR = crate::BitReader;
        #[doc = "Field `CH3_WM` writer - Channel_3 WorkMode"]
        pub type Ch3WmW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Channel_2 N Polarity"]
            #[inline(always)]
            pub fn ch2_np(&self) -> Ch2NpR {
                Ch2NpR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Channel_2 P Polarity"]
            #[inline(always)]
            pub fn ch2_pp(&self) -> Ch2PpR {
                Ch2PpR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Channel_2 N Source"]
            #[inline(always)]
            pub fn ch2_ns(&self) -> Ch2NsR {
                Ch2NsR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Channel_2 P Source"]
            #[inline(always)]
            pub fn ch2_ps(&self) -> Ch2PsR {
                Ch2PsR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Channel_2 SoftCtrlN"]
            #[inline(always)]
            pub fn ch2_sctrln(&self) -> Ch2SctrlnR {
                Ch2SctrlnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Channel_2 SoftCtrlP"]
            #[inline(always)]
            pub fn ch2_sctrlp(&self) -> Ch2SctrlpR {
                Ch2SctrlpR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Channel_2 P/N Switch"]
            #[inline(always)]
            pub fn ch2_pn_sw(&self) -> Ch2PnSwR {
                Ch2PnSwR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Channel_2 WorkMode"]
            #[inline(always)]
            pub fn ch2_wm(&self) -> Ch2WmR {
                Ch2WmR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Channel_3 N Polarity"]
            #[inline(always)]
            pub fn ch3_np(&self) -> Ch3NpR {
                Ch3NpR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Channel_3 P Polarity"]
            #[inline(always)]
            pub fn ch3_pp(&self) -> Ch3PpR {
                Ch3PpR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Channel_3 N Source"]
            #[inline(always)]
            pub fn ch3_ns(&self) -> Ch3NsR {
                Ch3NsR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Channel_3 P Source"]
            #[inline(always)]
            pub fn ch3_ps(&self) -> Ch3PsR {
                Ch3PsR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Channel_3 SoftCtrlN"]
            #[inline(always)]
            pub fn ch3_sctrln(&self) -> Ch3SctrlnR {
                Ch3SctrlnR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Channel_3 SoftCtrlP"]
            #[inline(always)]
            pub fn ch3_sctrlp(&self) -> Ch3SctrlpR {
                Ch3SctrlpR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Channel_3 P/N Switch"]
            #[inline(always)]
            pub fn ch3_pn_sw(&self) -> Ch3PnSwR {
                Ch3PnSwR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Channel_3 WorkMode"]
            #[inline(always)]
            pub fn ch3_wm(&self) -> Ch3WmR {
                Ch3WmR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Channel_2 N Polarity"]
            #[inline(always)]
            pub fn ch2_np(&mut self) -> Ch2NpW<Io23Spec> {
                Ch2NpW::new(self, 0)
            }
            #[doc = "Bit 1 - Channel_2 P Polarity"]
            #[inline(always)]
            pub fn ch2_pp(&mut self) -> Ch2PpW<Io23Spec> {
                Ch2PpW::new(self, 1)
            }
            #[doc = "Bit 2 - Channel_2 N Source"]
            #[inline(always)]
            pub fn ch2_ns(&mut self) -> Ch2NsW<Io23Spec> {
                Ch2NsW::new(self, 2)
            }
            #[doc = "Bit 3 - Channel_2 P Source"]
            #[inline(always)]
            pub fn ch2_ps(&mut self) -> Ch2PsW<Io23Spec> {
                Ch2PsW::new(self, 3)
            }
            #[doc = "Bit 4 - Channel_2 SoftCtrlN"]
            #[inline(always)]
            pub fn ch2_sctrln(&mut self) -> Ch2SctrlnW<Io23Spec> {
                Ch2SctrlnW::new(self, 4)
            }
            #[doc = "Bit 5 - Channel_2 SoftCtrlP"]
            #[inline(always)]
            pub fn ch2_sctrlp(&mut self) -> Ch2SctrlpW<Io23Spec> {
                Ch2SctrlpW::new(self, 5)
            }
            #[doc = "Bit 6 - Channel_2 P/N Switch"]
            #[inline(always)]
            pub fn ch2_pn_sw(&mut self) -> Ch2PnSwW<Io23Spec> {
                Ch2PnSwW::new(self, 6)
            }
            #[doc = "Bit 7 - Channel_2 WorkMode"]
            #[inline(always)]
            pub fn ch2_wm(&mut self) -> Ch2WmW<Io23Spec> {
                Ch2WmW::new(self, 7)
            }
            #[doc = "Bit 8 - Channel_3 N Polarity"]
            #[inline(always)]
            pub fn ch3_np(&mut self) -> Ch3NpW<Io23Spec> {
                Ch3NpW::new(self, 8)
            }
            #[doc = "Bit 9 - Channel_3 P Polarity"]
            #[inline(always)]
            pub fn ch3_pp(&mut self) -> Ch3PpW<Io23Spec> {
                Ch3PpW::new(self, 9)
            }
            #[doc = "Bit 10 - Channel_3 N Source"]
            #[inline(always)]
            pub fn ch3_ns(&mut self) -> Ch3NsW<Io23Spec> {
                Ch3NsW::new(self, 10)
            }
            #[doc = "Bit 11 - Channel_3 P Source"]
            #[inline(always)]
            pub fn ch3_ps(&mut self) -> Ch3PsW<Io23Spec> {
                Ch3PsW::new(self, 11)
            }
            #[doc = "Bit 12 - Channel_3 SoftCtrlN"]
            #[inline(always)]
            pub fn ch3_sctrln(&mut self) -> Ch3SctrlnW<Io23Spec> {
                Ch3SctrlnW::new(self, 12)
            }
            #[doc = "Bit 13 - Channel_3 SoftCtrlP"]
            #[inline(always)]
            pub fn ch3_sctrlp(&mut self) -> Ch3SctrlpW<Io23Spec> {
                Ch3SctrlpW::new(self, 13)
            }
            #[doc = "Bit 14 - Channel_3 P/N Switch"]
            #[inline(always)]
            pub fn ch3_pn_sw(&mut self) -> Ch3PnSwW<Io23Spec> {
                Ch3PnSwW::new(self, 14)
            }
            #[doc = "Bit 15 - Channel_3 WorkMode"]
            #[inline(always)]
            pub fn ch3_wm(&mut self) -> Ch3WmW<Io23Spec> {
                Ch3WmW::new(self, 15)
            }
        }
        #[doc = "Channel 2/3 Setting\n\nYou can [`read`](crate::Reg::read) this register and get [`io23::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`io23::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Io23Spec;
        impl crate::RegisterSpec for Io23Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`io23::R`](R) reader structure"]
        impl crate::Readable for Io23Spec {}
        #[doc = "`write(|w| ..)` method takes [`io23::W`](W) writer structure"]
        impl crate::Writable for Io23Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IO23 to value 0"]
        impl crate::Resettable for Io23Spec {}
    }
    #[doc = "FAIL012 (rw) register accessor: MCPWM Channel 012 Short Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fail012::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fail012::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fail012`] module"]
    #[doc(alias = "FAIL012")]
    pub type Fail012 = crate::Reg<fail012::Fail012Spec>;
    #[doc = "MCPWM Channel 012 Short Control Register"]
    pub mod fail012 {
        #[doc = "Register `FAIL012` reader"]
        pub type R = crate::R<Fail012Spec>;
        #[doc = "Register `FAIL012` writer"]
        pub type W = crate::W<Fail012Spec>;
        #[doc = "Field `FAIL0_SEL` reader - Select from CMP0 or IO 0"]
        pub type Fail0SelR = crate::BitReader;
        #[doc = "Field `FAIL0_SEL` writer - Select from CMP0 or IO 0"]
        pub type Fail0SelW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL1_SEL` reader - Select from CMP1 or IO 1"]
        pub type Fail1SelR = crate::BitReader;
        #[doc = "Field `FAIL1_SEL` writer - Select from CMP1 or IO 1"]
        pub type Fail1SelW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL0_POL` reader - FAIL 0 active polarity"]
        pub type Fail0PolR = crate::BitReader;
        #[doc = "Field `FAIL0_POL` writer - FAIL 0 active polarity"]
        pub type Fail0PolW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL1_POL` reader - FAIL 1 active polarity"]
        pub type Fail1PolR = crate::BitReader;
        #[doc = "Field `FAIL1_POL` writer - FAIL 1 active polarity"]
        pub type Fail1PolW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL0_EN` reader - FAIL 0 Short Protect Enable or Not"]
        pub type Fail0EnR = crate::BitReader;
        #[doc = "Field `FAIL0_EN` writer - FAIL 0 Short Protect Enable or Not"]
        pub type Fail0EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL1_EN` reader - FAIL 1 Short Protect Enable or Not"]
        pub type Fail1EnR = crate::BitReader;
        #[doc = "Field `FAIL1_EN` writer - FAIL 1 Short Protect Enable or Not"]
        pub type Fail1EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MOE` reader - MCPWM Output Enable"]
        pub type MoeR = crate::BitReader;
        #[doc = "Field `MOE` writer - MCPWM Output Enable"]
        pub type MoeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HALT_PRT` reader - MCU in Debug Mode(Halted by Debug), MCPWM Close or Not"]
        pub type HaltPrtR = crate::BitReader;
        #[doc = "Field `HALT_PRT` writer - MCU in Debug Mode(Halted by Debug), MCPWM Close or Not"]
        pub type HaltPrtW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0N_DEFAULT` reader - CH0_N Default Value"]
        pub type Ch0nDefaultR = crate::BitReader;
        #[doc = "Field `CH0N_DEFAULT` writer - CH0_N Default Value"]
        pub type Ch0nDefaultW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0P_DEFAULT` reader - CH0_P Default Value"]
        pub type Ch0pDefaultR = crate::BitReader;
        #[doc = "Field `CH0P_DEFAULT` writer - CH0_P Default Value"]
        pub type Ch0pDefaultW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1N_DEFAULT` reader - CH1_N Default Value"]
        pub type Ch1nDefaultR = crate::BitReader;
        #[doc = "Field `CH1N_DEFAULT` writer - CH1_N Default Value"]
        pub type Ch1nDefaultW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1P_DEFAULT` reader - CH1_P Default Value"]
        pub type Ch1pDefaultR = crate::BitReader;
        #[doc = "Field `CH1P_DEFAULT` writer - CH1_P Default Value"]
        pub type Ch1pDefaultW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2N_DEFAULT` reader - CH2_N Default Value"]
        pub type Ch2nDefaultR = crate::BitReader;
        #[doc = "Field `CH2N_DEFAULT` writer - CH2_N Default Value"]
        pub type Ch2nDefaultW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2P_DEFAULT` reader - CH2_P Default Value"]
        pub type Ch2pDefaultR = crate::BitReader;
        #[doc = "Field `CH2P_DEFAULT` writer - CH2_P Default Value"]
        pub type Ch2pDefaultW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL_0CAP` reader - Save Counter0 to MCPWM_FCNT during fail0/1 event"]
        pub type Fail0capR = crate::BitReader;
        #[doc = "Field `FAIL_0CAP` writer - Save Counter0 to MCPWM_FCNT during fail0/1 event"]
        pub type Fail0capW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Select from CMP0 or IO 0"]
            #[inline(always)]
            pub fn fail0_sel(&self) -> Fail0SelR {
                Fail0SelR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Select from CMP1 or IO 1"]
            #[inline(always)]
            pub fn fail1_sel(&self) -> Fail1SelR {
                Fail1SelR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - FAIL 0 active polarity"]
            #[inline(always)]
            pub fn fail0_pol(&self) -> Fail0PolR {
                Fail0PolR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - FAIL 1 active polarity"]
            #[inline(always)]
            pub fn fail1_pol(&self) -> Fail1PolR {
                Fail1PolR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - FAIL 0 Short Protect Enable or Not"]
            #[inline(always)]
            pub fn fail0_en(&self) -> Fail0EnR {
                Fail0EnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - FAIL 1 Short Protect Enable or Not"]
            #[inline(always)]
            pub fn fail1_en(&self) -> Fail1EnR {
                Fail1EnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - MCPWM Output Enable"]
            #[inline(always)]
            pub fn moe(&self) -> MoeR {
                MoeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - MCU in Debug Mode(Halted by Debug), MCPWM Close or Not"]
            #[inline(always)]
            pub fn halt_prt(&self) -> HaltPrtR {
                HaltPrtR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - CH0_N Default Value"]
            #[inline(always)]
            pub fn ch0n_default(&self) -> Ch0nDefaultR {
                Ch0nDefaultR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - CH0_P Default Value"]
            #[inline(always)]
            pub fn ch0p_default(&self) -> Ch0pDefaultR {
                Ch0pDefaultR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - CH1_N Default Value"]
            #[inline(always)]
            pub fn ch1n_default(&self) -> Ch1nDefaultR {
                Ch1nDefaultR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - CH1_P Default Value"]
            #[inline(always)]
            pub fn ch1p_default(&self) -> Ch1pDefaultR {
                Ch1pDefaultR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - CH2_N Default Value"]
            #[inline(always)]
            pub fn ch2n_default(&self) -> Ch2nDefaultR {
                Ch2nDefaultR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - CH2_P Default Value"]
            #[inline(always)]
            pub fn ch2p_default(&self) -> Ch2pDefaultR {
                Ch2pDefaultR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 15 - Save Counter0 to MCPWM_FCNT during fail0/1 event"]
            #[inline(always)]
            pub fn fail_0cap(&self) -> Fail0capR {
                Fail0capR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Select from CMP0 or IO 0"]
            #[inline(always)]
            pub fn fail0_sel(&mut self) -> Fail0SelW<Fail012Spec> {
                Fail0SelW::new(self, 0)
            }
            #[doc = "Bit 1 - Select from CMP1 or IO 1"]
            #[inline(always)]
            pub fn fail1_sel(&mut self) -> Fail1SelW<Fail012Spec> {
                Fail1SelW::new(self, 1)
            }
            #[doc = "Bit 2 - FAIL 0 active polarity"]
            #[inline(always)]
            pub fn fail0_pol(&mut self) -> Fail0PolW<Fail012Spec> {
                Fail0PolW::new(self, 2)
            }
            #[doc = "Bit 3 - FAIL 1 active polarity"]
            #[inline(always)]
            pub fn fail1_pol(&mut self) -> Fail1PolW<Fail012Spec> {
                Fail1PolW::new(self, 3)
            }
            #[doc = "Bit 4 - FAIL 0 Short Protect Enable or Not"]
            #[inline(always)]
            pub fn fail0_en(&mut self) -> Fail0EnW<Fail012Spec> {
                Fail0EnW::new(self, 4)
            }
            #[doc = "Bit 5 - FAIL 1 Short Protect Enable or Not"]
            #[inline(always)]
            pub fn fail1_en(&mut self) -> Fail1EnW<Fail012Spec> {
                Fail1EnW::new(self, 5)
            }
            #[doc = "Bit 6 - MCPWM Output Enable"]
            #[inline(always)]
            pub fn moe(&mut self) -> MoeW<Fail012Spec> {
                MoeW::new(self, 6)
            }
            #[doc = "Bit 7 - MCU in Debug Mode(Halted by Debug), MCPWM Close or Not"]
            #[inline(always)]
            pub fn halt_prt(&mut self) -> HaltPrtW<Fail012Spec> {
                HaltPrtW::new(self, 7)
            }
            #[doc = "Bit 8 - CH0_N Default Value"]
            #[inline(always)]
            pub fn ch0n_default(&mut self) -> Ch0nDefaultW<Fail012Spec> {
                Ch0nDefaultW::new(self, 8)
            }
            #[doc = "Bit 9 - CH0_P Default Value"]
            #[inline(always)]
            pub fn ch0p_default(&mut self) -> Ch0pDefaultW<Fail012Spec> {
                Ch0pDefaultW::new(self, 9)
            }
            #[doc = "Bit 10 - CH1_N Default Value"]
            #[inline(always)]
            pub fn ch1n_default(&mut self) -> Ch1nDefaultW<Fail012Spec> {
                Ch1nDefaultW::new(self, 10)
            }
            #[doc = "Bit 11 - CH1_P Default Value"]
            #[inline(always)]
            pub fn ch1p_default(&mut self) -> Ch1pDefaultW<Fail012Spec> {
                Ch1pDefaultW::new(self, 11)
            }
            #[doc = "Bit 12 - CH2_N Default Value"]
            #[inline(always)]
            pub fn ch2n_default(&mut self) -> Ch2nDefaultW<Fail012Spec> {
                Ch2nDefaultW::new(self, 12)
            }
            #[doc = "Bit 13 - CH2_P Default Value"]
            #[inline(always)]
            pub fn ch2p_default(&mut self) -> Ch2pDefaultW<Fail012Spec> {
                Ch2pDefaultW::new(self, 13)
            }
            #[doc = "Bit 15 - Save Counter0 to MCPWM_FCNT during fail0/1 event"]
            #[inline(always)]
            pub fn fail_0cap(&mut self) -> Fail0capW<Fail012Spec> {
                Fail0capW::new(self, 15)
            }
        }
        #[doc = "MCPWM Channel 012 Short Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fail012::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fail012::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fail012Spec;
        impl crate::RegisterSpec for Fail012Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fail012::R`](R) reader structure"]
        impl crate::Readable for Fail012Spec {}
        #[doc = "`write(|w| ..)` method takes [`fail012::W`](W) writer structure"]
        impl crate::Writable for Fail012Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FAIL012 to value 0"]
        impl crate::Resettable for Fail012Spec {}
    }
    #[doc = "FAIL3 (rw) register accessor: MCPWM Channel 3 Short Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fail3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fail3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fail3`] module"]
    #[doc(alias = "FAIL3")]
    pub type Fail3 = crate::Reg<fail3::Fail3Spec>;
    #[doc = "MCPWM Channel 3 Short Control Register"]
    pub mod fail3 {
        #[doc = "Register `FAIL3` reader"]
        pub type R = crate::R<Fail3Spec>;
        #[doc = "Register `FAIL3` writer"]
        pub type W = crate::W<Fail3Spec>;
        #[doc = "Field `FAIL2_SEL` reader - Select from CMP0 or IO 0"]
        pub type Fail2SelR = crate::BitReader;
        #[doc = "Field `FAIL2_SEL` writer - Select from CMP0 or IO 0"]
        pub type Fail2SelW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL3_SEL` reader - Select from CMP1 or IO 1"]
        pub type Fail3SelR = crate::BitReader;
        #[doc = "Field `FAIL3_SEL` writer - Select from CMP1 or IO 1"]
        pub type Fail3SelW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL2_POL` reader - FAIL 2 active polarity"]
        pub type Fail2PolR = crate::BitReader;
        #[doc = "Field `FAIL2_POL` writer - FAIL 2 active polarity"]
        pub type Fail2PolW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL3_POL` reader - FAIL 3 active polarity"]
        pub type Fail3PolR = crate::BitReader;
        #[doc = "Field `FAIL3_POL` writer - FAIL 3 active polarity"]
        pub type Fail3PolW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL2_EN` reader - FAIL 2 Short Protect Enable or Not"]
        pub type Fail2EnR = crate::BitReader;
        #[doc = "Field `FAIL2_EN` writer - FAIL 2 Short Protect Enable or Not"]
        pub type Fail2EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL3_EN` reader - FAIL 3 Short Protect Enable or Not"]
        pub type Fail3EnR = crate::BitReader;
        #[doc = "Field `FAIL3_EN` writer - FAIL 3 Short Protect Enable or Not"]
        pub type Fail3EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MOE` reader - MCPWM Output Enable"]
        pub type MoeR = crate::BitReader;
        #[doc = "Field `MOE` writer - MCPWM Output Enable"]
        pub type MoeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HALT_PRT` reader - MCU in Debug Mode(Halted by Debug), MCPWM Close or Not"]
        pub type HaltPrtR = crate::BitReader;
        #[doc = "Field `HALT_PRT` writer - MCU in Debug Mode(Halted by Debug), MCPWM Close or Not"]
        pub type HaltPrtW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3N_DEFAULT` reader - CH3_N Default Value"]
        pub type Ch3nDefaultR = crate::BitReader;
        #[doc = "Field `CH3N_DEFAULT` writer - CH3_N Default Value"]
        pub type Ch3nDefaultW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3P_DEFAULT` reader - CH3_P Default Value"]
        pub type Ch3pDefaultR = crate::BitReader;
        #[doc = "Field `CH3P_DEFAULT` writer - CH3_P Default Value"]
        pub type Ch3pDefaultW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL_1CAP` reader - Save Counter1 to MCPWM_FCNT during fail2/3 event"]
        pub type Fail1capR = crate::BitReader;
        #[doc = "Field `FAIL_1CAP` writer - Save Counter1 to MCPWM_FCNT during fail2/3 event"]
        pub type Fail1capW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Select from CMP0 or IO 0"]
            #[inline(always)]
            pub fn fail2_sel(&self) -> Fail2SelR {
                Fail2SelR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Select from CMP1 or IO 1"]
            #[inline(always)]
            pub fn fail3_sel(&self) -> Fail3SelR {
                Fail3SelR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - FAIL 2 active polarity"]
            #[inline(always)]
            pub fn fail2_pol(&self) -> Fail2PolR {
                Fail2PolR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - FAIL 3 active polarity"]
            #[inline(always)]
            pub fn fail3_pol(&self) -> Fail3PolR {
                Fail3PolR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - FAIL 2 Short Protect Enable or Not"]
            #[inline(always)]
            pub fn fail2_en(&self) -> Fail2EnR {
                Fail2EnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - FAIL 3 Short Protect Enable or Not"]
            #[inline(always)]
            pub fn fail3_en(&self) -> Fail3EnR {
                Fail3EnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - MCPWM Output Enable"]
            #[inline(always)]
            pub fn moe(&self) -> MoeR {
                MoeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - MCU in Debug Mode(Halted by Debug), MCPWM Close or Not"]
            #[inline(always)]
            pub fn halt_prt(&self) -> HaltPrtR {
                HaltPrtR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - CH3_N Default Value"]
            #[inline(always)]
            pub fn ch3n_default(&self) -> Ch3nDefaultR {
                Ch3nDefaultR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - CH3_P Default Value"]
            #[inline(always)]
            pub fn ch3p_default(&self) -> Ch3pDefaultR {
                Ch3pDefaultR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 15 - Save Counter1 to MCPWM_FCNT during fail2/3 event"]
            #[inline(always)]
            pub fn fail_1cap(&self) -> Fail1capR {
                Fail1capR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Select from CMP0 or IO 0"]
            #[inline(always)]
            pub fn fail2_sel(&mut self) -> Fail2SelW<Fail3Spec> {
                Fail2SelW::new(self, 0)
            }
            #[doc = "Bit 1 - Select from CMP1 or IO 1"]
            #[inline(always)]
            pub fn fail3_sel(&mut self) -> Fail3SelW<Fail3Spec> {
                Fail3SelW::new(self, 1)
            }
            #[doc = "Bit 2 - FAIL 2 active polarity"]
            #[inline(always)]
            pub fn fail2_pol(&mut self) -> Fail2PolW<Fail3Spec> {
                Fail2PolW::new(self, 2)
            }
            #[doc = "Bit 3 - FAIL 3 active polarity"]
            #[inline(always)]
            pub fn fail3_pol(&mut self) -> Fail3PolW<Fail3Spec> {
                Fail3PolW::new(self, 3)
            }
            #[doc = "Bit 4 - FAIL 2 Short Protect Enable or Not"]
            #[inline(always)]
            pub fn fail2_en(&mut self) -> Fail2EnW<Fail3Spec> {
                Fail2EnW::new(self, 4)
            }
            #[doc = "Bit 5 - FAIL 3 Short Protect Enable or Not"]
            #[inline(always)]
            pub fn fail3_en(&mut self) -> Fail3EnW<Fail3Spec> {
                Fail3EnW::new(self, 5)
            }
            #[doc = "Bit 6 - MCPWM Output Enable"]
            #[inline(always)]
            pub fn moe(&mut self) -> MoeW<Fail3Spec> {
                MoeW::new(self, 6)
            }
            #[doc = "Bit 7 - MCU in Debug Mode(Halted by Debug), MCPWM Close or Not"]
            #[inline(always)]
            pub fn halt_prt(&mut self) -> HaltPrtW<Fail3Spec> {
                HaltPrtW::new(self, 7)
            }
            #[doc = "Bit 8 - CH3_N Default Value"]
            #[inline(always)]
            pub fn ch3n_default(&mut self) -> Ch3nDefaultW<Fail3Spec> {
                Ch3nDefaultW::new(self, 8)
            }
            #[doc = "Bit 9 - CH3_P Default Value"]
            #[inline(always)]
            pub fn ch3p_default(&mut self) -> Ch3pDefaultW<Fail3Spec> {
                Ch3pDefaultW::new(self, 9)
            }
            #[doc = "Bit 15 - Save Counter1 to MCPWM_FCNT during fail2/3 event"]
            #[inline(always)]
            pub fn fail_1cap(&mut self) -> Fail1capW<Fail3Spec> {
                Fail1capW::new(self, 15)
            }
        }
        #[doc = "MCPWM Channel 3 Short Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fail3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fail3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fail3Spec;
        impl crate::RegisterSpec for Fail3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fail3::R`](R) reader structure"]
        impl crate::Readable for Fail3Spec {}
        #[doc = "`write(|w| ..)` method takes [`fail3::W`](W) writer structure"]
        impl crate::Writable for Fail3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FAIL3 to value 0"]
        impl crate::Resettable for Fail3Spec {}
    }
    #[doc = "PRT (w) register accessor: MCPWM Register Protection.Write 0xDEAD to unlock Protect\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prt::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@prt`] module"]
    #[doc(alias = "PRT")]
    pub type Prt = crate::Reg<prt::PrtSpec>;
    #[doc = "MCPWM Register Protection.Write 0xDEAD to unlock Protect"]
    pub mod prt {
        #[doc = "Register `PRT` writer"]
        pub type W = crate::W<PrtSpec>;
        impl core::fmt::Debug for crate::generic::Reg<PrtSpec> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {}
        #[doc = "MCPWM Register Protection.Write 0xDEAD to unlock Protect\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prt::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PrtSpec;
        impl crate::RegisterSpec for PrtSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`prt::W`](W) writer structure"]
        impl crate::Writable for PrtSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PRT to value 0"]
        impl crate::Resettable for PrtSpec {}
    }
    #[doc = "SWAP (rw) register accessor: MCPWM channel swap\n\nYou can [`read`](crate::Reg::read) this register and get [`swap::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swap::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@swap`] module"]
    #[doc(alias = "SWAP")]
    pub type Swap = crate::Reg<swap::SwapSpec>;
    #[doc = "MCPWM channel swap"]
    pub mod swap {
        #[doc = "Register `SWAP` reader"]
        pub type R = crate::R<SwapSpec>;
        #[doc = "Register `SWAP` writer"]
        pub type W = crate::W<SwapSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "MCPWM channel swap\n\nYou can [`read`](crate::Reg::read) this register and get [`swap::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swap::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SwapSpec;
        impl crate::RegisterSpec for SwapSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`swap::R`](R) reader structure"]
        impl crate::Readable for SwapSpec {}
        #[doc = "`write(|w| ..)` method takes [`swap::W`](W) writer structure"]
        impl crate::Writable for SwapSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SWAP to value 0"]
        impl crate::Resettable for SwapSpec {}
    }
    #[doc = "CHMSK (rw) register accessor: MCPWM channel mask\n\nYou can [`read`](crate::Reg::read) this register and get [`chmsk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chmsk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@chmsk`] module"]
    #[doc(alias = "CHMSK")]
    pub type Chmsk = crate::Reg<chmsk::ChmskSpec>;
    #[doc = "MCPWM channel mask"]
    pub mod chmsk {
        #[doc = "Register `CHMSK` reader"]
        pub type R = crate::R<ChmskSpec>;
        #[doc = "Register `CHMSK` writer"]
        pub type W = crate::W<ChmskSpec>;
        #[doc = "Field `CH0N_FAIL_EN` reader - Set ch0n to default during failure event"]
        pub type Ch0nFailEnR = crate::BitReader;
        #[doc = "Field `CH0N_FAIL_EN` writer - Set ch0n to default during failure event"]
        pub type Ch0nFailEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH0P_FAIL_EN` reader - Set ch0p to default during failure event"]
        pub type Ch0pFailEnR = crate::BitReader;
        #[doc = "Field `CH0P_FAIL_EN` writer - Set ch0p to default during failure event"]
        pub type Ch0pFailEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1N_FAIL_EN` reader - Set ch1n to default during failure event"]
        pub type Ch1nFailEnR = crate::BitReader;
        #[doc = "Field `CH1N_FAIL_EN` writer - Set ch1n to default during failure event"]
        pub type Ch1nFailEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1P_FAIL_EN` reader - Set ch1p to default during failure event"]
        pub type Ch1pFailEnR = crate::BitReader;
        #[doc = "Field `CH1P_FAIL_EN` writer - Set ch1p to default during failure event"]
        pub type Ch1pFailEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2N_FAIL_EN` reader - Set ch2n to default during failure event"]
        pub type Ch2nFailEnR = crate::BitReader;
        #[doc = "Field `CH2N_FAIL_EN` writer - Set ch2n to default during failure event"]
        pub type Ch2nFailEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2P_FAIL_EN` reader - Set ch2p to default during failure event"]
        pub type Ch2pFailEnR = crate::BitReader;
        #[doc = "Field `CH2P_FAIL_EN` writer - Set ch2p to default during failure event"]
        pub type Ch2pFailEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Set ch0n to default during failure event"]
            #[inline(always)]
            pub fn ch0n_fail_en(&self) -> Ch0nFailEnR {
                Ch0nFailEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Set ch0p to default during failure event"]
            #[inline(always)]
            pub fn ch0p_fail_en(&self) -> Ch0pFailEnR {
                Ch0pFailEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Set ch1n to default during failure event"]
            #[inline(always)]
            pub fn ch1n_fail_en(&self) -> Ch1nFailEnR {
                Ch1nFailEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Set ch1p to default during failure event"]
            #[inline(always)]
            pub fn ch1p_fail_en(&self) -> Ch1pFailEnR {
                Ch1pFailEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Set ch2n to default during failure event"]
            #[inline(always)]
            pub fn ch2n_fail_en(&self) -> Ch2nFailEnR {
                Ch2nFailEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Set ch2p to default during failure event"]
            #[inline(always)]
            pub fn ch2p_fail_en(&self) -> Ch2pFailEnR {
                Ch2pFailEnR::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Set ch0n to default during failure event"]
            #[inline(always)]
            pub fn ch0n_fail_en(&mut self) -> Ch0nFailEnW<ChmskSpec> {
                Ch0nFailEnW::new(self, 0)
            }
            #[doc = "Bit 1 - Set ch0p to default during failure event"]
            #[inline(always)]
            pub fn ch0p_fail_en(&mut self) -> Ch0pFailEnW<ChmskSpec> {
                Ch0pFailEnW::new(self, 1)
            }
            #[doc = "Bit 2 - Set ch1n to default during failure event"]
            #[inline(always)]
            pub fn ch1n_fail_en(&mut self) -> Ch1nFailEnW<ChmskSpec> {
                Ch1nFailEnW::new(self, 2)
            }
            #[doc = "Bit 3 - Set ch1p to default during failure event"]
            #[inline(always)]
            pub fn ch1p_fail_en(&mut self) -> Ch1pFailEnW<ChmskSpec> {
                Ch1pFailEnW::new(self, 3)
            }
            #[doc = "Bit 4 - Set ch2n to default during failure event"]
            #[inline(always)]
            pub fn ch2n_fail_en(&mut self) -> Ch2nFailEnW<ChmskSpec> {
                Ch2nFailEnW::new(self, 4)
            }
            #[doc = "Bit 5 - Set ch2p to default during failure event"]
            #[inline(always)]
            pub fn ch2p_fail_en(&mut self) -> Ch2pFailEnW<ChmskSpec> {
                Ch2pFailEnW::new(self, 5)
            }
        }
        #[doc = "MCPWM channel mask\n\nYou can [`read`](crate::Reg::read) this register and get [`chmsk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chmsk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ChmskSpec;
        impl crate::RegisterSpec for ChmskSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`chmsk::R`](R) reader structure"]
        impl crate::Readable for ChmskSpec {}
        #[doc = "`write(|w| ..)` method takes [`chmsk::W`](W) writer structure"]
        impl crate::Writable for ChmskSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CHMSK to value 0"]
        impl crate::Resettable for ChmskSpec {}
    }
}
#[doc = "GPIO0 registers"]
pub type Gpio0 = crate::Periph<gpio0::RegisterBlock, 0x4001_0800>;
impl core::fmt::Debug for Gpio0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio0").finish()
    }
}
#[doc = "GPIO0 registers"]
pub mod gpio0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        pie: Pie,
        poe: Poe,
        pdi: Pdi,
        pdo: Pdo,
        pue: Pue,
        _reserved5: [u8; 0x04],
        pode: Pode,
        pflt: Pflt,
        f3210: F3210,
        f7654: F7654,
        fba98: Fba98,
        ffedc: Ffedc,
        bsrr: Bsrr,
        brr: Brr,
    }
    impl RegisterBlock {
        #[doc = "0x00 - GPIO0 input enable"]
        #[inline(always)]
        pub const fn pie(&self) -> &Pie {
            &self.pie
        }
        #[doc = "0x04 - GPIO0 output enable"]
        #[inline(always)]
        pub const fn poe(&self) -> &Poe {
            &self.poe
        }
        #[doc = "0x08 - GPIO0 input data"]
        #[inline(always)]
        pub const fn pdi(&self) -> &Pdi {
            &self.pdi
        }
        #[doc = "0x0c - GPIO0 output data"]
        #[inline(always)]
        pub const fn pdo(&self) -> &Pdo {
            &self.pdo
        }
        #[doc = "0x10 - GPIO0 pull-up enable"]
        #[inline(always)]
        pub const fn pue(&self) -> &Pue {
            &self.pue
        }
        #[doc = "0x18 - GPIO0 open drain enable"]
        #[inline(always)]
        pub const fn pode(&self) -> &Pode {
            &self.pode
        }
        #[doc = "0x1c - GPIO0 filter enable"]
        #[inline(always)]
        pub const fn pflt(&self) -> &Pflt {
            &self.pflt
        }
        #[doc = "0x20 - GPIO0\\[3:0\\] function selection"]
        #[inline(always)]
        pub const fn f3210(&self) -> &F3210 {
            &self.f3210
        }
        #[doc = "0x24 - GPIO0\\[7:4\\] function selection"]
        #[inline(always)]
        pub const fn f7654(&self) -> &F7654 {
            &self.f7654
        }
        #[doc = "0x28 - GPIO0\\[11:8\\] function selection"]
        #[inline(always)]
        pub const fn fba98(&self) -> &Fba98 {
            &self.fba98
        }
        #[doc = "0x2c - GPIO0\\[15:12\\] function selection"]
        #[inline(always)]
        pub const fn ffedc(&self) -> &Ffedc {
            &self.ffedc
        }
        #[doc = "0x30 - GPIO0 bit set reset reg"]
        #[inline(always)]
        pub const fn bsrr(&self) -> &Bsrr {
            &self.bsrr
        }
        #[doc = "0x34 - GPIO0 bit reset reg"]
        #[inline(always)]
        pub const fn brr(&self) -> &Brr {
            &self.brr
        }
    }
    #[doc = "PIE (rw) register accessor: GPIO0 input enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pie`] module"]
    #[doc(alias = "PIE")]
    pub type Pie = crate::Reg<pie::PieSpec>;
    #[doc = "GPIO0 input enable"]
    pub mod pie {
        #[doc = "Register `PIE` reader"]
        pub type R = crate::R<PieSpec>;
        #[doc = "Register `PIE` writer"]
        pub type W = crate::W<PieSpec>;
        #[doc = "Field `PIE` reader - GPIO0\\[n\\] input enable"]
        pub type PieR = crate::FieldReader<u16>;
        #[doc = "Field `PIE` writer - GPIO0\\[n\\] input enable"]
        pub type PieW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] input enable"]
            #[inline(always)]
            pub fn pie(&self) -> PieR {
                PieR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] input enable"]
            #[inline(always)]
            pub fn pie(&mut self) -> PieW<PieSpec> {
                PieW::new(self, 0)
            }
        }
        #[doc = "GPIO0 input enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PieSpec;
        impl crate::RegisterSpec for PieSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pie::R`](R) reader structure"]
        impl crate::Readable for PieSpec {}
        #[doc = "`write(|w| ..)` method takes [`pie::W`](W) writer structure"]
        impl crate::Writable for PieSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PIE to value 0"]
        impl crate::Resettable for PieSpec {}
    }
    #[doc = "POE (rw) register accessor: GPIO0 output enable\n\nYou can [`read`](crate::Reg::read) this register and get [`poe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`poe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@poe`] module"]
    #[doc(alias = "POE")]
    pub type Poe = crate::Reg<poe::PoeSpec>;
    #[doc = "GPIO0 output enable"]
    pub mod poe {
        #[doc = "Register `POE` reader"]
        pub type R = crate::R<PoeSpec>;
        #[doc = "Register `POE` writer"]
        pub type W = crate::W<PoeSpec>;
        #[doc = "Field `POE` reader - GPIO0\\[n\\] output enable"]
        pub type PoeR = crate::FieldReader<u16>;
        #[doc = "Field `POE` writer - GPIO0\\[n\\] output enable"]
        pub type PoeW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] output enable"]
            #[inline(always)]
            pub fn poe(&self) -> PoeR {
                PoeR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] output enable"]
            #[inline(always)]
            pub fn poe(&mut self) -> PoeW<PoeSpec> {
                PoeW::new(self, 0)
            }
        }
        #[doc = "GPIO0 output enable\n\nYou can [`read`](crate::Reg::read) this register and get [`poe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`poe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PoeSpec;
        impl crate::RegisterSpec for PoeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`poe::R`](R) reader structure"]
        impl crate::Readable for PoeSpec {}
        #[doc = "`write(|w| ..)` method takes [`poe::W`](W) writer structure"]
        impl crate::Writable for PoeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets POE to value 0"]
        impl crate::Resettable for PoeSpec {}
    }
    #[doc = "PDI (rw) register accessor: GPIO0 input data\n\nYou can [`read`](crate::Reg::read) this register and get [`pdi::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdi::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdi`] module"]
    #[doc(alias = "PDI")]
    pub type Pdi = crate::Reg<pdi::PdiSpec>;
    #[doc = "GPIO0 input data"]
    pub mod pdi {
        #[doc = "Register `PDI` reader"]
        pub type R = crate::R<PdiSpec>;
        #[doc = "Register `PDI` writer"]
        pub type W = crate::W<PdiSpec>;
        #[doc = "Field `PDI` reader - GPIO0\\[n\\] input data"]
        pub type PdiR = crate::FieldReader<u16>;
        #[doc = "Field `PDI` writer - GPIO0\\[n\\] input data"]
        pub type PdiW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] input data"]
            #[inline(always)]
            pub fn pdi(&self) -> PdiR {
                PdiR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] input data"]
            #[inline(always)]
            pub fn pdi(&mut self) -> PdiW<PdiSpec> {
                PdiW::new(self, 0)
            }
        }
        #[doc = "GPIO0 input data\n\nYou can [`read`](crate::Reg::read) this register and get [`pdi::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdi::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PdiSpec;
        impl crate::RegisterSpec for PdiSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pdi::R`](R) reader structure"]
        impl crate::Readable for PdiSpec {}
        #[doc = "`write(|w| ..)` method takes [`pdi::W`](W) writer structure"]
        impl crate::Writable for PdiSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PDI to value 0"]
        impl crate::Resettable for PdiSpec {}
    }
    #[doc = "PDO (rw) register accessor: GPIO0 output data\n\nYou can [`read`](crate::Reg::read) this register and get [`pdo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdo`] module"]
    #[doc(alias = "PDO")]
    pub type Pdo = crate::Reg<pdo::PdoSpec>;
    #[doc = "GPIO0 output data"]
    pub mod pdo {
        #[doc = "Register `PDO` reader"]
        pub type R = crate::R<PdoSpec>;
        #[doc = "Register `PDO` writer"]
        pub type W = crate::W<PdoSpec>;
        #[doc = "Field `PDO` reader - GPIO0\\[n\\] output data"]
        pub type PdoR = crate::FieldReader<u16>;
        #[doc = "Field `PDO` writer - GPIO0\\[n\\] output data"]
        pub type PdoW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] output data"]
            #[inline(always)]
            pub fn pdo(&self) -> PdoR {
                PdoR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] output data"]
            #[inline(always)]
            pub fn pdo(&mut self) -> PdoW<PdoSpec> {
                PdoW::new(self, 0)
            }
        }
        #[doc = "GPIO0 output data\n\nYou can [`read`](crate::Reg::read) this register and get [`pdo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PdoSpec;
        impl crate::RegisterSpec for PdoSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pdo::R`](R) reader structure"]
        impl crate::Readable for PdoSpec {}
        #[doc = "`write(|w| ..)` method takes [`pdo::W`](W) writer structure"]
        impl crate::Writable for PdoSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PDO to value 0"]
        impl crate::Resettable for PdoSpec {}
    }
    #[doc = "PUE (rw) register accessor: GPIO0 pull-up enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pue::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pue::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pue`] module"]
    #[doc(alias = "PUE")]
    pub type Pue = crate::Reg<pue::PueSpec>;
    #[doc = "GPIO0 pull-up enable"]
    pub mod pue {
        #[doc = "Register `PUE` reader"]
        pub type R = crate::R<PueSpec>;
        #[doc = "Register `PUE` writer"]
        pub type W = crate::W<PueSpec>;
        #[doc = "Field `PUE` reader - GPIO0\\[n\\] pull-up enable"]
        pub type PueR = crate::FieldReader<u16>;
        #[doc = "Field `PUE` writer - GPIO0\\[n\\] pull-up enable"]
        pub type PueW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] pull-up enable"]
            #[inline(always)]
            pub fn pue(&self) -> PueR {
                PueR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] pull-up enable"]
            #[inline(always)]
            pub fn pue(&mut self) -> PueW<PueSpec> {
                PueW::new(self, 0)
            }
        }
        #[doc = "GPIO0 pull-up enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pue::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pue::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PueSpec;
        impl crate::RegisterSpec for PueSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pue::R`](R) reader structure"]
        impl crate::Readable for PueSpec {}
        #[doc = "`write(|w| ..)` method takes [`pue::W`](W) writer structure"]
        impl crate::Writable for PueSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PUE to value 0"]
        impl crate::Resettable for PueSpec {}
    }
    #[doc = "PODE (rw) register accessor: GPIO0 open drain enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pode`] module"]
    #[doc(alias = "PODE")]
    pub type Pode = crate::Reg<pode::PodeSpec>;
    #[doc = "GPIO0 open drain enable"]
    pub mod pode {
        #[doc = "Register `PODE` reader"]
        pub type R = crate::R<PodeSpec>;
        #[doc = "Register `PODE` writer"]
        pub type W = crate::W<PodeSpec>;
        #[doc = "Field `PODE` reader - GPIO0\\[n\\] open drain enable"]
        pub type PodeR = crate::FieldReader<u16>;
        #[doc = "Field `PODE` writer - GPIO0\\[n\\] open drain enable"]
        pub type PodeW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] open drain enable"]
            #[inline(always)]
            pub fn pode(&self) -> PodeR {
                PodeR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] open drain enable"]
            #[inline(always)]
            pub fn pode(&mut self) -> PodeW<PodeSpec> {
                PodeW::new(self, 0)
            }
        }
        #[doc = "GPIO0 open drain enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PodeSpec;
        impl crate::RegisterSpec for PodeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pode::R`](R) reader structure"]
        impl crate::Readable for PodeSpec {}
        #[doc = "`write(|w| ..)` method takes [`pode::W`](W) writer structure"]
        impl crate::Writable for PodeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PODE to value 0"]
        impl crate::Resettable for PodeSpec {}
    }
    #[doc = "PFLT (rw) register accessor: GPIO0 filter enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pflt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pflt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pflt`] module"]
    #[doc(alias = "PFLT")]
    pub type Pflt = crate::Reg<pflt::PfltSpec>;
    #[doc = "GPIO0 filter enable"]
    pub mod pflt {
        #[doc = "Register `PFLT` reader"]
        pub type R = crate::R<PfltSpec>;
        #[doc = "Register `PFLT` writer"]
        pub type W = crate::W<PfltSpec>;
        #[doc = "Field `PFLT` reader - GPIO0\\[n\\] filter enable"]
        pub type PfltR = crate::FieldReader<u16>;
        #[doc = "Field `PFLT` writer - GPIO0\\[n\\] filter enable"]
        pub type PfltW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] filter enable"]
            #[inline(always)]
            pub fn pflt(&self) -> PfltR {
                PfltR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] filter enable"]
            #[inline(always)]
            pub fn pflt(&mut self) -> PfltW<PfltSpec> {
                PfltW::new(self, 0)
            }
        }
        #[doc = "GPIO0 filter enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pflt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pflt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PfltSpec;
        impl crate::RegisterSpec for PfltSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pflt::R`](R) reader structure"]
        impl crate::Readable for PfltSpec {}
        #[doc = "`write(|w| ..)` method takes [`pflt::W`](W) writer structure"]
        impl crate::Writable for PfltSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PFLT to value 0"]
        impl crate::Resettable for PfltSpec {}
    }
    #[doc = "F3210 (rw) register accessor: GPIO0\\[3:0\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`f3210::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f3210::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f3210`] module"]
    pub type F3210 = crate::Reg<f3210::F3210Spec>;
    #[doc = "GPIO0\\[3:0\\] function selection"]
    pub mod f3210 {
        #[doc = "Register `F3210` reader"]
        pub type R = crate::R<F3210Spec>;
        #[doc = "Register `F3210` writer"]
        pub type W = crate::W<F3210Spec>;
        #[doc = "Field `F0` reader - GPIO0\\[0\\] function selection"]
        pub type F0R = crate::FieldReader;
        #[doc = "Field `F0` writer - GPIO0\\[0\\] function selection"]
        pub type F0W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F1` reader - GPIO0\\[1\\] function selection"]
        pub type F1R = crate::FieldReader;
        #[doc = "Field `F1` writer - GPIO0\\[1\\] function selection"]
        pub type F1W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F2` reader - GPIO0\\[2\\] function selection"]
        pub type F2R = crate::FieldReader;
        #[doc = "Field `F2` writer - GPIO0\\[2\\] function selection"]
        pub type F2W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F3` reader - GPIO0\\[3\\] function selection"]
        pub type F3R = crate::FieldReader;
        #[doc = "Field `F3` writer - GPIO0\\[3\\] function selection"]
        pub type F3W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - GPIO0\\[0\\] function selection"]
            #[inline(always)]
            pub fn f0(&self) -> F0R {
                F0R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - GPIO0\\[1\\] function selection"]
            #[inline(always)]
            pub fn f1(&self) -> F1R {
                F1R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - GPIO0\\[2\\] function selection"]
            #[inline(always)]
            pub fn f2(&self) -> F2R {
                F2R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - GPIO0\\[3\\] function selection"]
            #[inline(always)]
            pub fn f3(&self) -> F3R {
                F3R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - GPIO0\\[0\\] function selection"]
            #[inline(always)]
            pub fn f0(&mut self) -> F0W<F3210Spec> {
                F0W::new(self, 0)
            }
            #[doc = "Bits 4:7 - GPIO0\\[1\\] function selection"]
            #[inline(always)]
            pub fn f1(&mut self) -> F1W<F3210Spec> {
                F1W::new(self, 4)
            }
            #[doc = "Bits 8:11 - GPIO0\\[2\\] function selection"]
            #[inline(always)]
            pub fn f2(&mut self) -> F2W<F3210Spec> {
                F2W::new(self, 8)
            }
            #[doc = "Bits 12:15 - GPIO0\\[3\\] function selection"]
            #[inline(always)]
            pub fn f3(&mut self) -> F3W<F3210Spec> {
                F3W::new(self, 12)
            }
        }
        #[doc = "GPIO0\\[3:0\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`f3210::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f3210::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct F3210Spec;
        impl crate::RegisterSpec for F3210Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`f3210::R`](R) reader structure"]
        impl crate::Readable for F3210Spec {}
        #[doc = "`write(|w| ..)` method takes [`f3210::W`](W) writer structure"]
        impl crate::Writable for F3210Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets F3210 to value 0"]
        impl crate::Resettable for F3210Spec {}
    }
    #[doc = "F7654 (rw) register accessor: GPIO0\\[7:4\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`f7654::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f7654::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f7654`] module"]
    pub type F7654 = crate::Reg<f7654::F7654Spec>;
    #[doc = "GPIO0\\[7:4\\] function selection"]
    pub mod f7654 {
        #[doc = "Register `F7654` reader"]
        pub type R = crate::R<F7654Spec>;
        #[doc = "Register `F7654` writer"]
        pub type W = crate::W<F7654Spec>;
        #[doc = "Field `F4` reader - GPIO0\\[4\\] function selection"]
        pub type F4R = crate::FieldReader;
        #[doc = "Field `F4` writer - GPIO0\\[4\\] function selection"]
        pub type F4W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F5` reader - GPIO0\\[5\\] function selection"]
        pub type F5R = crate::FieldReader;
        #[doc = "Field `F5` writer - GPIO0\\[5\\] function selection"]
        pub type F5W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F6` reader - GPIO0\\[6\\] function selection"]
        pub type F6R = crate::FieldReader;
        #[doc = "Field `F6` writer - GPIO0\\[6\\] function selection"]
        pub type F6W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F7` reader - GPIO0\\[7\\] function selection"]
        pub type F7R = crate::FieldReader;
        #[doc = "Field `F7` writer - GPIO0\\[7\\] function selection"]
        pub type F7W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - GPIO0\\[4\\] function selection"]
            #[inline(always)]
            pub fn f4(&self) -> F4R {
                F4R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - GPIO0\\[5\\] function selection"]
            #[inline(always)]
            pub fn f5(&self) -> F5R {
                F5R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - GPIO0\\[6\\] function selection"]
            #[inline(always)]
            pub fn f6(&self) -> F6R {
                F6R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - GPIO0\\[7\\] function selection"]
            #[inline(always)]
            pub fn f7(&self) -> F7R {
                F7R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - GPIO0\\[4\\] function selection"]
            #[inline(always)]
            pub fn f4(&mut self) -> F4W<F7654Spec> {
                F4W::new(self, 0)
            }
            #[doc = "Bits 4:7 - GPIO0\\[5\\] function selection"]
            #[inline(always)]
            pub fn f5(&mut self) -> F5W<F7654Spec> {
                F5W::new(self, 4)
            }
            #[doc = "Bits 8:11 - GPIO0\\[6\\] function selection"]
            #[inline(always)]
            pub fn f6(&mut self) -> F6W<F7654Spec> {
                F6W::new(self, 8)
            }
            #[doc = "Bits 12:15 - GPIO0\\[7\\] function selection"]
            #[inline(always)]
            pub fn f7(&mut self) -> F7W<F7654Spec> {
                F7W::new(self, 12)
            }
        }
        #[doc = "GPIO0\\[7:4\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`f7654::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f7654::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct F7654Spec;
        impl crate::RegisterSpec for F7654Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`f7654::R`](R) reader structure"]
        impl crate::Readable for F7654Spec {}
        #[doc = "`write(|w| ..)` method takes [`f7654::W`](W) writer structure"]
        impl crate::Writable for F7654Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets F7654 to value 0"]
        impl crate::Resettable for F7654Spec {}
    }
    #[doc = "FBA98 (rw) register accessor: GPIO0\\[11:8\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`fba98::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fba98::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fba98`] module"]
    #[doc(alias = "FBA98")]
    pub type Fba98 = crate::Reg<fba98::Fba98Spec>;
    #[doc = "GPIO0\\[11:8\\] function selection"]
    pub mod fba98 {
        #[doc = "Register `FBA98` reader"]
        pub type R = crate::R<Fba98Spec>;
        #[doc = "Register `FBA98` writer"]
        pub type W = crate::W<Fba98Spec>;
        #[doc = "Field `F8` reader - GPIO0\\[8\\] function selection"]
        pub type F8R = crate::FieldReader;
        #[doc = "Field `F8` writer - GPIO0\\[8\\] function selection"]
        pub type F8W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F9` reader - GPIO0\\[9\\] function selection"]
        pub type F9R = crate::FieldReader;
        #[doc = "Field `F9` writer - GPIO0\\[9\\] function selection"]
        pub type F9W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F10` reader - GPIO0\\[10\\] function selection"]
        pub type F10R = crate::FieldReader;
        #[doc = "Field `F10` writer - GPIO0\\[10\\] function selection"]
        pub type F10W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F11` reader - GPIO0\\[11\\] function selection"]
        pub type F11R = crate::FieldReader;
        #[doc = "Field `F11` writer - GPIO0\\[11\\] function selection"]
        pub type F11W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - GPIO0\\[8\\] function selection"]
            #[inline(always)]
            pub fn f8(&self) -> F8R {
                F8R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - GPIO0\\[9\\] function selection"]
            #[inline(always)]
            pub fn f9(&self) -> F9R {
                F9R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - GPIO0\\[10\\] function selection"]
            #[inline(always)]
            pub fn f10(&self) -> F10R {
                F10R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - GPIO0\\[11\\] function selection"]
            #[inline(always)]
            pub fn f11(&self) -> F11R {
                F11R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - GPIO0\\[8\\] function selection"]
            #[inline(always)]
            pub fn f8(&mut self) -> F8W<Fba98Spec> {
                F8W::new(self, 0)
            }
            #[doc = "Bits 4:7 - GPIO0\\[9\\] function selection"]
            #[inline(always)]
            pub fn f9(&mut self) -> F9W<Fba98Spec> {
                F9W::new(self, 4)
            }
            #[doc = "Bits 8:11 - GPIO0\\[10\\] function selection"]
            #[inline(always)]
            pub fn f10(&mut self) -> F10W<Fba98Spec> {
                F10W::new(self, 8)
            }
            #[doc = "Bits 12:15 - GPIO0\\[11\\] function selection"]
            #[inline(always)]
            pub fn f11(&mut self) -> F11W<Fba98Spec> {
                F11W::new(self, 12)
            }
        }
        #[doc = "GPIO0\\[11:8\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`fba98::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fba98::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fba98Spec;
        impl crate::RegisterSpec for Fba98Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fba98::R`](R) reader structure"]
        impl crate::Readable for Fba98Spec {}
        #[doc = "`write(|w| ..)` method takes [`fba98::W`](W) writer structure"]
        impl crate::Writable for Fba98Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FBA98 to value 0"]
        impl crate::Resettable for Fba98Spec {}
    }
    #[doc = "FFEDC (rw) register accessor: GPIO0\\[15:12\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`ffedc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ffedc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ffedc`] module"]
    #[doc(alias = "FFEDC")]
    pub type Ffedc = crate::Reg<ffedc::FfedcSpec>;
    #[doc = "GPIO0\\[15:12\\] function selection"]
    pub mod ffedc {
        #[doc = "Register `FFEDC` reader"]
        pub type R = crate::R<FfedcSpec>;
        #[doc = "Register `FFEDC` writer"]
        pub type W = crate::W<FfedcSpec>;
        #[doc = "Field `F12` reader - GPIO0\\[0\\] function selection"]
        pub type F12R = crate::FieldReader;
        #[doc = "Field `F12` writer - GPIO0\\[0\\] function selection"]
        pub type F12W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F13` reader - GPIO0\\[1\\] function selection"]
        pub type F13R = crate::FieldReader;
        #[doc = "Field `F13` writer - GPIO0\\[1\\] function selection"]
        pub type F13W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F14` reader - GPIO0\\[2\\] function selection"]
        pub type F14R = crate::FieldReader;
        #[doc = "Field `F14` writer - GPIO0\\[2\\] function selection"]
        pub type F14W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F15` reader - GPIO0\\[3\\] function selection"]
        pub type F15R = crate::FieldReader;
        #[doc = "Field `F15` writer - GPIO0\\[3\\] function selection"]
        pub type F15W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - GPIO0\\[0\\] function selection"]
            #[inline(always)]
            pub fn f12(&self) -> F12R {
                F12R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - GPIO0\\[1\\] function selection"]
            #[inline(always)]
            pub fn f13(&self) -> F13R {
                F13R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - GPIO0\\[2\\] function selection"]
            #[inline(always)]
            pub fn f14(&self) -> F14R {
                F14R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - GPIO0\\[3\\] function selection"]
            #[inline(always)]
            pub fn f15(&self) -> F15R {
                F15R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - GPIO0\\[0\\] function selection"]
            #[inline(always)]
            pub fn f12(&mut self) -> F12W<FfedcSpec> {
                F12W::new(self, 0)
            }
            #[doc = "Bits 4:7 - GPIO0\\[1\\] function selection"]
            #[inline(always)]
            pub fn f13(&mut self) -> F13W<FfedcSpec> {
                F13W::new(self, 4)
            }
            #[doc = "Bits 8:11 - GPIO0\\[2\\] function selection"]
            #[inline(always)]
            pub fn f14(&mut self) -> F14W<FfedcSpec> {
                F14W::new(self, 8)
            }
            #[doc = "Bits 12:15 - GPIO0\\[3\\] function selection"]
            #[inline(always)]
            pub fn f15(&mut self) -> F15W<FfedcSpec> {
                F15W::new(self, 12)
            }
        }
        #[doc = "GPIO0\\[15:12\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`ffedc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ffedc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FfedcSpec;
        impl crate::RegisterSpec for FfedcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ffedc::R`](R) reader structure"]
        impl crate::Readable for FfedcSpec {}
        #[doc = "`write(|w| ..)` method takes [`ffedc::W`](W) writer structure"]
        impl crate::Writable for FfedcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FFEDC to value 0"]
        impl crate::Resettable for FfedcSpec {}
    }
    #[doc = "BSRR (w) register accessor: GPIO0 bit set reset reg\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsrr`] module"]
    #[doc(alias = "BSRR")]
    pub type Bsrr = crate::Reg<bsrr::BsrrSpec>;
    #[doc = "GPIO0 bit set reset reg"]
    pub mod bsrr {
        #[doc = "Register `BSRR` writer"]
        pub type W = crate::W<BsrrSpec>;
        #[doc = "Field `SET` writer - GPIO0\\[n\\] write 1 to set"]
        pub type SetW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        #[doc = "Field `CLR` writer - GPIO0\\[n\\] write 1 to clear"]
        pub type ClrW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] write 1 to set"]
            #[inline(always)]
            pub fn set_(&mut self) -> SetW<BsrrSpec> {
                SetW::new(self, 0)
            }
            #[doc = "Bits 16:31 - GPIO0\\[n\\] write 1 to clear"]
            #[inline(always)]
            pub fn clr(&mut self) -> ClrW<BsrrSpec> {
                ClrW::new(self, 16)
            }
        }
        #[doc = "GPIO0 bit set reset reg\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BsrrSpec;
        impl crate::RegisterSpec for BsrrSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`bsrr::W`](W) writer structure"]
        impl crate::Writable for BsrrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BSRR to value 0"]
        impl crate::Resettable for BsrrSpec {}
    }
    #[doc = "BRR (w) register accessor: GPIO0 bit reset reg\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
    #[doc(alias = "BRR")]
    pub type Brr = crate::Reg<brr::BrrSpec>;
    #[doc = "GPIO0 bit reset reg"]
    pub mod brr {
        #[doc = "Register `BRR` writer"]
        pub type W = crate::W<BrrSpec>;
        #[doc = "Field `CLR` writer - GPIO0\\[n\\] write 1 to clear"]
        pub type ClrW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            #[doc = "Bits 0:15 - GPIO0\\[n\\] write 1 to clear"]
            #[inline(always)]
            pub fn clr(&mut self) -> ClrW<BrrSpec> {
                ClrW::new(self, 0)
            }
        }
        #[doc = "GPIO0 bit reset reg\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BrrSpec;
        impl crate::RegisterSpec for BrrSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"]
        impl crate::Writable for BrrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BRR to value 0"]
        impl crate::Resettable for BrrSpec {}
    }
}
#[doc = "GPIO1 registers"]
pub type Gpio1 = crate::Periph<gpio1::RegisterBlock, 0x4001_0840>;
impl core::fmt::Debug for Gpio1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio1").finish()
    }
}
#[doc = "GPIO1 registers"]
pub mod gpio1 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        pie: Pie,
        poe: Poe,
        pdi: Pdi,
        pdo: Pdo,
        pue: Pue,
        _reserved5: [u8; 0x04],
        pode: Pode,
        pflt: Pflt,
        f3210: F3210,
        f7654: F7654,
        fba98: Fba98,
        ffedc: Ffedc,
        bsrr: Bsrr,
        brr: Brr,
    }
    impl RegisterBlock {
        #[doc = "0x00 - GPIO1 input enable"]
        #[inline(always)]
        pub const fn pie(&self) -> &Pie {
            &self.pie
        }
        #[doc = "0x04 - GPIO1 output enable"]
        #[inline(always)]
        pub const fn poe(&self) -> &Poe {
            &self.poe
        }
        #[doc = "0x08 - GPIO1 input data"]
        #[inline(always)]
        pub const fn pdi(&self) -> &Pdi {
            &self.pdi
        }
        #[doc = "0x0c - GPIO1 output data"]
        #[inline(always)]
        pub const fn pdo(&self) -> &Pdo {
            &self.pdo
        }
        #[doc = "0x10 - GPIO1 pull-up enable"]
        #[inline(always)]
        pub const fn pue(&self) -> &Pue {
            &self.pue
        }
        #[doc = "0x18 - GPIO1 open drain enable"]
        #[inline(always)]
        pub const fn pode(&self) -> &Pode {
            &self.pode
        }
        #[doc = "0x1c - GPIO1 filter enable"]
        #[inline(always)]
        pub const fn pflt(&self) -> &Pflt {
            &self.pflt
        }
        #[doc = "0x20 - GPIO1\\[3:0\\] function selection"]
        #[inline(always)]
        pub const fn f3210(&self) -> &F3210 {
            &self.f3210
        }
        #[doc = "0x24 - GPIO1\\[7:4\\] function selection"]
        #[inline(always)]
        pub const fn f7654(&self) -> &F7654 {
            &self.f7654
        }
        #[doc = "0x28 - GPIO1\\[11:8\\] function selection"]
        #[inline(always)]
        pub const fn fba98(&self) -> &Fba98 {
            &self.fba98
        }
        #[doc = "0x2c - GPIO1\\[15:12\\] function selection"]
        #[inline(always)]
        pub const fn ffedc(&self) -> &Ffedc {
            &self.ffedc
        }
        #[doc = "0x30 - GPIO1 bit set reset reg"]
        #[inline(always)]
        pub const fn bsrr(&self) -> &Bsrr {
            &self.bsrr
        }
        #[doc = "0x34 - GPIO1 bit reset reg"]
        #[inline(always)]
        pub const fn brr(&self) -> &Brr {
            &self.brr
        }
    }
    #[doc = "PIE (rw) register accessor: GPIO1 input enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pie`] module"]
    #[doc(alias = "PIE")]
    pub type Pie = crate::Reg<pie::PieSpec>;
    #[doc = "GPIO1 input enable"]
    pub mod pie {
        #[doc = "Register `PIE` reader"]
        pub type R = crate::R<PieSpec>;
        #[doc = "Register `PIE` writer"]
        pub type W = crate::W<PieSpec>;
        #[doc = "Field `PIE` reader - GPIO1\\[n\\] input enable"]
        pub type PieR = crate::FieldReader<u16>;
        #[doc = "Field `PIE` writer - GPIO1\\[n\\] input enable"]
        pub type PieW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] input enable"]
            #[inline(always)]
            pub fn pie(&self) -> PieR {
                PieR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] input enable"]
            #[inline(always)]
            pub fn pie(&mut self) -> PieW<PieSpec> {
                PieW::new(self, 0)
            }
        }
        #[doc = "GPIO1 input enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PieSpec;
        impl crate::RegisterSpec for PieSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pie::R`](R) reader structure"]
        impl crate::Readable for PieSpec {}
        #[doc = "`write(|w| ..)` method takes [`pie::W`](W) writer structure"]
        impl crate::Writable for PieSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PIE to value 0"]
        impl crate::Resettable for PieSpec {}
    }
    #[doc = "POE (rw) register accessor: GPIO1 output enable\n\nYou can [`read`](crate::Reg::read) this register and get [`poe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`poe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@poe`] module"]
    #[doc(alias = "POE")]
    pub type Poe = crate::Reg<poe::PoeSpec>;
    #[doc = "GPIO1 output enable"]
    pub mod poe {
        #[doc = "Register `POE` reader"]
        pub type R = crate::R<PoeSpec>;
        #[doc = "Register `POE` writer"]
        pub type W = crate::W<PoeSpec>;
        #[doc = "Field `POE` reader - GPIO1\\[n\\] output enable"]
        pub type PoeR = crate::FieldReader<u16>;
        #[doc = "Field `POE` writer - GPIO1\\[n\\] output enable"]
        pub type PoeW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] output enable"]
            #[inline(always)]
            pub fn poe(&self) -> PoeR {
                PoeR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] output enable"]
            #[inline(always)]
            pub fn poe(&mut self) -> PoeW<PoeSpec> {
                PoeW::new(self, 0)
            }
        }
        #[doc = "GPIO1 output enable\n\nYou can [`read`](crate::Reg::read) this register and get [`poe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`poe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PoeSpec;
        impl crate::RegisterSpec for PoeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`poe::R`](R) reader structure"]
        impl crate::Readable for PoeSpec {}
        #[doc = "`write(|w| ..)` method takes [`poe::W`](W) writer structure"]
        impl crate::Writable for PoeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets POE to value 0"]
        impl crate::Resettable for PoeSpec {}
    }
    #[doc = "PDI (rw) register accessor: GPIO1 input data\n\nYou can [`read`](crate::Reg::read) this register and get [`pdi::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdi::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdi`] module"]
    #[doc(alias = "PDI")]
    pub type Pdi = crate::Reg<pdi::PdiSpec>;
    #[doc = "GPIO1 input data"]
    pub mod pdi {
        #[doc = "Register `PDI` reader"]
        pub type R = crate::R<PdiSpec>;
        #[doc = "Register `PDI` writer"]
        pub type W = crate::W<PdiSpec>;
        #[doc = "Field `PDI` reader - GPIO1\\[n\\] input data"]
        pub type PdiR = crate::FieldReader<u16>;
        #[doc = "Field `PDI` writer - GPIO1\\[n\\] input data"]
        pub type PdiW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] input data"]
            #[inline(always)]
            pub fn pdi(&self) -> PdiR {
                PdiR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] input data"]
            #[inline(always)]
            pub fn pdi(&mut self) -> PdiW<PdiSpec> {
                PdiW::new(self, 0)
            }
        }
        #[doc = "GPIO1 input data\n\nYou can [`read`](crate::Reg::read) this register and get [`pdi::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdi::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PdiSpec;
        impl crate::RegisterSpec for PdiSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pdi::R`](R) reader structure"]
        impl crate::Readable for PdiSpec {}
        #[doc = "`write(|w| ..)` method takes [`pdi::W`](W) writer structure"]
        impl crate::Writable for PdiSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PDI to value 0"]
        impl crate::Resettable for PdiSpec {}
    }
    #[doc = "PDO (rw) register accessor: GPIO1 output data\n\nYou can [`read`](crate::Reg::read) this register and get [`pdo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdo`] module"]
    #[doc(alias = "PDO")]
    pub type Pdo = crate::Reg<pdo::PdoSpec>;
    #[doc = "GPIO1 output data"]
    pub mod pdo {
        #[doc = "Register `PDO` reader"]
        pub type R = crate::R<PdoSpec>;
        #[doc = "Register `PDO` writer"]
        pub type W = crate::W<PdoSpec>;
        #[doc = "Field `PDO` reader - GPIO1\\[n\\] output data"]
        pub type PdoR = crate::FieldReader<u16>;
        #[doc = "Field `PDO` writer - GPIO1\\[n\\] output data"]
        pub type PdoW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] output data"]
            #[inline(always)]
            pub fn pdo(&self) -> PdoR {
                PdoR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] output data"]
            #[inline(always)]
            pub fn pdo(&mut self) -> PdoW<PdoSpec> {
                PdoW::new(self, 0)
            }
        }
        #[doc = "GPIO1 output data\n\nYou can [`read`](crate::Reg::read) this register and get [`pdo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PdoSpec;
        impl crate::RegisterSpec for PdoSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pdo::R`](R) reader structure"]
        impl crate::Readable for PdoSpec {}
        #[doc = "`write(|w| ..)` method takes [`pdo::W`](W) writer structure"]
        impl crate::Writable for PdoSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PDO to value 0"]
        impl crate::Resettable for PdoSpec {}
    }
    #[doc = "PUE (rw) register accessor: GPIO1 pull-up enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pue::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pue::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pue`] module"]
    #[doc(alias = "PUE")]
    pub type Pue = crate::Reg<pue::PueSpec>;
    #[doc = "GPIO1 pull-up enable"]
    pub mod pue {
        #[doc = "Register `PUE` reader"]
        pub type R = crate::R<PueSpec>;
        #[doc = "Register `PUE` writer"]
        pub type W = crate::W<PueSpec>;
        #[doc = "Field `PUE` reader - GPIO1\\[n\\] pull-up enable"]
        pub type PueR = crate::FieldReader<u16>;
        #[doc = "Field `PUE` writer - GPIO1\\[n\\] pull-up enable"]
        pub type PueW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] pull-up enable"]
            #[inline(always)]
            pub fn pue(&self) -> PueR {
                PueR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] pull-up enable"]
            #[inline(always)]
            pub fn pue(&mut self) -> PueW<PueSpec> {
                PueW::new(self, 0)
            }
        }
        #[doc = "GPIO1 pull-up enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pue::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pue::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PueSpec;
        impl crate::RegisterSpec for PueSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pue::R`](R) reader structure"]
        impl crate::Readable for PueSpec {}
        #[doc = "`write(|w| ..)` method takes [`pue::W`](W) writer structure"]
        impl crate::Writable for PueSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PUE to value 0"]
        impl crate::Resettable for PueSpec {}
    }
    #[doc = "PODE (rw) register accessor: GPIO1 open drain enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pode`] module"]
    #[doc(alias = "PODE")]
    pub type Pode = crate::Reg<pode::PodeSpec>;
    #[doc = "GPIO1 open drain enable"]
    pub mod pode {
        #[doc = "Register `PODE` reader"]
        pub type R = crate::R<PodeSpec>;
        #[doc = "Register `PODE` writer"]
        pub type W = crate::W<PodeSpec>;
        #[doc = "Field `PODE` reader - GPIO1\\[n\\] open drain enable"]
        pub type PodeR = crate::FieldReader<u16>;
        #[doc = "Field `PODE` writer - GPIO1\\[n\\] open drain enable"]
        pub type PodeW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] open drain enable"]
            #[inline(always)]
            pub fn pode(&self) -> PodeR {
                PodeR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] open drain enable"]
            #[inline(always)]
            pub fn pode(&mut self) -> PodeW<PodeSpec> {
                PodeW::new(self, 0)
            }
        }
        #[doc = "GPIO1 open drain enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PodeSpec;
        impl crate::RegisterSpec for PodeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pode::R`](R) reader structure"]
        impl crate::Readable for PodeSpec {}
        #[doc = "`write(|w| ..)` method takes [`pode::W`](W) writer structure"]
        impl crate::Writable for PodeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PODE to value 0"]
        impl crate::Resettable for PodeSpec {}
    }
    #[doc = "PFLT (rw) register accessor: GPIO1 filter enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pflt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pflt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pflt`] module"]
    #[doc(alias = "PFLT")]
    pub type Pflt = crate::Reg<pflt::PfltSpec>;
    #[doc = "GPIO1 filter enable"]
    pub mod pflt {
        #[doc = "Register `PFLT` reader"]
        pub type R = crate::R<PfltSpec>;
        #[doc = "Register `PFLT` writer"]
        pub type W = crate::W<PfltSpec>;
        #[doc = "Field `PFLT` reader - GPIO1\\[n\\] filter enable"]
        pub type PfltR = crate::FieldReader<u16>;
        #[doc = "Field `PFLT` writer - GPIO1\\[n\\] filter enable"]
        pub type PfltW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] filter enable"]
            #[inline(always)]
            pub fn pflt(&self) -> PfltR {
                PfltR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] filter enable"]
            #[inline(always)]
            pub fn pflt(&mut self) -> PfltW<PfltSpec> {
                PfltW::new(self, 0)
            }
        }
        #[doc = "GPIO1 filter enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pflt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pflt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PfltSpec;
        impl crate::RegisterSpec for PfltSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pflt::R`](R) reader structure"]
        impl crate::Readable for PfltSpec {}
        #[doc = "`write(|w| ..)` method takes [`pflt::W`](W) writer structure"]
        impl crate::Writable for PfltSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PFLT to value 0"]
        impl crate::Resettable for PfltSpec {}
    }
    #[doc = "F3210 (rw) register accessor: GPIO1\\[3:0\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`f3210::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f3210::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f3210`] module"]
    pub type F3210 = crate::Reg<f3210::F3210Spec>;
    #[doc = "GPIO1\\[3:0\\] function selection"]
    pub mod f3210 {
        #[doc = "Register `F3210` reader"]
        pub type R = crate::R<F3210Spec>;
        #[doc = "Register `F3210` writer"]
        pub type W = crate::W<F3210Spec>;
        #[doc = "Field `F0` reader - GPIO1\\[0\\] function selection"]
        pub type F0R = crate::FieldReader;
        #[doc = "Field `F0` writer - GPIO1\\[0\\] function selection"]
        pub type F0W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F1` reader - GPIO1\\[1\\] function selection"]
        pub type F1R = crate::FieldReader;
        #[doc = "Field `F1` writer - GPIO1\\[1\\] function selection"]
        pub type F1W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F2` reader - GPIO1\\[2\\] function selection"]
        pub type F2R = crate::FieldReader;
        #[doc = "Field `F2` writer - GPIO1\\[2\\] function selection"]
        pub type F2W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F3` reader - GPIO1\\[3\\] function selection"]
        pub type F3R = crate::FieldReader;
        #[doc = "Field `F3` writer - GPIO1\\[3\\] function selection"]
        pub type F3W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - GPIO1\\[0\\] function selection"]
            #[inline(always)]
            pub fn f0(&self) -> F0R {
                F0R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - GPIO1\\[1\\] function selection"]
            #[inline(always)]
            pub fn f1(&self) -> F1R {
                F1R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - GPIO1\\[2\\] function selection"]
            #[inline(always)]
            pub fn f2(&self) -> F2R {
                F2R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - GPIO1\\[3\\] function selection"]
            #[inline(always)]
            pub fn f3(&self) -> F3R {
                F3R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - GPIO1\\[0\\] function selection"]
            #[inline(always)]
            pub fn f0(&mut self) -> F0W<F3210Spec> {
                F0W::new(self, 0)
            }
            #[doc = "Bits 4:7 - GPIO1\\[1\\] function selection"]
            #[inline(always)]
            pub fn f1(&mut self) -> F1W<F3210Spec> {
                F1W::new(self, 4)
            }
            #[doc = "Bits 8:11 - GPIO1\\[2\\] function selection"]
            #[inline(always)]
            pub fn f2(&mut self) -> F2W<F3210Spec> {
                F2W::new(self, 8)
            }
            #[doc = "Bits 12:15 - GPIO1\\[3\\] function selection"]
            #[inline(always)]
            pub fn f3(&mut self) -> F3W<F3210Spec> {
                F3W::new(self, 12)
            }
        }
        #[doc = "GPIO1\\[3:0\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`f3210::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f3210::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct F3210Spec;
        impl crate::RegisterSpec for F3210Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`f3210::R`](R) reader structure"]
        impl crate::Readable for F3210Spec {}
        #[doc = "`write(|w| ..)` method takes [`f3210::W`](W) writer structure"]
        impl crate::Writable for F3210Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets F3210 to value 0"]
        impl crate::Resettable for F3210Spec {}
    }
    #[doc = "F7654 (rw) register accessor: GPIO1\\[7:4\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`f7654::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f7654::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f7654`] module"]
    pub type F7654 = crate::Reg<f7654::F7654Spec>;
    #[doc = "GPIO1\\[7:4\\] function selection"]
    pub mod f7654 {
        #[doc = "Register `F7654` reader"]
        pub type R = crate::R<F7654Spec>;
        #[doc = "Register `F7654` writer"]
        pub type W = crate::W<F7654Spec>;
        #[doc = "Field `F4` reader - GPIO1\\[4\\] function selection"]
        pub type F4R = crate::FieldReader;
        #[doc = "Field `F4` writer - GPIO1\\[4\\] function selection"]
        pub type F4W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F5` reader - GPIO1\\[5\\] function selection"]
        pub type F5R = crate::FieldReader;
        #[doc = "Field `F5` writer - GPIO1\\[5\\] function selection"]
        pub type F5W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F6` reader - GPIO1\\[6\\] function selection"]
        pub type F6R = crate::FieldReader;
        #[doc = "Field `F6` writer - GPIO1\\[6\\] function selection"]
        pub type F6W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F7` reader - GPIO1\\[7\\] function selection"]
        pub type F7R = crate::FieldReader;
        #[doc = "Field `F7` writer - GPIO1\\[7\\] function selection"]
        pub type F7W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - GPIO1\\[4\\] function selection"]
            #[inline(always)]
            pub fn f4(&self) -> F4R {
                F4R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - GPIO1\\[5\\] function selection"]
            #[inline(always)]
            pub fn f5(&self) -> F5R {
                F5R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - GPIO1\\[6\\] function selection"]
            #[inline(always)]
            pub fn f6(&self) -> F6R {
                F6R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - GPIO1\\[7\\] function selection"]
            #[inline(always)]
            pub fn f7(&self) -> F7R {
                F7R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - GPIO1\\[4\\] function selection"]
            #[inline(always)]
            pub fn f4(&mut self) -> F4W<F7654Spec> {
                F4W::new(self, 0)
            }
            #[doc = "Bits 4:7 - GPIO1\\[5\\] function selection"]
            #[inline(always)]
            pub fn f5(&mut self) -> F5W<F7654Spec> {
                F5W::new(self, 4)
            }
            #[doc = "Bits 8:11 - GPIO1\\[6\\] function selection"]
            #[inline(always)]
            pub fn f6(&mut self) -> F6W<F7654Spec> {
                F6W::new(self, 8)
            }
            #[doc = "Bits 12:15 - GPIO1\\[7\\] function selection"]
            #[inline(always)]
            pub fn f7(&mut self) -> F7W<F7654Spec> {
                F7W::new(self, 12)
            }
        }
        #[doc = "GPIO1\\[7:4\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`f7654::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f7654::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct F7654Spec;
        impl crate::RegisterSpec for F7654Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`f7654::R`](R) reader structure"]
        impl crate::Readable for F7654Spec {}
        #[doc = "`write(|w| ..)` method takes [`f7654::W`](W) writer structure"]
        impl crate::Writable for F7654Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets F7654 to value 0"]
        impl crate::Resettable for F7654Spec {}
    }
    #[doc = "FBA98 (rw) register accessor: GPIO1\\[11:8\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`fba98::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fba98::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fba98`] module"]
    #[doc(alias = "FBA98")]
    pub type Fba98 = crate::Reg<fba98::Fba98Spec>;
    #[doc = "GPIO1\\[11:8\\] function selection"]
    pub mod fba98 {
        #[doc = "Register `FBA98` reader"]
        pub type R = crate::R<Fba98Spec>;
        #[doc = "Register `FBA98` writer"]
        pub type W = crate::W<Fba98Spec>;
        #[doc = "Field `F8` reader - GPIO1\\[8\\] function selection"]
        pub type F8R = crate::FieldReader;
        #[doc = "Field `F8` writer - GPIO1\\[8\\] function selection"]
        pub type F8W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F9` reader - GPIO1\\[9\\] function selection"]
        pub type F9R = crate::FieldReader;
        #[doc = "Field `F9` writer - GPIO1\\[9\\] function selection"]
        pub type F9W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F10` reader - GPIO1\\[10\\] function selection"]
        pub type F10R = crate::FieldReader;
        #[doc = "Field `F10` writer - GPIO1\\[10\\] function selection"]
        pub type F10W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F11` reader - GPIO1\\[11\\] function selection"]
        pub type F11R = crate::FieldReader;
        #[doc = "Field `F11` writer - GPIO1\\[11\\] function selection"]
        pub type F11W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - GPIO1\\[8\\] function selection"]
            #[inline(always)]
            pub fn f8(&self) -> F8R {
                F8R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - GPIO1\\[9\\] function selection"]
            #[inline(always)]
            pub fn f9(&self) -> F9R {
                F9R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - GPIO1\\[10\\] function selection"]
            #[inline(always)]
            pub fn f10(&self) -> F10R {
                F10R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - GPIO1\\[11\\] function selection"]
            #[inline(always)]
            pub fn f11(&self) -> F11R {
                F11R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - GPIO1\\[8\\] function selection"]
            #[inline(always)]
            pub fn f8(&mut self) -> F8W<Fba98Spec> {
                F8W::new(self, 0)
            }
            #[doc = "Bits 4:7 - GPIO1\\[9\\] function selection"]
            #[inline(always)]
            pub fn f9(&mut self) -> F9W<Fba98Spec> {
                F9W::new(self, 4)
            }
            #[doc = "Bits 8:11 - GPIO1\\[10\\] function selection"]
            #[inline(always)]
            pub fn f10(&mut self) -> F10W<Fba98Spec> {
                F10W::new(self, 8)
            }
            #[doc = "Bits 12:15 - GPIO1\\[11\\] function selection"]
            #[inline(always)]
            pub fn f11(&mut self) -> F11W<Fba98Spec> {
                F11W::new(self, 12)
            }
        }
        #[doc = "GPIO1\\[11:8\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`fba98::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fba98::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fba98Spec;
        impl crate::RegisterSpec for Fba98Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fba98::R`](R) reader structure"]
        impl crate::Readable for Fba98Spec {}
        #[doc = "`write(|w| ..)` method takes [`fba98::W`](W) writer structure"]
        impl crate::Writable for Fba98Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FBA98 to value 0"]
        impl crate::Resettable for Fba98Spec {}
    }
    #[doc = "FFEDC (rw) register accessor: GPIO1\\[15:12\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`ffedc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ffedc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ffedc`] module"]
    #[doc(alias = "FFEDC")]
    pub type Ffedc = crate::Reg<ffedc::FfedcSpec>;
    #[doc = "GPIO1\\[15:12\\] function selection"]
    pub mod ffedc {
        #[doc = "Register `FFEDC` reader"]
        pub type R = crate::R<FfedcSpec>;
        #[doc = "Register `FFEDC` writer"]
        pub type W = crate::W<FfedcSpec>;
        #[doc = "Field `F12` reader - GPIO1\\[0\\] function selection"]
        pub type F12R = crate::FieldReader;
        #[doc = "Field `F12` writer - GPIO1\\[0\\] function selection"]
        pub type F12W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F13` reader - GPIO1\\[1\\] function selection"]
        pub type F13R = crate::FieldReader;
        #[doc = "Field `F13` writer - GPIO1\\[1\\] function selection"]
        pub type F13W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F14` reader - GPIO1\\[2\\] function selection"]
        pub type F14R = crate::FieldReader;
        #[doc = "Field `F14` writer - GPIO1\\[2\\] function selection"]
        pub type F14W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `F15` reader - GPIO1\\[3\\] function selection"]
        pub type F15R = crate::FieldReader;
        #[doc = "Field `F15` writer - GPIO1\\[3\\] function selection"]
        pub type F15W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - GPIO1\\[0\\] function selection"]
            #[inline(always)]
            pub fn f12(&self) -> F12R {
                F12R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - GPIO1\\[1\\] function selection"]
            #[inline(always)]
            pub fn f13(&self) -> F13R {
                F13R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - GPIO1\\[2\\] function selection"]
            #[inline(always)]
            pub fn f14(&self) -> F14R {
                F14R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - GPIO1\\[3\\] function selection"]
            #[inline(always)]
            pub fn f15(&self) -> F15R {
                F15R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - GPIO1\\[0\\] function selection"]
            #[inline(always)]
            pub fn f12(&mut self) -> F12W<FfedcSpec> {
                F12W::new(self, 0)
            }
            #[doc = "Bits 4:7 - GPIO1\\[1\\] function selection"]
            #[inline(always)]
            pub fn f13(&mut self) -> F13W<FfedcSpec> {
                F13W::new(self, 4)
            }
            #[doc = "Bits 8:11 - GPIO1\\[2\\] function selection"]
            #[inline(always)]
            pub fn f14(&mut self) -> F14W<FfedcSpec> {
                F14W::new(self, 8)
            }
            #[doc = "Bits 12:15 - GPIO1\\[3\\] function selection"]
            #[inline(always)]
            pub fn f15(&mut self) -> F15W<FfedcSpec> {
                F15W::new(self, 12)
            }
        }
        #[doc = "GPIO1\\[15:12\\] function selection\n\nYou can [`read`](crate::Reg::read) this register and get [`ffedc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ffedc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FfedcSpec;
        impl crate::RegisterSpec for FfedcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ffedc::R`](R) reader structure"]
        impl crate::Readable for FfedcSpec {}
        #[doc = "`write(|w| ..)` method takes [`ffedc::W`](W) writer structure"]
        impl crate::Writable for FfedcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FFEDC to value 0"]
        impl crate::Resettable for FfedcSpec {}
    }
    #[doc = "BSRR (w) register accessor: GPIO1 bit set reset reg\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsrr`] module"]
    #[doc(alias = "BSRR")]
    pub type Bsrr = crate::Reg<bsrr::BsrrSpec>;
    #[doc = "GPIO1 bit set reset reg"]
    pub mod bsrr {
        #[doc = "Register `BSRR` writer"]
        pub type W = crate::W<BsrrSpec>;
        #[doc = "Field `SET` writer - GPIO1\\[n\\] write 1 to set"]
        pub type SetW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        #[doc = "Field `CLR` writer - GPIO1\\[n\\] write 1 to clear"]
        pub type ClrW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] write 1 to set"]
            #[inline(always)]
            pub fn set_(&mut self) -> SetW<BsrrSpec> {
                SetW::new(self, 0)
            }
            #[doc = "Bits 16:31 - GPIO1\\[n\\] write 1 to clear"]
            #[inline(always)]
            pub fn clr(&mut self) -> ClrW<BsrrSpec> {
                ClrW::new(self, 16)
            }
        }
        #[doc = "GPIO1 bit set reset reg\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BsrrSpec;
        impl crate::RegisterSpec for BsrrSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`bsrr::W`](W) writer structure"]
        impl crate::Writable for BsrrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BSRR to value 0"]
        impl crate::Resettable for BsrrSpec {}
    }
    #[doc = "BRR (w) register accessor: GPIO1 bit reset reg\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
    #[doc(alias = "BRR")]
    pub type Brr = crate::Reg<brr::BrrSpec>;
    #[doc = "GPIO1 bit reset reg"]
    pub mod brr {
        #[doc = "Register `BRR` writer"]
        pub type W = crate::W<BrrSpec>;
        #[doc = "Field `CLR` writer - GPIO1\\[n\\] write 1 to clear"]
        pub type ClrW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            #[doc = "Bits 0:15 - GPIO1\\[n\\] write 1 to clear"]
            #[inline(always)]
            pub fn clr(&mut self) -> ClrW<BrrSpec> {
                ClrW::new(self, 0)
            }
        }
        #[doc = "GPIO1 bit reset reg\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BrrSpec;
        impl crate::RegisterSpec for BrrSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"]
        impl crate::Writable for BrrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BRR to value 0"]
        impl crate::Resettable for BrrSpec {}
    }
}
#[doc = "EXTI registers"]
pub type Exti = crate::Periph<exti::RegisterBlock, 0x4001_0880>;
impl core::fmt::Debug for Exti {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Exti").finish()
    }
}
#[doc = "EXTI registers"]
pub mod exti {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        cr0: Cr0,
        cr1: Cr1,
        ie: Ie,
        if_: If,
        clko: Clko,
    }
    impl RegisterBlock {
        #[doc = "0x00 - GPIO0\\[7:0\\] external interrupt trigger type"]
        #[inline(always)]
        pub const fn cr0(&self) -> &Cr0 {
            &self.cr0
        }
        #[doc = "0x04 - GPIO0\\[15:8\\] external interrupt trigger type"]
        #[inline(always)]
        pub const fn cr1(&self) -> &Cr1 {
            &self.cr1
        }
        #[doc = "0x08 - GPIO interrupt enable"]
        #[inline(always)]
        pub const fn ie(&self) -> &Ie {
            &self.ie
        }
        #[doc = "0x0c - GPIO interrupt flag"]
        #[inline(always)]
        pub const fn if_(&self) -> &If {
            &self.if_
        }
        #[doc = "0x10 - GPIO output clock selection"]
        #[inline(always)]
        pub const fn clko(&self) -> &Clko {
            &self.clko
        }
    }
    #[doc = "CR0 (rw) register accessor: GPIO0\\[7:0\\] external interrupt trigger type\n\nYou can [`read`](crate::Reg::read) this register and get [`cr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr0`] module"]
    #[doc(alias = "CR0")]
    pub type Cr0 = crate::Reg<cr0::Cr0Spec>;
    #[doc = "GPIO0\\[7:0\\] external interrupt trigger type"]
    pub mod cr0 {
        #[doc = "Register `CR0` reader"]
        pub type R = crate::R<Cr0Spec>;
        #[doc = "Register `CR0` writer"]
        pub type W = crate::W<Cr0Spec>;
        #[doc = "Field `T0` reader - GPIO0\\[0\\] external interrupt trigger type"]
        pub type T0R = crate::FieldReader;
        #[doc = "Field `T0` writer - GPIO0\\[0\\] external interrupt trigger type"]
        pub type T0W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T1` reader - GPIO0\\[1\\] external interrupt trigger type"]
        pub type T1R = crate::FieldReader;
        #[doc = "Field `T1` writer - GPIO0\\[1\\] external interrupt trigger type"]
        pub type T1W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T2` reader - GPIO0\\[2\\] external interrupt trigger type"]
        pub type T2R = crate::FieldReader;
        #[doc = "Field `T2` writer - GPIO0\\[2\\] external interrupt trigger type"]
        pub type T2W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T3` reader - GPIO0\\[3\\] external interrupt trigger type"]
        pub type T3R = crate::FieldReader;
        #[doc = "Field `T3` writer - GPIO0\\[3\\] external interrupt trigger type"]
        pub type T3W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T4` reader - GPIO0\\[4\\] external interrupt trigger type"]
        pub type T4R = crate::FieldReader;
        #[doc = "Field `T4` writer - GPIO0\\[4\\] external interrupt trigger type"]
        pub type T4W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T5` reader - GPIO0\\[5\\] external interrupt trigger type"]
        pub type T5R = crate::FieldReader;
        #[doc = "Field `T5` writer - GPIO0\\[5\\] external interrupt trigger type"]
        pub type T5W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T6` reader - GPIO0\\[6\\] external interrupt trigger type"]
        pub type T6R = crate::FieldReader;
        #[doc = "Field `T6` writer - GPIO0\\[6\\] external interrupt trigger type"]
        pub type T6W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T7` reader - GPIO0\\[7\\] external interrupt trigger type"]
        pub type T7R = crate::FieldReader;
        #[doc = "Field `T7` writer - GPIO0\\[7\\] external interrupt trigger type"]
        pub type T7W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bits 0:1 - GPIO0\\[0\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t0(&self) -> T0R {
                T0R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - GPIO0\\[1\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t1(&self) -> T1R {
                T1R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - GPIO0\\[2\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t2(&self) -> T2R {
                T2R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - GPIO0\\[3\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t3(&self) -> T3R {
                T3R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - GPIO0\\[4\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t4(&self) -> T4R {
                T4R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - GPIO0\\[5\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t5(&self) -> T5R {
                T5R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - GPIO0\\[6\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t6(&self) -> T6R {
                T6R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - GPIO0\\[7\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t7(&self) -> T7R {
                T7R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - GPIO0\\[0\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t0(&mut self) -> T0W<Cr0Spec> {
                T0W::new(self, 0)
            }
            #[doc = "Bits 2:3 - GPIO0\\[1\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t1(&mut self) -> T1W<Cr0Spec> {
                T1W::new(self, 2)
            }
            #[doc = "Bits 4:5 - GPIO0\\[2\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t2(&mut self) -> T2W<Cr0Spec> {
                T2W::new(self, 4)
            }
            #[doc = "Bits 6:7 - GPIO0\\[3\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t3(&mut self) -> T3W<Cr0Spec> {
                T3W::new(self, 6)
            }
            #[doc = "Bits 8:9 - GPIO0\\[4\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t4(&mut self) -> T4W<Cr0Spec> {
                T4W::new(self, 8)
            }
            #[doc = "Bits 10:11 - GPIO0\\[5\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t5(&mut self) -> T5W<Cr0Spec> {
                T5W::new(self, 10)
            }
            #[doc = "Bits 12:13 - GPIO0\\[6\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t6(&mut self) -> T6W<Cr0Spec> {
                T6W::new(self, 12)
            }
            #[doc = "Bits 14:15 - GPIO0\\[7\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t7(&mut self) -> T7W<Cr0Spec> {
                T7W::new(self, 14)
            }
        }
        #[doc = "GPIO0\\[7:0\\] external interrupt trigger type\n\nYou can [`read`](crate::Reg::read) this register and get [`cr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Cr0Spec;
        impl crate::RegisterSpec for Cr0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cr0::R`](R) reader structure"]
        impl crate::Readable for Cr0Spec {}
        #[doc = "`write(|w| ..)` method takes [`cr0::W`](W) writer structure"]
        impl crate::Writable for Cr0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CR0 to value 0"]
        impl crate::Resettable for Cr0Spec {}
    }
    #[doc = "CR1 (rw) register accessor: GPIO0\\[15:8\\] external interrupt trigger type\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
    #[doc(alias = "CR1")]
    pub type Cr1 = crate::Reg<cr1::Cr1Spec>;
    #[doc = "GPIO0\\[15:8\\] external interrupt trigger type"]
    pub mod cr1 {
        #[doc = "Register `CR1` reader"]
        pub type R = crate::R<Cr1Spec>;
        #[doc = "Register `CR1` writer"]
        pub type W = crate::W<Cr1Spec>;
        #[doc = "Field `T8` reader - GPIO0\\[8\\] external interrupt trigger type"]
        pub type T8R = crate::FieldReader;
        #[doc = "Field `T8` writer - GPIO0\\[8\\] external interrupt trigger type"]
        pub type T8W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T9` reader - GPIO0\\[9\\] external interrupt trigger type"]
        pub type T9R = crate::FieldReader;
        #[doc = "Field `T9` writer - GPIO0\\[9\\] external interrupt trigger type"]
        pub type T9W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T10` reader - GPIO0\\[10\\] external interrupt trigger type"]
        pub type T10R = crate::FieldReader;
        #[doc = "Field `T10` writer - GPIO0\\[10\\] external interrupt trigger type"]
        pub type T10W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T11` reader - GPIO0\\[11\\] external interrupt trigger type"]
        pub type T11R = crate::FieldReader;
        #[doc = "Field `T11` writer - GPIO0\\[11\\] external interrupt trigger type"]
        pub type T11W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T12` reader - GPIO0\\[12\\] external interrupt trigger type"]
        pub type T12R = crate::FieldReader;
        #[doc = "Field `T12` writer - GPIO0\\[12\\] external interrupt trigger type"]
        pub type T12W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T13` reader - GPIO0\\[13\\] external interrupt trigger type"]
        pub type T13R = crate::FieldReader;
        #[doc = "Field `T13` writer - GPIO0\\[13\\] external interrupt trigger type"]
        pub type T13W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T14` reader - GPIO0\\[14\\] external interrupt trigger type"]
        pub type T14R = crate::FieldReader;
        #[doc = "Field `T14` writer - GPIO0\\[14\\] external interrupt trigger type"]
        pub type T14W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `T15` reader - GPIO0\\[15\\] external interrupt trigger type"]
        pub type T15R = crate::FieldReader;
        #[doc = "Field `T15` writer - GPIO0\\[15\\] external interrupt trigger type"]
        pub type T15W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bits 0:1 - GPIO0\\[8\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t8(&self) -> T8R {
                T8R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - GPIO0\\[9\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t9(&self) -> T9R {
                T9R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - GPIO0\\[10\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t10(&self) -> T10R {
                T10R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - GPIO0\\[11\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t11(&self) -> T11R {
                T11R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - GPIO0\\[12\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t12(&self) -> T12R {
                T12R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - GPIO0\\[13\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t13(&self) -> T13R {
                T13R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - GPIO0\\[14\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t14(&self) -> T14R {
                T14R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - GPIO0\\[15\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t15(&self) -> T15R {
                T15R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - GPIO0\\[8\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t8(&mut self) -> T8W<Cr1Spec> {
                T8W::new(self, 0)
            }
            #[doc = "Bits 2:3 - GPIO0\\[9\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t9(&mut self) -> T9W<Cr1Spec> {
                T9W::new(self, 2)
            }
            #[doc = "Bits 4:5 - GPIO0\\[10\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t10(&mut self) -> T10W<Cr1Spec> {
                T10W::new(self, 4)
            }
            #[doc = "Bits 6:7 - GPIO0\\[11\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t11(&mut self) -> T11W<Cr1Spec> {
                T11W::new(self, 6)
            }
            #[doc = "Bits 8:9 - GPIO0\\[12\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t12(&mut self) -> T12W<Cr1Spec> {
                T12W::new(self, 8)
            }
            #[doc = "Bits 10:11 - GPIO0\\[13\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t13(&mut self) -> T13W<Cr1Spec> {
                T13W::new(self, 10)
            }
            #[doc = "Bits 12:13 - GPIO0\\[14\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t14(&mut self) -> T14W<Cr1Spec> {
                T14W::new(self, 12)
            }
            #[doc = "Bits 14:15 - GPIO0\\[15\\] external interrupt trigger type"]
            #[inline(always)]
            pub fn t15(&mut self) -> T15W<Cr1Spec> {
                T15W::new(self, 14)
            }
        }
        #[doc = "GPIO0\\[15:8\\] external interrupt trigger type\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Cr1Spec;
        impl crate::RegisterSpec for Cr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cr1::R`](R) reader structure"]
        impl crate::Readable for Cr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"]
        impl crate::Writable for Cr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CR1 to value 0"]
        impl crate::Resettable for Cr1Spec {}
    }
    #[doc = "IE (rw) register accessor: GPIO interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie`] module"]
    #[doc(alias = "IE")]
    pub type Ie = crate::Reg<ie::IeSpec>;
    #[doc = "GPIO interrupt enable"]
    pub mod ie {
        #[doc = "Register `IE` reader"]
        pub type R = crate::R<IeSpec>;
        #[doc = "Register `IE` writer"]
        pub type W = crate::W<IeSpec>;
        #[doc = "Field `EXTI0_IE` reader - GPIO0 interrupt enable"]
        pub type Exti0IeR = crate::BitReader;
        #[doc = "Field `EXTI0_IE` writer - GPIO0 interrupt enable"]
        pub type Exti0IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EXTI1_IE` reader - GPIO1 interrupt enable"]
        pub type Exti1IeR = crate::BitReader;
        #[doc = "Field `EXTI1_IE` writer - GPIO1 interrupt enable"]
        pub type Exti1IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EXTI0_RE` reader - GPIO0 DMA enable"]
        pub type Exti0ReR = crate::BitReader;
        #[doc = "Field `EXTI0_RE` writer - GPIO0 DMA enable"]
        pub type Exti0ReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EXTI1_RE` reader - GPIO1 DMA enable"]
        pub type Exti1ReR = crate::BitReader;
        #[doc = "Field `EXTI1_RE` writer - GPIO1 DMA enable"]
        pub type Exti1ReW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - GPIO0 interrupt enable"]
            #[inline(always)]
            pub fn exti0_ie(&self) -> Exti0IeR {
                Exti0IeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - GPIO1 interrupt enable"]
            #[inline(always)]
            pub fn exti1_ie(&self) -> Exti1IeR {
                Exti1IeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 8 - GPIO0 DMA enable"]
            #[inline(always)]
            pub fn exti0_re(&self) -> Exti0ReR {
                Exti0ReR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - GPIO1 DMA enable"]
            #[inline(always)]
            pub fn exti1_re(&self) -> Exti1ReR {
                Exti1ReR::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - GPIO0 interrupt enable"]
            #[inline(always)]
            pub fn exti0_ie(&mut self) -> Exti0IeW<IeSpec> {
                Exti0IeW::new(self, 0)
            }
            #[doc = "Bit 1 - GPIO1 interrupt enable"]
            #[inline(always)]
            pub fn exti1_ie(&mut self) -> Exti1IeW<IeSpec> {
                Exti1IeW::new(self, 1)
            }
            #[doc = "Bit 8 - GPIO0 DMA enable"]
            #[inline(always)]
            pub fn exti0_re(&mut self) -> Exti0ReW<IeSpec> {
                Exti0ReW::new(self, 8)
            }
            #[doc = "Bit 9 - GPIO1 DMA enable"]
            #[inline(always)]
            pub fn exti1_re(&mut self) -> Exti1ReW<IeSpec> {
                Exti1ReW::new(self, 9)
            }
        }
        #[doc = "GPIO interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IeSpec;
        impl crate::RegisterSpec for IeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ie::R`](R) reader structure"]
        impl crate::Readable for IeSpec {}
        #[doc = "`write(|w| ..)` method takes [`ie::W`](W) writer structure"]
        impl crate::Writable for IeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE to value 0"]
        impl crate::Resettable for IeSpec {}
    }
    #[doc = "IF (rw) register accessor: GPIO interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@if_`] module"]
    #[doc(alias = "IF")]
    pub type If = crate::Reg<if_::IfSpec>;
    #[doc = "GPIO interrupt flag"]
    pub mod if_ {
        #[doc = "Register `IF` reader"]
        pub type R = crate::R<IfSpec>;
        #[doc = "Register `IF` writer"]
        pub type W = crate::W<IfSpec>;
        #[doc = "Field `IF0` reader - GPIO0\\[0\\] interrupt flag"]
        pub type If0R = crate::BitReader;
        #[doc = "Field `IF0` writer - GPIO0\\[0\\] interrupt flag"]
        pub type If0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF1` reader - GPIO0\\[1\\] interrupt flag"]
        pub type If1R = crate::BitReader;
        #[doc = "Field `IF1` writer - GPIO0\\[1\\] interrupt flag"]
        pub type If1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF2` reader - GPIO0\\[2\\] interrupt flag"]
        pub type If2R = crate::BitReader;
        #[doc = "Field `IF2` writer - GPIO0\\[2\\] interrupt flag"]
        pub type If2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF3` reader - GPIO0\\[3\\] interrupt flag"]
        pub type If3R = crate::BitReader;
        #[doc = "Field `IF3` writer - GPIO0\\[3\\] interrupt flag"]
        pub type If3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF4` reader - GPIO0\\[4\\] interrupt flag"]
        pub type If4R = crate::BitReader;
        #[doc = "Field `IF4` writer - GPIO0\\[4\\] interrupt flag"]
        pub type If4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF5` reader - GPIO0\\[5\\] interrupt flag"]
        pub type If5R = crate::BitReader;
        #[doc = "Field `IF5` writer - GPIO0\\[5\\] interrupt flag"]
        pub type If5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF6` reader - GPIO0\\[6\\] interrupt flag"]
        pub type If6R = crate::BitReader;
        #[doc = "Field `IF6` writer - GPIO0\\[6\\] interrupt flag"]
        pub type If6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF7` reader - GPIO0\\[7\\] interrupt flag"]
        pub type If7R = crate::BitReader;
        #[doc = "Field `IF7` writer - GPIO0\\[7\\] interrupt flag"]
        pub type If7W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF8` reader - GPIO0\\[8\\] interrupt flag"]
        pub type If8R = crate::BitReader;
        #[doc = "Field `IF8` writer - GPIO0\\[8\\] interrupt flag"]
        pub type If8W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF9` reader - GPIO0\\[9\\] interrupt flag"]
        pub type If9R = crate::BitReader;
        #[doc = "Field `IF9` writer - GPIO0\\[9\\] interrupt flag"]
        pub type If9W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF10` reader - GPIO0\\[10\\] interrupt flag"]
        pub type If10R = crate::BitReader;
        #[doc = "Field `IF10` writer - GPIO0\\[10\\] interrupt flag"]
        pub type If10W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF11` reader - GPIO0\\[11\\] interrupt flag"]
        pub type If11R = crate::BitReader;
        #[doc = "Field `IF11` writer - GPIO0\\[11\\] interrupt flag"]
        pub type If11W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF12` reader - GPIO0\\[12\\] interrupt flag"]
        pub type If12R = crate::BitReader;
        #[doc = "Field `IF12` writer - GPIO0\\[12\\] interrupt flag"]
        pub type If12W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF13` reader - GPIO0\\[13\\] interrupt flag"]
        pub type If13R = crate::BitReader;
        #[doc = "Field `IF13` writer - GPIO0\\[13\\] interrupt flag"]
        pub type If13W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF14` reader - GPIO0\\[14\\] interrupt flag"]
        pub type If14R = crate::BitReader;
        #[doc = "Field `IF14` writer - GPIO0\\[14\\] interrupt flag"]
        pub type If14W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF15` reader - GPIO0\\[15\\] interrupt flag"]
        pub type If15R = crate::BitReader;
        #[doc = "Field `IF15` writer - GPIO0\\[15\\] interrupt flag"]
        pub type If15W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - GPIO0\\[0\\] interrupt flag"]
            #[inline(always)]
            pub fn if0(&self) -> If0R {
                If0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - GPIO0\\[1\\] interrupt flag"]
            #[inline(always)]
            pub fn if1(&self) -> If1R {
                If1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - GPIO0\\[2\\] interrupt flag"]
            #[inline(always)]
            pub fn if2(&self) -> If2R {
                If2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - GPIO0\\[3\\] interrupt flag"]
            #[inline(always)]
            pub fn if3(&self) -> If3R {
                If3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - GPIO0\\[4\\] interrupt flag"]
            #[inline(always)]
            pub fn if4(&self) -> If4R {
                If4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - GPIO0\\[5\\] interrupt flag"]
            #[inline(always)]
            pub fn if5(&self) -> If5R {
                If5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - GPIO0\\[6\\] interrupt flag"]
            #[inline(always)]
            pub fn if6(&self) -> If6R {
                If6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - GPIO0\\[7\\] interrupt flag"]
            #[inline(always)]
            pub fn if7(&self) -> If7R {
                If7R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - GPIO0\\[8\\] interrupt flag"]
            #[inline(always)]
            pub fn if8(&self) -> If8R {
                If8R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - GPIO0\\[9\\] interrupt flag"]
            #[inline(always)]
            pub fn if9(&self) -> If9R {
                If9R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - GPIO0\\[10\\] interrupt flag"]
            #[inline(always)]
            pub fn if10(&self) -> If10R {
                If10R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - GPIO0\\[11\\] interrupt flag"]
            #[inline(always)]
            pub fn if11(&self) -> If11R {
                If11R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - GPIO0\\[12\\] interrupt flag"]
            #[inline(always)]
            pub fn if12(&self) -> If12R {
                If12R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - GPIO0\\[13\\] interrupt flag"]
            #[inline(always)]
            pub fn if13(&self) -> If13R {
                If13R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - GPIO0\\[14\\] interrupt flag"]
            #[inline(always)]
            pub fn if14(&self) -> If14R {
                If14R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - GPIO0\\[15\\] interrupt flag"]
            #[inline(always)]
            pub fn if15(&self) -> If15R {
                If15R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - GPIO0\\[0\\] interrupt flag"]
            #[inline(always)]
            pub fn if0(&mut self) -> If0W<IfSpec> {
                If0W::new(self, 0)
            }
            #[doc = "Bit 1 - GPIO0\\[1\\] interrupt flag"]
            #[inline(always)]
            pub fn if1(&mut self) -> If1W<IfSpec> {
                If1W::new(self, 1)
            }
            #[doc = "Bit 2 - GPIO0\\[2\\] interrupt flag"]
            #[inline(always)]
            pub fn if2(&mut self) -> If2W<IfSpec> {
                If2W::new(self, 2)
            }
            #[doc = "Bit 3 - GPIO0\\[3\\] interrupt flag"]
            #[inline(always)]
            pub fn if3(&mut self) -> If3W<IfSpec> {
                If3W::new(self, 3)
            }
            #[doc = "Bit 4 - GPIO0\\[4\\] interrupt flag"]
            #[inline(always)]
            pub fn if4(&mut self) -> If4W<IfSpec> {
                If4W::new(self, 4)
            }
            #[doc = "Bit 5 - GPIO0\\[5\\] interrupt flag"]
            #[inline(always)]
            pub fn if5(&mut self) -> If5W<IfSpec> {
                If5W::new(self, 5)
            }
            #[doc = "Bit 6 - GPIO0\\[6\\] interrupt flag"]
            #[inline(always)]
            pub fn if6(&mut self) -> If6W<IfSpec> {
                If6W::new(self, 6)
            }
            #[doc = "Bit 7 - GPIO0\\[7\\] interrupt flag"]
            #[inline(always)]
            pub fn if7(&mut self) -> If7W<IfSpec> {
                If7W::new(self, 7)
            }
            #[doc = "Bit 8 - GPIO0\\[8\\] interrupt flag"]
            #[inline(always)]
            pub fn if8(&mut self) -> If8W<IfSpec> {
                If8W::new(self, 8)
            }
            #[doc = "Bit 9 - GPIO0\\[9\\] interrupt flag"]
            #[inline(always)]
            pub fn if9(&mut self) -> If9W<IfSpec> {
                If9W::new(self, 9)
            }
            #[doc = "Bit 10 - GPIO0\\[10\\] interrupt flag"]
            #[inline(always)]
            pub fn if10(&mut self) -> If10W<IfSpec> {
                If10W::new(self, 10)
            }
            #[doc = "Bit 11 - GPIO0\\[11\\] interrupt flag"]
            #[inline(always)]
            pub fn if11(&mut self) -> If11W<IfSpec> {
                If11W::new(self, 11)
            }
            #[doc = "Bit 12 - GPIO0\\[12\\] interrupt flag"]
            #[inline(always)]
            pub fn if12(&mut self) -> If12W<IfSpec> {
                If12W::new(self, 12)
            }
            #[doc = "Bit 13 - GPIO0\\[13\\] interrupt flag"]
            #[inline(always)]
            pub fn if13(&mut self) -> If13W<IfSpec> {
                If13W::new(self, 13)
            }
            #[doc = "Bit 14 - GPIO0\\[14\\] interrupt flag"]
            #[inline(always)]
            pub fn if14(&mut self) -> If14W<IfSpec> {
                If14W::new(self, 14)
            }
            #[doc = "Bit 15 - GPIO0\\[15\\] interrupt flag"]
            #[inline(always)]
            pub fn if15(&mut self) -> If15W<IfSpec> {
                If15W::new(self, 15)
            }
        }
        #[doc = "GPIO interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IfSpec;
        impl crate::RegisterSpec for IfSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`if_::R`](R) reader structure"]
        impl crate::Readable for IfSpec {}
        #[doc = "`write(|w| ..)` method takes [`if_::W`](W) writer structure"]
        impl crate::Writable for IfSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IF to value 0"]
        impl crate::Resettable for IfSpec {}
    }
    #[doc = "CLKO (rw) register accessor: GPIO output clock selection\n\nYou can [`read`](crate::Reg::read) this register and get [`clko::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clko::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clko`] module"]
    #[doc(alias = "CLKO")]
    pub type Clko = crate::Reg<clko::ClkoSpec>;
    #[doc = "GPIO output clock selection"]
    pub mod clko {
        #[doc = "Register `CLKO` reader"]
        pub type R = crate::R<ClkoSpec>;
        #[doc = "Register `CLKO` writer"]
        pub type W = crate::W<ClkoSpec>;
        #[doc = "Field `LSI_OE` reader - LSI output enable"]
        pub type LsiOeR = crate::BitReader;
        #[doc = "Field `LSI_OE` writer - LSI output enable"]
        pub type LsiOeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HSI_OE` reader - HSI output enable"]
        pub type HsiOeR = crate::BitReader;
        #[doc = "Field `HSI_OE` writer - HSI output enable"]
        pub type HsiOeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PLL_OE` reader - PLL output enable"]
        pub type PllOeR = crate::BitReader;
        #[doc = "Field `PLL_OE` writer - PLL output enable"]
        pub type PllOeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADC_OE` reader - ADC output enable"]
        pub type AdcOeR = crate::BitReader;
        #[doc = "Field `ADC_OE` writer - ADC output enable"]
        pub type AdcOeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - LSI output enable"]
            #[inline(always)]
            pub fn lsi_oe(&self) -> LsiOeR {
                LsiOeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - HSI output enable"]
            #[inline(always)]
            pub fn hsi_oe(&self) -> HsiOeR {
                HsiOeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - PLL output enable"]
            #[inline(always)]
            pub fn pll_oe(&self) -> PllOeR {
                PllOeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - ADC output enable"]
            #[inline(always)]
            pub fn adc_oe(&self) -> AdcOeR {
                AdcOeR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - LSI output enable"]
            #[inline(always)]
            pub fn lsi_oe(&mut self) -> LsiOeW<ClkoSpec> {
                LsiOeW::new(self, 0)
            }
            #[doc = "Bit 1 - HSI output enable"]
            #[inline(always)]
            pub fn hsi_oe(&mut self) -> HsiOeW<ClkoSpec> {
                HsiOeW::new(self, 1)
            }
            #[doc = "Bit 2 - PLL output enable"]
            #[inline(always)]
            pub fn pll_oe(&mut self) -> PllOeW<ClkoSpec> {
                PllOeW::new(self, 2)
            }
            #[doc = "Bit 3 - ADC output enable"]
            #[inline(always)]
            pub fn adc_oe(&mut self) -> AdcOeW<ClkoSpec> {
                AdcOeW::new(self, 3)
            }
        }
        #[doc = "GPIO output clock selection\n\nYou can [`read`](crate::Reg::read) this register and get [`clko::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clko::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClkoSpec;
        impl crate::RegisterSpec for ClkoSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clko::R`](R) reader structure"]
        impl crate::Readable for ClkoSpec {}
        #[doc = "`write(|w| ..)` method takes [`clko::W`](W) writer structure"]
        impl crate::Writable for ClkoSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLKO to value 0"]
        impl crate::Resettable for ClkoSpec {}
    }
}
#[doc = "UART registers"]
pub type Uart = crate::Periph<uart::RegisterBlock, 0x4001_0900>;
impl core::fmt::Debug for Uart {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart").finish()
    }
}
#[doc = "UART registers"]
pub mod uart {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctrl: Ctrl,
        divh: Divh,
        divl: Divl,
        buff: Buff,
        adr: Adr,
        stt: Stt,
        re: Re,
        ie: Ie,
        if_: If,
        ioc: Ioc,
    }
    impl RegisterBlock {
        #[doc = "0x00 - UART control"]
        #[inline(always)]
        pub const fn ctrl(&self) -> &Ctrl {
            &self.ctrl
        }
        #[doc = "0x04 - UART Baudrate higher byte"]
        #[inline(always)]
        pub const fn divh(&self) -> &Divh {
            &self.divh
        }
        #[doc = "0x08 - UART Baudrate lower byte"]
        #[inline(always)]
        pub const fn divl(&self) -> &Divl {
            &self.divl
        }
        #[doc = "0x0c - UART read/write buffer"]
        #[inline(always)]
        pub const fn buff(&self) -> &Buff {
            &self.buff
        }
        #[doc = "0x10 - UART match address as RS485"]
        #[inline(always)]
        pub const fn adr(&self) -> &Adr {
            &self.adr
        }
        #[doc = "0x14 - UART status"]
        #[inline(always)]
        pub const fn stt(&self) -> &Stt {
            &self.stt
        }
        #[doc = "0x18 - UART DMA request enable"]
        #[inline(always)]
        pub const fn re(&self) -> &Re {
            &self.re
        }
        #[doc = "0x1c - UART interrupt enable"]
        #[inline(always)]
        pub const fn ie(&self) -> &Ie {
            &self.ie
        }
        #[doc = "0x20 - UART interrupt flag"]
        #[inline(always)]
        pub const fn if_(&self) -> &If {
            &self.if_
        }
        #[doc = "0x24 - UART IO Control"]
        #[inline(always)]
        pub const fn ioc(&self) -> &Ioc {
            &self.ioc
        }
    }
    #[doc = "CTRL (rw) register accessor: UART control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
    #[doc(alias = "CTRL")]
    pub type Ctrl = crate::Reg<ctrl::CtrlSpec>;
    #[doc = "UART control"]
    pub mod ctrl {
        #[doc = "Register `CTRL` reader"]
        pub type R = crate::R<CtrlSpec>;
        #[doc = "Register `CTRL` writer"]
        pub type W = crate::W<CtrlSpec>;
        #[doc = "Data length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ByteLen {
            #[doc = "0: 8bit data"]
            _8b = 0,
            #[doc = "1: 9bit data"]
            _9b = 1,
        }
        impl From<ByteLen> for bool {
            #[inline(always)]
            fn from(variant: ByteLen) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BYTE_LEN` reader - Data length"]
        pub type ByteLenR = crate::BitReader<ByteLen>;
        impl ByteLenR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ByteLen {
                match self.bits {
                    false => ByteLen::_8b,
                    true => ByteLen::_9b,
                }
            }
            #[doc = "8bit data"]
            #[inline(always)]
            pub fn is_8b(&self) -> bool {
                *self == ByteLen::_8b
            }
            #[doc = "9bit data"]
            #[inline(always)]
            pub fn is_9b(&self) -> bool {
                *self == ByteLen::_9b
            }
        }
        #[doc = "Field `BYTE_LEN` writer - Data length"]
        pub type ByteLenW<'a, REG> = crate::BitWriter<'a, REG, ByteLen>;
        impl<'a, REG> ByteLenW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "8bit data"]
            #[inline(always)]
            pub fn _8b(self) -> &'a mut crate::W<REG> {
                self.variant(ByteLen::_8b)
            }
            #[doc = "9bit data"]
            #[inline(always)]
            pub fn _9b(self) -> &'a mut crate::W<REG> {
                self.variant(ByteLen::_9b)
            }
        }
        #[doc = "Stop bit length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum StopLen {
            #[doc = "0: 1bit stop bit"]
            _1b = 0,
            #[doc = "1: 2bit stop bit"]
            _2b = 1,
        }
        impl From<StopLen> for bool {
            #[inline(always)]
            fn from(variant: StopLen) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `STOP_LEN` reader - Stop bit length"]
        pub type StopLenR = crate::BitReader<StopLen>;
        impl StopLenR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> StopLen {
                match self.bits {
                    false => StopLen::_1b,
                    true => StopLen::_2b,
                }
            }
            #[doc = "1bit stop bit"]
            #[inline(always)]
            pub fn is_1b(&self) -> bool {
                *self == StopLen::_1b
            }
            #[doc = "2bit stop bit"]
            #[inline(always)]
            pub fn is_2b(&self) -> bool {
                *self == StopLen::_2b
            }
        }
        #[doc = "Field `STOP_LEN` writer - Stop bit length"]
        pub type StopLenW<'a, REG> = crate::BitWriter<'a, REG, StopLen>;
        impl<'a, REG> StopLenW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "1bit stop bit"]
            #[inline(always)]
            pub fn _1b(self) -> &'a mut crate::W<REG> {
                self.variant(StopLen::_1b)
            }
            #[doc = "2bit stop bit"]
            #[inline(always)]
            pub fn _2b(self) -> &'a mut crate::W<REG> {
                self.variant(StopLen::_2b)
            }
        }
        #[doc = "LSB or MSB first\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BitOrder {
            #[doc = "0: LSB"]
            Lsb = 0,
            #[doc = "1: MSB"]
            Msb = 1,
        }
        impl From<BitOrder> for bool {
            #[inline(always)]
            fn from(variant: BitOrder) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BIT_ORDER` reader - LSB or MSB first"]
        pub type BitOrderR = crate::BitReader<BitOrder>;
        impl BitOrderR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BitOrder {
                match self.bits {
                    false => BitOrder::Lsb,
                    true => BitOrder::Msb,
                }
            }
            #[doc = "LSB"]
            #[inline(always)]
            pub fn is_lsb(&self) -> bool {
                *self == BitOrder::Lsb
            }
            #[doc = "MSB"]
            #[inline(always)]
            pub fn is_msb(&self) -> bool {
                *self == BitOrder::Msb
            }
        }
        #[doc = "Field `BIT_ORDER` writer - LSB or MSB first"]
        pub type BitOrderW<'a, REG> = crate::BitWriter<'a, REG, BitOrder>;
        impl<'a, REG> BitOrderW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "LSB"]
            #[inline(always)]
            pub fn lsb(self) -> &'a mut crate::W<REG> {
                self.variant(BitOrder::Lsb)
            }
            #[doc = "MSB"]
            #[inline(always)]
            pub fn msb(self) -> &'a mut crate::W<REG> {
                self.variant(BitOrder::Msb)
            }
        }
        #[doc = "Odd or Even Check\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CkType {
            #[doc = "0: Even check"]
            Even = 0,
            #[doc = "1: Odd check"]
            Odd = 1,
        }
        impl From<CkType> for bool {
            #[inline(always)]
            fn from(variant: CkType) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CK_TYPE` reader - Odd or Even Check"]
        pub type CkTypeR = crate::BitReader<CkType>;
        impl CkTypeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CkType {
                match self.bits {
                    false => CkType::Even,
                    true => CkType::Odd,
                }
            }
            #[doc = "Even check"]
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                *self == CkType::Even
            }
            #[doc = "Odd check"]
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                *self == CkType::Odd
            }
        }
        #[doc = "Field `CK_TYPE` writer - Odd or Even Check"]
        pub type CkTypeW<'a, REG> = crate::BitWriter<'a, REG, CkType>;
        impl<'a, REG> CkTypeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Even check"]
            #[inline(always)]
            pub fn even(self) -> &'a mut crate::W<REG> {
                self.variant(CkType::Even)
            }
            #[doc = "Odd check"]
            #[inline(always)]
            pub fn odd(self) -> &'a mut crate::W<REG> {
                self.variant(CkType::Odd)
            }
        }
        #[doc = "Odd-Even Check enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CkEn {
            #[doc = "0: Odd-Even check disabled"]
            Disabled = 0,
            #[doc = "1: Odd-Even check enabled"]
            Enabled = 1,
        }
        impl From<CkEn> for bool {
            #[inline(always)]
            fn from(variant: CkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CK_EN` reader - Odd-Even Check enable"]
        pub type CkEnR = crate::BitReader<CkEn>;
        impl CkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CkEn {
                match self.bits {
                    false => CkEn::Disabled,
                    true => CkEn::Enabled,
                }
            }
            #[doc = "Odd-Even check disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CkEn::Disabled
            }
            #[doc = "Odd-Even check enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CkEn::Enabled
            }
        }
        #[doc = "Field `CK_EN` writer - Odd-Even Check enable"]
        pub type CkEnW<'a, REG> = crate::BitWriter<'a, REG, CkEn>;
        impl<'a, REG> CkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Odd-Even check disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(CkEn::Disabled)
            }
            #[doc = "Odd-Even check enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(CkEn::Enabled)
            }
        }
        #[doc = "Multi-drop mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MdEn {
            #[doc = "0: Multi-drop mode disabled"]
            Disabled = 0,
            #[doc = "1: Multi-drop mode enabled"]
            Enabled = 1,
        }
        impl From<MdEn> for bool {
            #[inline(always)]
            fn from(variant: MdEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MD_EN` reader - Multi-drop mode enable"]
        pub type MdEnR = crate::BitReader<MdEn>;
        impl MdEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MdEn {
                match self.bits {
                    false => MdEn::Disabled,
                    true => MdEn::Enabled,
                }
            }
            #[doc = "Multi-drop mode disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MdEn::Disabled
            }
            #[doc = "Multi-drop mode enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MdEn::Enabled
            }
        }
        #[doc = "Field `MD_EN` writer - Multi-drop mode enable"]
        pub type MdEnW<'a, REG> = crate::BitWriter<'a, REG, MdEn>;
        impl<'a, REG> MdEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Multi-drop mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(MdEn::Disabled)
            }
            #[doc = "Multi-drop mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(MdEn::Enabled)
            }
        }
        impl R {
            #[doc = "Bit 0 - Data length"]
            #[inline(always)]
            pub fn byte_len(&self) -> ByteLenR {
                ByteLenR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Stop bit length"]
            #[inline(always)]
            pub fn stop_len(&self) -> StopLenR {
                StopLenR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - LSB or MSB first"]
            #[inline(always)]
            pub fn bit_order(&self) -> BitOrderR {
                BitOrderR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Odd or Even Check"]
            #[inline(always)]
            pub fn ck_type(&self) -> CkTypeR {
                CkTypeR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Odd-Even Check enable"]
            #[inline(always)]
            pub fn ck_en(&self) -> CkEnR {
                CkEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Multi-drop mode enable"]
            #[inline(always)]
            pub fn md_en(&self) -> MdEnR {
                MdEnR::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Data length"]
            #[inline(always)]
            pub fn byte_len(&mut self) -> ByteLenW<CtrlSpec> {
                ByteLenW::new(self, 0)
            }
            #[doc = "Bit 1 - Stop bit length"]
            #[inline(always)]
            pub fn stop_len(&mut self) -> StopLenW<CtrlSpec> {
                StopLenW::new(self, 1)
            }
            #[doc = "Bit 2 - LSB or MSB first"]
            #[inline(always)]
            pub fn bit_order(&mut self) -> BitOrderW<CtrlSpec> {
                BitOrderW::new(self, 2)
            }
            #[doc = "Bit 3 - Odd or Even Check"]
            #[inline(always)]
            pub fn ck_type(&mut self) -> CkTypeW<CtrlSpec> {
                CkTypeW::new(self, 3)
            }
            #[doc = "Bit 4 - Odd-Even Check enable"]
            #[inline(always)]
            pub fn ck_en(&mut self) -> CkEnW<CtrlSpec> {
                CkEnW::new(self, 4)
            }
            #[doc = "Bit 5 - Multi-drop mode enable"]
            #[inline(always)]
            pub fn md_en(&mut self) -> MdEnW<CtrlSpec> {
                MdEnW::new(self, 5)
            }
        }
        #[doc = "UART control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlSpec;
        impl crate::RegisterSpec for CtrlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctrl::R`](R) reader structure"]
        impl crate::Readable for CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"]
        impl crate::Writable for CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL to value 0"]
        impl crate::Resettable for CtrlSpec {}
    }
    #[doc = "DIVH (rw) register accessor: UART Baudrate higher byte\n\nYou can [`read`](crate::Reg::read) this register and get [`divh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`divh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@divh`] module"]
    #[doc(alias = "DIVH")]
    pub type Divh = crate::Reg<divh::DivhSpec>;
    #[doc = "UART Baudrate higher byte"]
    pub mod divh {
        #[doc = "Register `DIVH` reader"]
        pub type R = crate::R<DivhSpec>;
        #[doc = "Register `DIVH` writer"]
        pub type W = crate::W<DivhSpec>;
        #[doc = "Field `DIVH` reader - Baudrate higher byte"]
        pub type DivhR = crate::FieldReader;
        #[doc = "Field `DIVH` writer - Baudrate higher byte"]
        pub type DivhW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Baudrate higher byte"]
            #[inline(always)]
            pub fn divh(&self) -> DivhR {
                DivhR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Baudrate higher byte"]
            #[inline(always)]
            pub fn divh(&mut self) -> DivhW<DivhSpec> {
                DivhW::new(self, 0)
            }
        }
        #[doc = "UART Baudrate higher byte\n\nYou can [`read`](crate::Reg::read) this register and get [`divh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`divh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DivhSpec;
        impl crate::RegisterSpec for DivhSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`divh::R`](R) reader structure"]
        impl crate::Readable for DivhSpec {}
        #[doc = "`write(|w| ..)` method takes [`divh::W`](W) writer structure"]
        impl crate::Writable for DivhSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DIVH to value 0"]
        impl crate::Resettable for DivhSpec {}
    }
    #[doc = "DIVL (rw) register accessor: UART Baudrate lower byte\n\nYou can [`read`](crate::Reg::read) this register and get [`divl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`divl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@divl`] module"]
    #[doc(alias = "DIVL")]
    pub type Divl = crate::Reg<divl::DivlSpec>;
    #[doc = "UART Baudrate lower byte"]
    pub mod divl {
        #[doc = "Register `DIVL` reader"]
        pub type R = crate::R<DivlSpec>;
        #[doc = "Register `DIVL` writer"]
        pub type W = crate::W<DivlSpec>;
        #[doc = "Field `DIVL` reader - Baudrate lower byte"]
        pub type DivlR = crate::FieldReader;
        #[doc = "Field `DIVL` writer - Baudrate lower byte"]
        pub type DivlW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Baudrate lower byte"]
            #[inline(always)]
            pub fn divl(&self) -> DivlR {
                DivlR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Baudrate lower byte"]
            #[inline(always)]
            pub fn divl(&mut self) -> DivlW<DivlSpec> {
                DivlW::new(self, 0)
            }
        }
        #[doc = "UART Baudrate lower byte\n\nYou can [`read`](crate::Reg::read) this register and get [`divl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`divl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DivlSpec;
        impl crate::RegisterSpec for DivlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`divl::R`](R) reader structure"]
        impl crate::Readable for DivlSpec {}
        #[doc = "`write(|w| ..)` method takes [`divl::W`](W) writer structure"]
        impl crate::Writable for DivlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DIVL to value 0"]
        impl crate::Resettable for DivlSpec {}
    }
    #[doc = "BUFF (rw) register accessor: UART read/write buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`buff::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`buff::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@buff`] module"]
    #[doc(alias = "BUFF")]
    pub type Buff = crate::Reg<buff::BuffSpec>;
    #[doc = "UART read/write buffer"]
    pub mod buff {
        #[doc = "Register `BUFF` reader"]
        pub type R = crate::R<BuffSpec>;
        #[doc = "Register `BUFF` writer"]
        pub type W = crate::W<BuffSpec>;
        #[doc = "Field `DATA` reader - Write by Tx data, read as Rx data"]
        pub type DataR = crate::FieldReader<u16>;
        #[doc = "Field `DATA` writer - Write by Tx data, read as Rx data"]
        pub type DataW<'a, REG> = crate::FieldWriter<'a, REG, 9, u16>;
        impl R {
            #[doc = "Bits 0:8 - Write by Tx data, read as Rx data"]
            #[inline(always)]
            pub fn data(&self) -> DataR {
                DataR::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:8 - Write by Tx data, read as Rx data"]
            #[inline(always)]
            pub fn data(&mut self) -> DataW<BuffSpec> {
                DataW::new(self, 0)
            }
        }
        #[doc = "UART read/write buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`buff::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`buff::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BuffSpec;
        impl crate::RegisterSpec for BuffSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`buff::R`](R) reader structure"]
        impl crate::Readable for BuffSpec {}
        #[doc = "`write(|w| ..)` method takes [`buff::W`](W) writer structure"]
        impl crate::Writable for BuffSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BUFF to value 0"]
        impl crate::Resettable for BuffSpec {}
    }
    #[doc = "ADR (rw) register accessor: UART match address as RS485\n\nYou can [`read`](crate::Reg::read) this register and get [`adr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adr`] module"]
    #[doc(alias = "ADR")]
    pub type Adr = crate::Reg<adr::AdrSpec>;
    #[doc = "UART match address as RS485"]
    pub mod adr {
        #[doc = "Register `ADR` reader"]
        pub type R = crate::R<AdrSpec>;
        #[doc = "Register `ADR` writer"]
        pub type W = crate::W<AdrSpec>;
        #[doc = "Field `ADR` reader - UART address as a slave"]
        pub type AdrR = crate::FieldReader;
        #[doc = "Field `ADR` writer - UART address as a slave"]
        pub type AdrW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - UART address as a slave"]
            #[inline(always)]
            pub fn adr(&self) -> AdrR {
                AdrR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - UART address as a slave"]
            #[inline(always)]
            pub fn adr(&mut self) -> AdrW<AdrSpec> {
                AdrW::new(self, 0)
            }
        }
        #[doc = "UART match address as RS485\n\nYou can [`read`](crate::Reg::read) this register and get [`adr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AdrSpec;
        impl crate::RegisterSpec for AdrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adr::R`](R) reader structure"]
        impl crate::Readable for AdrSpec {}
        #[doc = "`write(|w| ..)` method takes [`adr::W`](W) writer structure"]
        impl crate::Writable for AdrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets ADR to value 0"]
        impl crate::Resettable for AdrSpec {}
    }
    #[doc = "STT (r) register accessor: UART status\n\nYou can [`read`](crate::Reg::read) this register and get [`stt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@stt`] module"]
    #[doc(alias = "STT")]
    pub type Stt = crate::Reg<stt::SttSpec>;
    #[doc = "UART status"]
    pub mod stt {
        #[doc = "Register `STT` reader"]
        pub type R = crate::R<SttSpec>;
        #[doc = "Field `TX_BUF_EMPTY` reader - TX Buffer empty"]
        pub type TxBufEmptyR = crate::BitReader;
        #[doc = "Field `TX_DONE` reader - Transmission fnished"]
        pub type TxDoneR = crate::BitReader;
        #[doc = "Field `ADR_MATCH` reader - Address matched in multi-drop mode"]
        pub type AdrMatchR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - TX Buffer empty"]
            #[inline(always)]
            pub fn tx_buf_empty(&self) -> TxBufEmptyR {
                TxBufEmptyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Transmission fnished"]
            #[inline(always)]
            pub fn tx_done(&self) -> TxDoneR {
                TxDoneR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Address matched in multi-drop mode"]
            #[inline(always)]
            pub fn adr_match(&self) -> AdrMatchR {
                AdrMatchR::new(((self.bits >> 2) & 1) != 0)
            }
        }
        #[doc = "UART status\n\nYou can [`read`](crate::Reg::read) this register and get [`stt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SttSpec;
        impl crate::RegisterSpec for SttSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`stt::R`](R) reader structure"]
        impl crate::Readable for SttSpec {}
        #[doc = "`reset()` method sets STT to value 0x03"]
        impl crate::Resettable for SttSpec {
            const RESET_VALUE: u32 = 0x03;
        }
    }
    #[doc = "RE (rw) register accessor: UART DMA request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`re::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`re::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@re`] module"]
    #[doc(alias = "RE")]
    pub type Re = crate::Reg<re::ReSpec>;
    #[doc = "UART DMA request enable"]
    pub mod re {
        #[doc = "Register `RE` reader"]
        pub type R = crate::R<ReSpec>;
        #[doc = "Register `RE` writer"]
        pub type W = crate::W<ReSpec>;
        #[doc = "Field `TX_DONE_RE` reader - Byte transmission finished DMA request flag"]
        pub type TxDoneReR = crate::BitReader;
        #[doc = "Field `TX_DONE_RE` writer - Byte transmission finished DMA request flag"]
        pub type TxDoneReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_DONE_RE` reader - Byte received DMA request enable"]
        pub type RxDoneReR = crate::BitReader;
        #[doc = "Field `RX_DONE_RE` writer - Byte received DMA request enable"]
        pub type RxDoneReW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TX_BUF_EMPTY_RE` reader - TX Buffer empty DMA request enable"]
        pub type TxBufEmptyReR = crate::BitReader;
        #[doc = "Field `TX_BUF_EMPTY_RE` writer - TX Buffer empty DMA request enable"]
        pub type TxBufEmptyReW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Byte transmission finished DMA request flag"]
            #[inline(always)]
            pub fn tx_done_re(&self) -> TxDoneReR {
                TxDoneReR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Byte received DMA request enable"]
            #[inline(always)]
            pub fn rx_done_re(&self) -> RxDoneReR {
                RxDoneReR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - TX Buffer empty DMA request enable"]
            #[inline(always)]
            pub fn tx_buf_empty_re(&self) -> TxBufEmptyReR {
                TxBufEmptyReR::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Byte transmission finished DMA request flag"]
            #[inline(always)]
            pub fn tx_done_re(&mut self) -> TxDoneReW<ReSpec> {
                TxDoneReW::new(self, 0)
            }
            #[doc = "Bit 1 - Byte received DMA request enable"]
            #[inline(always)]
            pub fn rx_done_re(&mut self) -> RxDoneReW<ReSpec> {
                RxDoneReW::new(self, 1)
            }
            #[doc = "Bit 2 - TX Buffer empty DMA request enable"]
            #[inline(always)]
            pub fn tx_buf_empty_re(&mut self) -> TxBufEmptyReW<ReSpec> {
                TxBufEmptyReW::new(self, 2)
            }
        }
        #[doc = "UART DMA request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`re::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`re::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ReSpec;
        impl crate::RegisterSpec for ReSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`re::R`](R) reader structure"]
        impl crate::Readable for ReSpec {}
        #[doc = "`write(|w| ..)` method takes [`re::W`](W) writer structure"]
        impl crate::Writable for ReSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets RE to value 0"]
        impl crate::Resettable for ReSpec {}
    }
    #[doc = "IE (rw) register accessor: UART interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie`] module"]
    #[doc(alias = "IE")]
    pub type Ie = crate::Reg<ie::IeSpec>;
    #[doc = "UART interrupt enable"]
    pub mod ie {
        #[doc = "Register `IE` reader"]
        pub type R = crate::R<IeSpec>;
        #[doc = "Register `IE` writer"]
        pub type W = crate::W<IeSpec>;
        #[doc = "Field `TX_DONE_IE` reader - Byte transmission finished interrupt flag"]
        pub type TxDoneIeR = crate::BitReader;
        #[doc = "Field `TX_DONE_IE` writer - Byte transmission finished interrupt flag"]
        pub type TxDoneIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_DONE_IE` reader - Byte received interrupt enable"]
        pub type RxDoneIeR = crate::BitReader;
        #[doc = "Field `RX_DONE_IE` writer - Byte received interrupt enable"]
        pub type RxDoneIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TX_BUF_EMPTY_IE` reader - TX Buffer empty interrupt enable"]
        pub type TxBufEmptyIeR = crate::BitReader;
        #[doc = "Field `TX_BUF_EMPTY_IE` writer - TX Buffer empty interrupt enable"]
        pub type TxBufEmptyIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STOP_ERR_IE` reader - Stop bit error interrupt enable"]
        pub type StopErrIeR = crate::BitReader;
        #[doc = "Field `STOP_ERR_IE` writer - Stop bit error interrupt enable"]
        pub type StopErrIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CK_ERR_IE` reader - Check error interrupt enable"]
        pub type CkErrIeR = crate::BitReader;
        #[doc = "Field `CK_ERR_IE` writer - Check error interrupt enable"]
        pub type CkErrIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TX_OV_IE` reader - TX overflow interrupt enable"]
        pub type TxOvIeR = crate::BitReader;
        #[doc = "Field `TX_OV_IE` writer - TX overflow interrupt enable"]
        pub type TxOvIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_OV_IE` reader - RX overflow interrupt enable"]
        pub type RxOvIeR = crate::BitReader;
        #[doc = "Field `RX_OV_IE` writer - RX overflow interrupt enable"]
        pub type RxOvIeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Byte transmission finished interrupt flag"]
            #[inline(always)]
            pub fn tx_done_ie(&self) -> TxDoneIeR {
                TxDoneIeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Byte received interrupt enable"]
            #[inline(always)]
            pub fn rx_done_ie(&self) -> RxDoneIeR {
                RxDoneIeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - TX Buffer empty interrupt enable"]
            #[inline(always)]
            pub fn tx_buf_empty_ie(&self) -> TxBufEmptyIeR {
                TxBufEmptyIeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Stop bit error interrupt enable"]
            #[inline(always)]
            pub fn stop_err_ie(&self) -> StopErrIeR {
                StopErrIeR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Check error interrupt enable"]
            #[inline(always)]
            pub fn ck_err_ie(&self) -> CkErrIeR {
                CkErrIeR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TX overflow interrupt enable"]
            #[inline(always)]
            pub fn tx_ov_ie(&self) -> TxOvIeR {
                TxOvIeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RX overflow interrupt enable"]
            #[inline(always)]
            pub fn rx_ov_ie(&self) -> RxOvIeR {
                RxOvIeR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Byte transmission finished interrupt flag"]
            #[inline(always)]
            pub fn tx_done_ie(&mut self) -> TxDoneIeW<IeSpec> {
                TxDoneIeW::new(self, 0)
            }
            #[doc = "Bit 1 - Byte received interrupt enable"]
            #[inline(always)]
            pub fn rx_done_ie(&mut self) -> RxDoneIeW<IeSpec> {
                RxDoneIeW::new(self, 1)
            }
            #[doc = "Bit 2 - TX Buffer empty interrupt enable"]
            #[inline(always)]
            pub fn tx_buf_empty_ie(&mut self) -> TxBufEmptyIeW<IeSpec> {
                TxBufEmptyIeW::new(self, 2)
            }
            #[doc = "Bit 3 - Stop bit error interrupt enable"]
            #[inline(always)]
            pub fn stop_err_ie(&mut self) -> StopErrIeW<IeSpec> {
                StopErrIeW::new(self, 3)
            }
            #[doc = "Bit 4 - Check error interrupt enable"]
            #[inline(always)]
            pub fn ck_err_ie(&mut self) -> CkErrIeW<IeSpec> {
                CkErrIeW::new(self, 4)
            }
            #[doc = "Bit 5 - TX overflow interrupt enable"]
            #[inline(always)]
            pub fn tx_ov_ie(&mut self) -> TxOvIeW<IeSpec> {
                TxOvIeW::new(self, 5)
            }
            #[doc = "Bit 6 - RX overflow interrupt enable"]
            #[inline(always)]
            pub fn rx_ov_ie(&mut self) -> RxOvIeW<IeSpec> {
                RxOvIeW::new(self, 6)
            }
        }
        #[doc = "UART interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IeSpec;
        impl crate::RegisterSpec for IeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ie::R`](R) reader structure"]
        impl crate::Readable for IeSpec {}
        #[doc = "`write(|w| ..)` method takes [`ie::W`](W) writer structure"]
        impl crate::Writable for IeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE to value 0"]
        impl crate::Resettable for IeSpec {}
    }
    #[doc = "IF (rw) register accessor: UART interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@if_`] module"]
    #[doc(alias = "IF")]
    pub type If = crate::Reg<if_::IfSpec>;
    #[doc = "UART interrupt flag"]
    pub mod if_ {
        #[doc = "Register `IF` reader"]
        pub type R = crate::R<IfSpec>;
        #[doc = "Register `IF` writer"]
        pub type W = crate::W<IfSpec>;
        #[doc = "Field `TX_DONE_IF` reader - Byte transmission finished interrupt flag"]
        pub type TxDoneIfR = crate::BitReader;
        #[doc = "Field `TX_DONE_IF` writer - Byte transmission finished interrupt flag"]
        pub type TxDoneIfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_DONE_IF` reader - Byte received interrupt flag"]
        pub type RxDoneIfR = crate::BitReader;
        #[doc = "Field `RX_DONE_IF` writer - Byte received interrupt flag"]
        pub type RxDoneIfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TX_BUF_EMPTY_IF` reader - TX Buffer empty interrupt flag"]
        pub type TxBufEmptyIfR = crate::BitReader;
        #[doc = "Field `TX_BUF_EMPTY_IF` writer - TX Buffer empty interrupt flag"]
        pub type TxBufEmptyIfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STOP_ERR_IF` reader - Stop bit error interrupt flag"]
        pub type StopErrIfR = crate::BitReader;
        #[doc = "Field `STOP_ERR_IF` writer - Stop bit error interrupt flag"]
        pub type StopErrIfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CK_ERR_IF` reader - Check error interrupt flag"]
        pub type CkErrIfR = crate::BitReader;
        #[doc = "Field `CK_ERR_IF` writer - Check error interrupt flag"]
        pub type CkErrIfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TX_OV_IF` reader - TX overflow interrupt flag"]
        pub type TxOvIfR = crate::BitReader;
        #[doc = "Field `TX_OV_IF` writer - TX overflow interrupt flag"]
        pub type TxOvIfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_OV_IF` reader - RX overflow interrupt flag"]
        pub type RxOvIfR = crate::BitReader;
        #[doc = "Field `RX_OV_IF` writer - RX overflow interrupt flag"]
        pub type RxOvIfW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Byte transmission finished interrupt flag"]
            #[inline(always)]
            pub fn tx_done_if(&self) -> TxDoneIfR {
                TxDoneIfR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Byte received interrupt flag"]
            #[inline(always)]
            pub fn rx_done_if(&self) -> RxDoneIfR {
                RxDoneIfR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - TX Buffer empty interrupt flag"]
            #[inline(always)]
            pub fn tx_buf_empty_if(&self) -> TxBufEmptyIfR {
                TxBufEmptyIfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Stop bit error interrupt flag"]
            #[inline(always)]
            pub fn stop_err_if(&self) -> StopErrIfR {
                StopErrIfR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Check error interrupt flag"]
            #[inline(always)]
            pub fn ck_err_if(&self) -> CkErrIfR {
                CkErrIfR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TX overflow interrupt flag"]
            #[inline(always)]
            pub fn tx_ov_if(&self) -> TxOvIfR {
                TxOvIfR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RX overflow interrupt flag"]
            #[inline(always)]
            pub fn rx_ov_if(&self) -> RxOvIfR {
                RxOvIfR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Byte transmission finished interrupt flag"]
            #[inline(always)]
            pub fn tx_done_if(&mut self) -> TxDoneIfW<IfSpec> {
                TxDoneIfW::new(self, 0)
            }
            #[doc = "Bit 1 - Byte received interrupt flag"]
            #[inline(always)]
            pub fn rx_done_if(&mut self) -> RxDoneIfW<IfSpec> {
                RxDoneIfW::new(self, 1)
            }
            #[doc = "Bit 2 - TX Buffer empty interrupt flag"]
            #[inline(always)]
            pub fn tx_buf_empty_if(&mut self) -> TxBufEmptyIfW<IfSpec> {
                TxBufEmptyIfW::new(self, 2)
            }
            #[doc = "Bit 3 - Stop bit error interrupt flag"]
            #[inline(always)]
            pub fn stop_err_if(&mut self) -> StopErrIfW<IfSpec> {
                StopErrIfW::new(self, 3)
            }
            #[doc = "Bit 4 - Check error interrupt flag"]
            #[inline(always)]
            pub fn ck_err_if(&mut self) -> CkErrIfW<IfSpec> {
                CkErrIfW::new(self, 4)
            }
            #[doc = "Bit 5 - TX overflow interrupt flag"]
            #[inline(always)]
            pub fn tx_ov_if(&mut self) -> TxOvIfW<IfSpec> {
                TxOvIfW::new(self, 5)
            }
            #[doc = "Bit 6 - RX overflow interrupt flag"]
            #[inline(always)]
            pub fn rx_ov_if(&mut self) -> RxOvIfW<IfSpec> {
                RxOvIfW::new(self, 6)
            }
        }
        #[doc = "UART interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IfSpec;
        impl crate::RegisterSpec for IfSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`if_::R`](R) reader structure"]
        impl crate::Readable for IfSpec {}
        #[doc = "`write(|w| ..)` method takes [`if_::W`](W) writer structure"]
        impl crate::Writable for IfSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IF to value 0x05"]
        impl crate::Resettable for IfSpec {
            const RESET_VALUE: u32 = 0x05;
        }
    }
    #[doc = "IOC (rw) register accessor: UART IO Control\n\nYou can [`read`](crate::Reg::read) this register and get [`ioc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ioc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ioc`] module"]
    #[doc(alias = "IOC")]
    pub type Ioc = crate::Reg<ioc::IocSpec>;
    #[doc = "UART IO Control"]
    pub mod ioc {
        #[doc = "Register `IOC` reader"]
        pub type R = crate::R<IocSpec>;
        #[doc = "Register `IOC` writer"]
        pub type W = crate::W<IocSpec>;
        #[doc = "Field `TXD_INV` reader - TXD inverted then output"]
        pub type TxdInvR = crate::BitReader;
        #[doc = "Field `TXD_INV` writer - TXD inverted then output"]
        pub type TxdInvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RXD_INV` reader - RXD inverted then input"]
        pub type RxdInvR = crate::BitReader;
        #[doc = "Field `RXD_INV` writer - RXD inverted then input"]
        pub type RxdInvW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - TXD inverted then output"]
            #[inline(always)]
            pub fn txd_inv(&self) -> TxdInvR {
                TxdInvR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RXD inverted then input"]
            #[inline(always)]
            pub fn rxd_inv(&self) -> RxdInvR {
                RxdInvR::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - TXD inverted then output"]
            #[inline(always)]
            pub fn txd_inv(&mut self) -> TxdInvW<IocSpec> {
                TxdInvW::new(self, 0)
            }
            #[doc = "Bit 1 - RXD inverted then input"]
            #[inline(always)]
            pub fn rxd_inv(&mut self) -> RxdInvW<IocSpec> {
                RxdInvW::new(self, 1)
            }
        }
        #[doc = "UART IO Control\n\nYou can [`read`](crate::Reg::read) this register and get [`ioc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ioc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IocSpec;
        impl crate::RegisterSpec for IocSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ioc::R`](R) reader structure"]
        impl crate::Readable for IocSpec {}
        #[doc = "`write(|w| ..)` method takes [`ioc::W`](W) writer structure"]
        impl crate::Writable for IocSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IOC to value 0"]
        impl crate::Resettable for IocSpec {}
    }
}
#[doc = "DMA registers"]
pub type Dma = crate::Periph<dma::RegisterBlock, 0x4001_0a00>;
impl core::fmt::Debug for Dma {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dma").finish()
    }
}
#[doc = "DMA registers"]
pub mod dma {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ccr0: Ccr0,
        ren0: Ren0,
        ctms0: Ctms0,
        sadr0: Sadr0,
        dadr0: Dadr0,
        _reserved5: [u8; 0x0c],
        ccr1: Ccr1,
        ren1: Ren1,
        ctms1: Ctms1,
        sadr1: Sadr1,
        dadr1: Dadr1,
        _reserved10: [u8; 0x0c],
        ccr2: Ccr2,
        ren2: Ren2,
        ctms2: Ctms2,
        sadr2: Sadr2,
        dadr2: Dadr2,
        _reserved15: [u8; 0x0c],
        ccr3: Ccr3,
        ren3: Ren3,
        ctms3: Ctms3,
        sadr3: Sadr3,
        dadr3: Dadr3,
        _reserved20: [u8; 0x0c],
        ctrl: Ctrl,
        ie: Ie,
        if_: If,
    }
    impl RegisterBlock {
        #[doc = "0x00 - DMA channel 0 configuration"]
        #[inline(always)]
        pub const fn ccr0(&self) -> &Ccr0 {
            &self.ccr0
        }
        #[doc = "0x04 - DMA channel 0 request enable"]
        #[inline(always)]
        pub const fn ren0(&self) -> &Ren0 {
            &self.ren0
        }
        #[doc = "0x08 - DMA channel 0 transmission times"]
        #[inline(always)]
        pub const fn ctms0(&self) -> &Ctms0 {
            &self.ctms0
        }
        #[doc = "0x0c - DMA channel 0 source address"]
        #[inline(always)]
        pub const fn sadr0(&self) -> &Sadr0 {
            &self.sadr0
        }
        #[doc = "0x10 - DMA channel 0 destination address"]
        #[inline(always)]
        pub const fn dadr0(&self) -> &Dadr0 {
            &self.dadr0
        }
        #[doc = "0x20 - DMA channel 1 configuration"]
        #[inline(always)]
        pub const fn ccr1(&self) -> &Ccr1 {
            &self.ccr1
        }
        #[doc = "0x24 - DMA channel 1 request enable"]
        #[inline(always)]
        pub const fn ren1(&self) -> &Ren1 {
            &self.ren1
        }
        #[doc = "0x28 - DMA channel 1 transmission times"]
        #[inline(always)]
        pub const fn ctms1(&self) -> &Ctms1 {
            &self.ctms1
        }
        #[doc = "0x2c - DMA channel 1 source address"]
        #[inline(always)]
        pub const fn sadr1(&self) -> &Sadr1 {
            &self.sadr1
        }
        #[doc = "0x30 - DMA channel 1 destination address"]
        #[inline(always)]
        pub const fn dadr1(&self) -> &Dadr1 {
            &self.dadr1
        }
        #[doc = "0x40 - DMA channel 2 configuration"]
        #[inline(always)]
        pub const fn ccr2(&self) -> &Ccr2 {
            &self.ccr2
        }
        #[doc = "0x44 - DMA channel 2 request enable"]
        #[inline(always)]
        pub const fn ren2(&self) -> &Ren2 {
            &self.ren2
        }
        #[doc = "0x48 - DMA channel 2 transmission times"]
        #[inline(always)]
        pub const fn ctms2(&self) -> &Ctms2 {
            &self.ctms2
        }
        #[doc = "0x4c - DMA channel 2 source address"]
        #[inline(always)]
        pub const fn sadr2(&self) -> &Sadr2 {
            &self.sadr2
        }
        #[doc = "0x50 - DMA channel 2 destination address"]
        #[inline(always)]
        pub const fn dadr2(&self) -> &Dadr2 {
            &self.dadr2
        }
        #[doc = "0x60 - DMA channel 3 configuration"]
        #[inline(always)]
        pub const fn ccr3(&self) -> &Ccr3 {
            &self.ccr3
        }
        #[doc = "0x64 - DMA channel 3 request enable"]
        #[inline(always)]
        pub const fn ren3(&self) -> &Ren3 {
            &self.ren3
        }
        #[doc = "0x68 - DMA channel 3 transmission times"]
        #[inline(always)]
        pub const fn ctms3(&self) -> &Ctms3 {
            &self.ctms3
        }
        #[doc = "0x6c - DMA channel 3 source address"]
        #[inline(always)]
        pub const fn sadr3(&self) -> &Sadr3 {
            &self.sadr3
        }
        #[doc = "0x70 - DMA channel 3 destination address"]
        #[inline(always)]
        pub const fn dadr3(&self) -> &Dadr3 {
            &self.dadr3
        }
        #[doc = "0x80 - DMA control"]
        #[inline(always)]
        pub const fn ctrl(&self) -> &Ctrl {
            &self.ctrl
        }
        #[doc = "0x84 - DMA interrupt enable"]
        #[inline(always)]
        pub const fn ie(&self) -> &Ie {
            &self.ie
        }
        #[doc = "0x88 - DMA interrupt flag"]
        #[inline(always)]
        pub const fn if_(&self) -> &If {
            &self.if_
        }
    }
    #[doc = "CCR0 (rw) register accessor: DMA channel 0 configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr0`] module"]
    #[doc(alias = "CCR0")]
    pub type Ccr0 = crate::Reg<ccr0::Ccr0Spec>;
    #[doc = "DMA channel 0 configuration"]
    pub mod ccr0 {
        #[doc = "Register `CCR0` reader"]
        pub type R = crate::R<Ccr0Spec>;
        #[doc = "Register `CCR0` writer"]
        pub type W = crate::W<Ccr0Spec>;
        #[doc = "channel enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum En {
            #[doc = "0: Channel is disabled"]
            Disabled = 0,
            #[doc = "1: Channel is enabled"]
            Enabled = 1,
        }
        impl From<En> for bool {
            #[inline(always)]
            fn from(variant: En) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EN` reader - channel enable"]
        pub type EnR = crate::BitReader<En>;
        impl EnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> En {
                match self.bits {
                    false => En::Disabled,
                    true => En::Enabled,
                }
            }
            #[doc = "Channel is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == En::Disabled
            }
            #[doc = "Channel is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == En::Enabled
            }
        }
        #[doc = "Field `EN` writer - channel enable"]
        pub type EnW<'a, REG> = crate::BitWriter<'a, REG, En>;
        impl<'a, REG> EnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Channel is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Disabled)
            }
            #[doc = "Channel is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Enabled)
            }
        }
        #[doc = "Round mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Rmode {
            #[doc = "0: Single round, multi-times"]
            Single = 0,
            #[doc = "1: Multi-round, single time per round"]
            Multi = 1,
        }
        impl From<Rmode> for bool {
            #[inline(always)]
            fn from(variant: Rmode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RMODE` reader - Round mode"]
        pub type RmodeR = crate::BitReader<Rmode>;
        impl RmodeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Rmode {
                match self.bits {
                    false => Rmode::Single,
                    true => Rmode::Multi,
                }
            }
            #[doc = "Single round, multi-times"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == Rmode::Single
            }
            #[doc = "Multi-round, single time per round"]
            #[inline(always)]
            pub fn is_multi(&self) -> bool {
                *self == Rmode::Multi
            }
        }
        #[doc = "Field `RMODE` writer - Round mode"]
        pub type RmodeW<'a, REG> = crate::BitWriter<'a, REG, Rmode>;
        impl<'a, REG> RmodeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Single round, multi-times"]
            #[inline(always)]
            pub fn single(self) -> &'a mut crate::W<REG> {
                self.variant(Rmode::Single)
            }
            #[doc = "Multi-round, single time per round"]
            #[inline(always)]
            pub fn multi(self) -> &'a mut crate::W<REG> {
                self.variant(Rmode::Multi)
            }
        }
        #[doc = "circular mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Circ {
            #[doc = "0: Normal mode"]
            Normal = 0,
            #[doc = "1: Circular mode"]
            Circ = 1,
        }
        impl From<Circ> for bool {
            #[inline(always)]
            fn from(variant: Circ) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIRC` reader - circular mode"]
        pub type CircR = crate::BitReader<Circ>;
        impl CircR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Circ {
                match self.bits {
                    false => Circ::Normal,
                    true => Circ::Circ,
                }
            }
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == Circ::Normal
            }
            #[doc = "Circular mode"]
            #[inline(always)]
            pub fn is_circ(&self) -> bool {
                *self == Circ::Circ
            }
        }
        #[doc = "Field `CIRC` writer - circular mode"]
        pub type CircW<'a, REG> = crate::BitWriter<'a, REG, Circ>;
        impl<'a, REG> CircW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut crate::W<REG> {
                self.variant(Circ::Normal)
            }
            #[doc = "Circular mode"]
            #[inline(always)]
            pub fn circ(self) -> &'a mut crate::W<REG> {
                self.variant(Circ::Circ)
            }
        }
        #[doc = "Destination Address Incremental\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Dinc {
            #[doc = "0: Source addr will be increased by SBTW each transfer"]
            Ninc = 0,
            #[doc = "1: Description addr will be increased by DBTW each transfer"]
            Inc = 1,
        }
        impl From<Dinc> for bool {
            #[inline(always)]
            fn from(variant: Dinc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DINC` reader - Destination Address Incremental"]
        pub type DincR = crate::BitReader<Dinc>;
        impl DincR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Dinc {
                match self.bits {
                    false => Dinc::Ninc,
                    true => Dinc::Inc,
                }
            }
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn is_ninc(&self) -> bool {
                *self == Dinc::Ninc
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn is_inc(&self) -> bool {
                *self == Dinc::Inc
            }
        }
        #[doc = "Field `DINC` writer - Destination Address Incremental"]
        pub type DincW<'a, REG> = crate::BitWriter<'a, REG, Dinc>;
        impl<'a, REG> DincW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn ninc(self) -> &'a mut crate::W<REG> {
                self.variant(Dinc::Ninc)
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn inc(self) -> &'a mut crate::W<REG> {
                self.variant(Dinc::Inc)
            }
        }
        #[doc = "Source Address Incremental\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sinc {
            #[doc = "0: Source addr will be increased by SBTW each transfer"]
            Ninc = 0,
            #[doc = "1: Description addr will be increased by DBTW each transfer"]
            Inc = 1,
        }
        impl From<Sinc> for bool {
            #[inline(always)]
            fn from(variant: Sinc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SINC` reader - Source Address Incremental"]
        pub type SincR = crate::BitReader<Sinc>;
        impl SincR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sinc {
                match self.bits {
                    false => Sinc::Ninc,
                    true => Sinc::Inc,
                }
            }
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn is_ninc(&self) -> bool {
                *self == Sinc::Ninc
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn is_inc(&self) -> bool {
                *self == Sinc::Inc
            }
        }
        #[doc = "Field `SINC` writer - Source Address Incremental"]
        pub type SincW<'a, REG> = crate::BitWriter<'a, REG, Sinc>;
        impl<'a, REG> SincW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn ninc(self) -> &'a mut crate::W<REG> {
                self.variant(Sinc::Ninc)
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn inc(self) -> &'a mut crate::W<REG> {
                self.variant(Sinc::Inc)
            }
        }
        #[doc = "Destination data width\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Dbtw {
            #[doc = "0: 8bit byte"]
            Byte = 0,
            #[doc = "1: 16bit halfword"]
            Halfword = 1,
            #[doc = "2: 32bit word"]
            Word = 2,
        }
        impl From<Dbtw> for u8 {
            #[inline(always)]
            fn from(variant: Dbtw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Dbtw {
            type Ux = u8;
        }
        impl crate::IsEnum for Dbtw {}
        #[doc = "Field `DBTW` reader - Destination data width"]
        pub type DbtwR = crate::FieldReader<Dbtw>;
        impl DbtwR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Dbtw> {
                match self.bits {
                    0 => Some(Dbtw::Byte),
                    1 => Some(Dbtw::Halfword),
                    2 => Some(Dbtw::Word),
                    _ => None,
                }
            }
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == Dbtw::Byte
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn is_halfword(&self) -> bool {
                *self == Dbtw::Halfword
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn is_word(&self) -> bool {
                *self == Dbtw::Word
            }
        }
        #[doc = "Field `DBTW` writer - Destination data width"]
        pub type DbtwW<'a, REG> = crate::FieldWriter<'a, REG, 2, Dbtw>;
        impl<'a, REG> DbtwW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Byte)
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn halfword(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Halfword)
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn word(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Word)
            }
        }
        #[doc = "Source data width\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Sbtw {
            #[doc = "0: 8bit byte"]
            Byte = 0,
            #[doc = "1: 16bit halfword"]
            Halfword = 1,
            #[doc = "2: 32bit word"]
            Word = 2,
        }
        impl From<Sbtw> for u8 {
            #[inline(always)]
            fn from(variant: Sbtw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Sbtw {
            type Ux = u8;
        }
        impl crate::IsEnum for Sbtw {}
        #[doc = "Field `SBTW` reader - Source data width"]
        pub type SbtwR = crate::FieldReader<Sbtw>;
        impl SbtwR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Sbtw> {
                match self.bits {
                    0 => Some(Sbtw::Byte),
                    1 => Some(Sbtw::Halfword),
                    2 => Some(Sbtw::Word),
                    _ => None,
                }
            }
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == Sbtw::Byte
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn is_halfword(&self) -> bool {
                *self == Sbtw::Halfword
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn is_word(&self) -> bool {
                *self == Sbtw::Word
            }
        }
        #[doc = "Field `SBTW` writer - Source data width"]
        pub type SbtwW<'a, REG> = crate::FieldWriter<'a, REG, 2, Sbtw>;
        impl<'a, REG> SbtwW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Byte)
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn halfword(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Halfword)
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn word(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Word)
            }
        }
        impl R {
            #[doc = "Bit 0 - channel enable"]
            #[inline(always)]
            pub fn en(&self) -> EnR {
                EnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Round mode"]
            #[inline(always)]
            pub fn rmode(&self) -> RmodeR {
                RmodeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - circular mode"]
            #[inline(always)]
            pub fn circ(&self) -> CircR {
                CircR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Destination Address Incremental"]
            #[inline(always)]
            pub fn dinc(&self) -> DincR {
                DincR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - Source Address Incremental"]
            #[inline(always)]
            pub fn sinc(&self) -> SincR {
                SincR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bits 8:9 - Destination data width"]
            #[inline(always)]
            pub fn dbtw(&self) -> DbtwR {
                DbtwR::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Source data width"]
            #[inline(always)]
            pub fn sbtw(&self) -> SbtwR {
                SbtwR::new(((self.bits >> 10) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - channel enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EnW<Ccr0Spec> {
                EnW::new(self, 0)
            }
            #[doc = "Bit 1 - Round mode"]
            #[inline(always)]
            pub fn rmode(&mut self) -> RmodeW<Ccr0Spec> {
                RmodeW::new(self, 1)
            }
            #[doc = "Bit 3 - circular mode"]
            #[inline(always)]
            pub fn circ(&mut self) -> CircW<Ccr0Spec> {
                CircW::new(self, 3)
            }
            #[doc = "Bit 4 - Destination Address Incremental"]
            #[inline(always)]
            pub fn dinc(&mut self) -> DincW<Ccr0Spec> {
                DincW::new(self, 4)
            }
            #[doc = "Bit 6 - Source Address Incremental"]
            #[inline(always)]
            pub fn sinc(&mut self) -> SincW<Ccr0Spec> {
                SincW::new(self, 6)
            }
            #[doc = "Bits 8:9 - Destination data width"]
            #[inline(always)]
            pub fn dbtw(&mut self) -> DbtwW<Ccr0Spec> {
                DbtwW::new(self, 8)
            }
            #[doc = "Bits 10:11 - Source data width"]
            #[inline(always)]
            pub fn sbtw(&mut self) -> SbtwW<Ccr0Spec> {
                SbtwW::new(self, 10)
            }
        }
        #[doc = "DMA channel 0 configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ccr0Spec;
        impl crate::RegisterSpec for Ccr0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ccr0::R`](R) reader structure"]
        impl crate::Readable for Ccr0Spec {}
        #[doc = "`write(|w| ..)` method takes [`ccr0::W`](W) writer structure"]
        impl crate::Writable for Ccr0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CCR0 to value 0"]
        impl crate::Resettable for Ccr0Spec {}
    }
    #[doc = "REN0 (rw) register accessor: DMA channel 0 request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ren0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ren0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ren0`] module"]
    #[doc(alias = "REN0")]
    pub type Ren0 = crate::Reg<ren0::Ren0Spec>;
    #[doc = "DMA channel 0 request enable"]
    pub mod ren0 {
        #[doc = "Register `REN0` reader"]
        pub type R = crate::R<Ren0Spec>;
        #[doc = "Register `REN0` writer"]
        pub type W = crate::W<Ren0Spec>;
        #[doc = "Field `ADC_TRIG` reader - ADC trigger enable"]
        pub type AdcTrigR = crate::BitReader;
        #[doc = "Field `ADC_TRIG` writer - ADC trigger enable"]
        pub type AdcTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCPWM_TRIG` reader - MCPWM trigger enable"]
        pub type McpwmTrigR = crate::BitReader;
        #[doc = "Field `MCPWM_TRIG` writer - MCPWM trigger enable"]
        pub type McpwmTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HALL_TRIG` reader - HALL trigger enable"]
        pub type HallTrigR = crate::BitReader;
        #[doc = "Field `HALL_TRIG` writer - HALL trigger enable"]
        pub type HallTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER0_TRIG` reader - TIMER0 trigger enable"]
        pub type Timer0TrigR = crate::BitReader;
        #[doc = "Field `TIMER0_TRIG` writer - TIMER0 trigger enable"]
        pub type Timer0TrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER1_TRIG` reader - TIMER1 trigger enable"]
        pub type Timer1TrigR = crate::BitReader;
        #[doc = "Field `TIMER1_TRIG` writer - TIMER1 trigger enable"]
        pub type Timer1TrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UART_RX_TRIG` reader - UART_RX trigger enable"]
        pub type UartRxTrigR = crate::BitReader;
        #[doc = "Field `UART_RX_TRIG` writer - UART_RX trigger enable"]
        pub type UartRxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UART_TX_TRIG` reader - UART_TX trigger enable"]
        pub type UartTxTrigR = crate::BitReader;
        #[doc = "Field `UART_TX_TRIG` writer - UART_TX trigger enable"]
        pub type UartTxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SPI_RX_TRIG` reader - SPI_RX trigger enable"]
        pub type SpiRxTrigR = crate::BitReader;
        #[doc = "Field `SPI_RX_TRIG` writer - SPI_RX trigger enable"]
        pub type SpiRxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SPI_TX_TRIG` reader - SPI_TX trigger enable"]
        pub type SpiTxTrigR = crate::BitReader;
        #[doc = "Field `SPI_TX_TRIG` writer - SPI_TX trigger enable"]
        pub type SpiTxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP_TRIG` reader - CMP trigger enable"]
        pub type CmpTrigR = crate::BitReader;
        #[doc = "Field `CMP_TRIG` writer - CMP trigger enable"]
        pub type CmpTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GPIO_TRIG` reader - GPIO trigger enable"]
        pub type GpioTrigR = crate::BitReader;
        #[doc = "Field `GPIO_TRIG` writer - GPIO trigger enable"]
        pub type GpioTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `I2C_TRIG` reader - I2C trigger enable"]
        pub type I2cTrigR = crate::BitReader;
        #[doc = "Field `I2C_TRIG` writer - I2C trigger enable"]
        pub type I2cTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SW_TRIG` reader - Software trigger enable"]
        pub type SwTrigR = crate::BitReader;
        #[doc = "Field `SW_TRIG` writer - Software trigger enable"]
        pub type SwTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - ADC trigger enable"]
            #[inline(always)]
            pub fn adc_trig(&self) -> AdcTrigR {
                AdcTrigR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - MCPWM trigger enable"]
            #[inline(always)]
            pub fn mcpwm_trig(&self) -> McpwmTrigR {
                McpwmTrigR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - HALL trigger enable"]
            #[inline(always)]
            pub fn hall_trig(&self) -> HallTrigR {
                HallTrigR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - TIMER0 trigger enable"]
            #[inline(always)]
            pub fn timer0_trig(&self) -> Timer0TrigR {
                Timer0TrigR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TIMER1 trigger enable"]
            #[inline(always)]
            pub fn timer1_trig(&self) -> Timer1TrigR {
                Timer1TrigR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - UART_RX trigger enable"]
            #[inline(always)]
            pub fn uart_rx_trig(&self) -> UartRxTrigR {
                UartRxTrigR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - UART_TX trigger enable"]
            #[inline(always)]
            pub fn uart_tx_trig(&self) -> UartTxTrigR {
                UartTxTrigR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 10 - SPI_RX trigger enable"]
            #[inline(always)]
            pub fn spi_rx_trig(&self) -> SpiRxTrigR {
                SpiRxTrigR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - SPI_TX trigger enable"]
            #[inline(always)]
            pub fn spi_tx_trig(&self) -> SpiTxTrigR {
                SpiTxTrigR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - CMP trigger enable"]
            #[inline(always)]
            pub fn cmp_trig(&self) -> CmpTrigR {
                CmpTrigR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - GPIO trigger enable"]
            #[inline(always)]
            pub fn gpio_trig(&self) -> GpioTrigR {
                GpioTrigR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - I2C trigger enable"]
            #[inline(always)]
            pub fn i2c_trig(&self) -> I2cTrigR {
                I2cTrigR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Software trigger enable"]
            #[inline(always)]
            pub fn sw_trig(&self) -> SwTrigR {
                SwTrigR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ADC trigger enable"]
            #[inline(always)]
            pub fn adc_trig(&mut self) -> AdcTrigW<Ren0Spec> {
                AdcTrigW::new(self, 0)
            }
            #[doc = "Bit 1 - MCPWM trigger enable"]
            #[inline(always)]
            pub fn mcpwm_trig(&mut self) -> McpwmTrigW<Ren0Spec> {
                McpwmTrigW::new(self, 1)
            }
            #[doc = "Bit 2 - HALL trigger enable"]
            #[inline(always)]
            pub fn hall_trig(&mut self) -> HallTrigW<Ren0Spec> {
                HallTrigW::new(self, 2)
            }
            #[doc = "Bit 4 - TIMER0 trigger enable"]
            #[inline(always)]
            pub fn timer0_trig(&mut self) -> Timer0TrigW<Ren0Spec> {
                Timer0TrigW::new(self, 4)
            }
            #[doc = "Bit 5 - TIMER1 trigger enable"]
            #[inline(always)]
            pub fn timer1_trig(&mut self) -> Timer1TrigW<Ren0Spec> {
                Timer1TrigW::new(self, 5)
            }
            #[doc = "Bit 6 - UART_RX trigger enable"]
            #[inline(always)]
            pub fn uart_rx_trig(&mut self) -> UartRxTrigW<Ren0Spec> {
                UartRxTrigW::new(self, 6)
            }
            #[doc = "Bit 7 - UART_TX trigger enable"]
            #[inline(always)]
            pub fn uart_tx_trig(&mut self) -> UartTxTrigW<Ren0Spec> {
                UartTxTrigW::new(self, 7)
            }
            #[doc = "Bit 10 - SPI_RX trigger enable"]
            #[inline(always)]
            pub fn spi_rx_trig(&mut self) -> SpiRxTrigW<Ren0Spec> {
                SpiRxTrigW::new(self, 10)
            }
            #[doc = "Bit 11 - SPI_TX trigger enable"]
            #[inline(always)]
            pub fn spi_tx_trig(&mut self) -> SpiTxTrigW<Ren0Spec> {
                SpiTxTrigW::new(self, 11)
            }
            #[doc = "Bit 12 - CMP trigger enable"]
            #[inline(always)]
            pub fn cmp_trig(&mut self) -> CmpTrigW<Ren0Spec> {
                CmpTrigW::new(self, 12)
            }
            #[doc = "Bit 13 - GPIO trigger enable"]
            #[inline(always)]
            pub fn gpio_trig(&mut self) -> GpioTrigW<Ren0Spec> {
                GpioTrigW::new(self, 13)
            }
            #[doc = "Bit 14 - I2C trigger enable"]
            #[inline(always)]
            pub fn i2c_trig(&mut self) -> I2cTrigW<Ren0Spec> {
                I2cTrigW::new(self, 14)
            }
            #[doc = "Bit 15 - Software trigger enable"]
            #[inline(always)]
            pub fn sw_trig(&mut self) -> SwTrigW<Ren0Spec> {
                SwTrigW::new(self, 15)
            }
        }
        #[doc = "DMA channel 0 request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ren0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ren0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ren0Spec;
        impl crate::RegisterSpec for Ren0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ren0::R`](R) reader structure"]
        impl crate::Readable for Ren0Spec {}
        #[doc = "`write(|w| ..)` method takes [`ren0::W`](W) writer structure"]
        impl crate::Writable for Ren0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets REN0 to value 0"]
        impl crate::Resettable for Ren0Spec {}
    }
    #[doc = "CTMS0 (rw) register accessor: DMA channel 0 transmission times\n\nYou can [`read`](crate::Reg::read) this register and get [`ctms0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctms0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctms0`] module"]
    #[doc(alias = "CTMS0")]
    pub type Ctms0 = crate::Reg<ctms0::Ctms0Spec>;
    #[doc = "DMA channel 0 transmission times"]
    pub mod ctms0 {
        #[doc = "Register `CTMS0` reader"]
        pub type R = crate::R<Ctms0Spec>;
        #[doc = "Register `CTMS0` writer"]
        pub type W = crate::W<Ctms0Spec>;
        #[doc = "Field `TMS` reader - times or rounds"]
        pub type TmsR = crate::FieldReader;
        #[doc = "Field `TMS` writer - times or rounds"]
        pub type TmsW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - times or rounds"]
            #[inline(always)]
            pub fn tms(&self) -> TmsR {
                TmsR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - times or rounds"]
            #[inline(always)]
            pub fn tms(&mut self) -> TmsW<Ctms0Spec> {
                TmsW::new(self, 0)
            }
        }
        #[doc = "DMA channel 0 transmission times\n\nYou can [`read`](crate::Reg::read) this register and get [`ctms0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctms0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ctms0Spec;
        impl crate::RegisterSpec for Ctms0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctms0::R`](R) reader structure"]
        impl crate::Readable for Ctms0Spec {}
        #[doc = "`write(|w| ..)` method takes [`ctms0::W`](W) writer structure"]
        impl crate::Writable for Ctms0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTMS0 to value 0"]
        impl crate::Resettable for Ctms0Spec {}
    }
    #[doc = "SADR0 (rw) register accessor: DMA channel 0 source address\n\nYou can [`read`](crate::Reg::read) this register and get [`sadr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sadr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sadr0`] module"]
    #[doc(alias = "SADR0")]
    pub type Sadr0 = crate::Reg<sadr0::Sadr0Spec>;
    #[doc = "DMA channel 0 source address"]
    pub mod sadr0 {
        #[doc = "Register `SADR0` reader"]
        pub type R = crate::R<Sadr0Spec>;
        #[doc = "Register `SADR0` writer"]
        pub type W = crate::W<Sadr0Spec>;
        #[doc = "Field `ADDR` reader - Source Address"]
        pub type AddrR = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Source Address"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Source Address"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Source Address"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<Sadr0Spec> {
                AddrW::new(self, 0)
            }
        }
        #[doc = "DMA channel 0 source address\n\nYou can [`read`](crate::Reg::read) this register and get [`sadr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sadr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Sadr0Spec;
        impl crate::RegisterSpec for Sadr0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sadr0::R`](R) reader structure"]
        impl crate::Readable for Sadr0Spec {}
        #[doc = "`write(|w| ..)` method takes [`sadr0::W`](W) writer structure"]
        impl crate::Writable for Sadr0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SADR0 to value 0"]
        impl crate::Resettable for Sadr0Spec {}
    }
    #[doc = "DADR0 (rw) register accessor: DMA channel 0 destination address\n\nYou can [`read`](crate::Reg::read) this register and get [`dadr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dadr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dadr0`] module"]
    #[doc(alias = "DADR0")]
    pub type Dadr0 = crate::Reg<dadr0::Dadr0Spec>;
    #[doc = "DMA channel 0 destination address"]
    pub mod dadr0 {
        #[doc = "Register `DADR0` reader"]
        pub type R = crate::R<Dadr0Spec>;
        #[doc = "Register `DADR0` writer"]
        pub type W = crate::W<Dadr0Spec>;
        #[doc = "Field `ADDR` reader - Destination Address"]
        pub type AddrR = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Destination Address"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Destination Address"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Destination Address"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<Dadr0Spec> {
                AddrW::new(self, 0)
            }
        }
        #[doc = "DMA channel 0 destination address\n\nYou can [`read`](crate::Reg::read) this register and get [`dadr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dadr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dadr0Spec;
        impl crate::RegisterSpec for Dadr0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dadr0::R`](R) reader structure"]
        impl crate::Readable for Dadr0Spec {}
        #[doc = "`write(|w| ..)` method takes [`dadr0::W`](W) writer structure"]
        impl crate::Writable for Dadr0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DADR0 to value 0"]
        impl crate::Resettable for Dadr0Spec {}
    }
    #[doc = "CCR1 (rw) register accessor: DMA channel 1 configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
    #[doc(alias = "CCR1")]
    pub type Ccr1 = crate::Reg<ccr1::Ccr1Spec>;
    #[doc = "DMA channel 1 configuration"]
    pub mod ccr1 {
        #[doc = "Register `CCR1` reader"]
        pub type R = crate::R<Ccr1Spec>;
        #[doc = "Register `CCR1` writer"]
        pub type W = crate::W<Ccr1Spec>;
        #[doc = "channel enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum En {
            #[doc = "0: Channel is disabled"]
            Disabled = 0,
            #[doc = "1: Channel is enabled"]
            Enabled = 1,
        }
        impl From<En> for bool {
            #[inline(always)]
            fn from(variant: En) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EN` reader - channel enable"]
        pub type EnR = crate::BitReader<En>;
        impl EnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> En {
                match self.bits {
                    false => En::Disabled,
                    true => En::Enabled,
                }
            }
            #[doc = "Channel is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == En::Disabled
            }
            #[doc = "Channel is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == En::Enabled
            }
        }
        #[doc = "Field `EN` writer - channel enable"]
        pub type EnW<'a, REG> = crate::BitWriter<'a, REG, En>;
        impl<'a, REG> EnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Channel is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Disabled)
            }
            #[doc = "Channel is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Enabled)
            }
        }
        #[doc = "Round mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Rmode {
            #[doc = "0: Single round, multi-times"]
            Single = 0,
            #[doc = "1: Multi-round, single time per round"]
            Multi = 1,
        }
        impl From<Rmode> for bool {
            #[inline(always)]
            fn from(variant: Rmode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RMODE` reader - Round mode"]
        pub type RmodeR = crate::BitReader<Rmode>;
        impl RmodeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Rmode {
                match self.bits {
                    false => Rmode::Single,
                    true => Rmode::Multi,
                }
            }
            #[doc = "Single round, multi-times"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == Rmode::Single
            }
            #[doc = "Multi-round, single time per round"]
            #[inline(always)]
            pub fn is_multi(&self) -> bool {
                *self == Rmode::Multi
            }
        }
        #[doc = "Field `RMODE` writer - Round mode"]
        pub type RmodeW<'a, REG> = crate::BitWriter<'a, REG, Rmode>;
        impl<'a, REG> RmodeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Single round, multi-times"]
            #[inline(always)]
            pub fn single(self) -> &'a mut crate::W<REG> {
                self.variant(Rmode::Single)
            }
            #[doc = "Multi-round, single time per round"]
            #[inline(always)]
            pub fn multi(self) -> &'a mut crate::W<REG> {
                self.variant(Rmode::Multi)
            }
        }
        #[doc = "circular mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Circ {
            #[doc = "0: Normal mode"]
            Normal = 0,
            #[doc = "1: Circular mode"]
            Circ = 1,
        }
        impl From<Circ> for bool {
            #[inline(always)]
            fn from(variant: Circ) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIRC` reader - circular mode"]
        pub type CircR = crate::BitReader<Circ>;
        impl CircR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Circ {
                match self.bits {
                    false => Circ::Normal,
                    true => Circ::Circ,
                }
            }
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == Circ::Normal
            }
            #[doc = "Circular mode"]
            #[inline(always)]
            pub fn is_circ(&self) -> bool {
                *self == Circ::Circ
            }
        }
        #[doc = "Field `CIRC` writer - circular mode"]
        pub type CircW<'a, REG> = crate::BitWriter<'a, REG, Circ>;
        impl<'a, REG> CircW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut crate::W<REG> {
                self.variant(Circ::Normal)
            }
            #[doc = "Circular mode"]
            #[inline(always)]
            pub fn circ(self) -> &'a mut crate::W<REG> {
                self.variant(Circ::Circ)
            }
        }
        #[doc = "Destination Address Incremental\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Dinc {
            #[doc = "0: Source addr will be increased by SBTW each transfer"]
            Ninc = 0,
            #[doc = "1: Description addr will be increased by DBTW each transfer"]
            Inc = 1,
        }
        impl From<Dinc> for bool {
            #[inline(always)]
            fn from(variant: Dinc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DINC` reader - Destination Address Incremental"]
        pub type DincR = crate::BitReader<Dinc>;
        impl DincR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Dinc {
                match self.bits {
                    false => Dinc::Ninc,
                    true => Dinc::Inc,
                }
            }
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn is_ninc(&self) -> bool {
                *self == Dinc::Ninc
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn is_inc(&self) -> bool {
                *self == Dinc::Inc
            }
        }
        #[doc = "Field `DINC` writer - Destination Address Incremental"]
        pub type DincW<'a, REG> = crate::BitWriter<'a, REG, Dinc>;
        impl<'a, REG> DincW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn ninc(self) -> &'a mut crate::W<REG> {
                self.variant(Dinc::Ninc)
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn inc(self) -> &'a mut crate::W<REG> {
                self.variant(Dinc::Inc)
            }
        }
        #[doc = "Source Address Incremental\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sinc {
            #[doc = "0: Source addr will be increased by SBTW each transfer"]
            Ninc = 0,
            #[doc = "1: Description addr will be increased by DBTW each transfer"]
            Inc = 1,
        }
        impl From<Sinc> for bool {
            #[inline(always)]
            fn from(variant: Sinc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SINC` reader - Source Address Incremental"]
        pub type SincR = crate::BitReader<Sinc>;
        impl SincR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sinc {
                match self.bits {
                    false => Sinc::Ninc,
                    true => Sinc::Inc,
                }
            }
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn is_ninc(&self) -> bool {
                *self == Sinc::Ninc
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn is_inc(&self) -> bool {
                *self == Sinc::Inc
            }
        }
        #[doc = "Field `SINC` writer - Source Address Incremental"]
        pub type SincW<'a, REG> = crate::BitWriter<'a, REG, Sinc>;
        impl<'a, REG> SincW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn ninc(self) -> &'a mut crate::W<REG> {
                self.variant(Sinc::Ninc)
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn inc(self) -> &'a mut crate::W<REG> {
                self.variant(Sinc::Inc)
            }
        }
        #[doc = "Destination data width\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Dbtw {
            #[doc = "0: 8bit byte"]
            Byte = 0,
            #[doc = "1: 16bit halfword"]
            Halfword = 1,
            #[doc = "2: 32bit word"]
            Word = 2,
        }
        impl From<Dbtw> for u8 {
            #[inline(always)]
            fn from(variant: Dbtw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Dbtw {
            type Ux = u8;
        }
        impl crate::IsEnum for Dbtw {}
        #[doc = "Field `DBTW` reader - Destination data width"]
        pub type DbtwR = crate::FieldReader<Dbtw>;
        impl DbtwR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Dbtw> {
                match self.bits {
                    0 => Some(Dbtw::Byte),
                    1 => Some(Dbtw::Halfword),
                    2 => Some(Dbtw::Word),
                    _ => None,
                }
            }
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == Dbtw::Byte
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn is_halfword(&self) -> bool {
                *self == Dbtw::Halfword
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn is_word(&self) -> bool {
                *self == Dbtw::Word
            }
        }
        #[doc = "Field `DBTW` writer - Destination data width"]
        pub type DbtwW<'a, REG> = crate::FieldWriter<'a, REG, 2, Dbtw>;
        impl<'a, REG> DbtwW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Byte)
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn halfword(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Halfword)
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn word(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Word)
            }
        }
        #[doc = "Source data width\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Sbtw {
            #[doc = "0: 8bit byte"]
            Byte = 0,
            #[doc = "1: 16bit halfword"]
            Halfword = 1,
            #[doc = "2: 32bit word"]
            Word = 2,
        }
        impl From<Sbtw> for u8 {
            #[inline(always)]
            fn from(variant: Sbtw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Sbtw {
            type Ux = u8;
        }
        impl crate::IsEnum for Sbtw {}
        #[doc = "Field `SBTW` reader - Source data width"]
        pub type SbtwR = crate::FieldReader<Sbtw>;
        impl SbtwR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Sbtw> {
                match self.bits {
                    0 => Some(Sbtw::Byte),
                    1 => Some(Sbtw::Halfword),
                    2 => Some(Sbtw::Word),
                    _ => None,
                }
            }
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == Sbtw::Byte
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn is_halfword(&self) -> bool {
                *self == Sbtw::Halfword
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn is_word(&self) -> bool {
                *self == Sbtw::Word
            }
        }
        #[doc = "Field `SBTW` writer - Source data width"]
        pub type SbtwW<'a, REG> = crate::FieldWriter<'a, REG, 2, Sbtw>;
        impl<'a, REG> SbtwW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Byte)
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn halfword(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Halfword)
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn word(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Word)
            }
        }
        impl R {
            #[doc = "Bit 0 - channel enable"]
            #[inline(always)]
            pub fn en(&self) -> EnR {
                EnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Round mode"]
            #[inline(always)]
            pub fn rmode(&self) -> RmodeR {
                RmodeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - circular mode"]
            #[inline(always)]
            pub fn circ(&self) -> CircR {
                CircR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Destination Address Incremental"]
            #[inline(always)]
            pub fn dinc(&self) -> DincR {
                DincR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - Source Address Incremental"]
            #[inline(always)]
            pub fn sinc(&self) -> SincR {
                SincR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bits 8:9 - Destination data width"]
            #[inline(always)]
            pub fn dbtw(&self) -> DbtwR {
                DbtwR::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Source data width"]
            #[inline(always)]
            pub fn sbtw(&self) -> SbtwR {
                SbtwR::new(((self.bits >> 10) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - channel enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EnW<Ccr1Spec> {
                EnW::new(self, 0)
            }
            #[doc = "Bit 1 - Round mode"]
            #[inline(always)]
            pub fn rmode(&mut self) -> RmodeW<Ccr1Spec> {
                RmodeW::new(self, 1)
            }
            #[doc = "Bit 3 - circular mode"]
            #[inline(always)]
            pub fn circ(&mut self) -> CircW<Ccr1Spec> {
                CircW::new(self, 3)
            }
            #[doc = "Bit 4 - Destination Address Incremental"]
            #[inline(always)]
            pub fn dinc(&mut self) -> DincW<Ccr1Spec> {
                DincW::new(self, 4)
            }
            #[doc = "Bit 6 - Source Address Incremental"]
            #[inline(always)]
            pub fn sinc(&mut self) -> SincW<Ccr1Spec> {
                SincW::new(self, 6)
            }
            #[doc = "Bits 8:9 - Destination data width"]
            #[inline(always)]
            pub fn dbtw(&mut self) -> DbtwW<Ccr1Spec> {
                DbtwW::new(self, 8)
            }
            #[doc = "Bits 10:11 - Source data width"]
            #[inline(always)]
            pub fn sbtw(&mut self) -> SbtwW<Ccr1Spec> {
                SbtwW::new(self, 10)
            }
        }
        #[doc = "DMA channel 1 configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ccr1Spec;
        impl crate::RegisterSpec for Ccr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ccr1::R`](R) reader structure"]
        impl crate::Readable for Ccr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"]
        impl crate::Writable for Ccr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CCR1 to value 0"]
        impl crate::Resettable for Ccr1Spec {}
    }
    #[doc = "REN1 (rw) register accessor: DMA channel 1 request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ren1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ren1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ren1`] module"]
    #[doc(alias = "REN1")]
    pub type Ren1 = crate::Reg<ren1::Ren1Spec>;
    #[doc = "DMA channel 1 request enable"]
    pub mod ren1 {
        #[doc = "Register `REN1` reader"]
        pub type R = crate::R<Ren1Spec>;
        #[doc = "Register `REN1` writer"]
        pub type W = crate::W<Ren1Spec>;
        #[doc = "Field `ADC_TRIG` reader - ADC trigger enable"]
        pub type AdcTrigR = crate::BitReader;
        #[doc = "Field `ADC_TRIG` writer - ADC trigger enable"]
        pub type AdcTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCPWM_TRIG` reader - MCPWM trigger enable"]
        pub type McpwmTrigR = crate::BitReader;
        #[doc = "Field `MCPWM_TRIG` writer - MCPWM trigger enable"]
        pub type McpwmTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HALL_TRIG` reader - HALL trigger enable"]
        pub type HallTrigR = crate::BitReader;
        #[doc = "Field `HALL_TRIG` writer - HALL trigger enable"]
        pub type HallTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER0_TRIG` reader - TIMER0 trigger enable"]
        pub type Timer0TrigR = crate::BitReader;
        #[doc = "Field `TIMER0_TRIG` writer - TIMER0 trigger enable"]
        pub type Timer0TrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER1_TRIG` reader - TIMER1 trigger enable"]
        pub type Timer1TrigR = crate::BitReader;
        #[doc = "Field `TIMER1_TRIG` writer - TIMER1 trigger enable"]
        pub type Timer1TrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UART_RX_TRIG` reader - UART_RX trigger enable"]
        pub type UartRxTrigR = crate::BitReader;
        #[doc = "Field `UART_RX_TRIG` writer - UART_RX trigger enable"]
        pub type UartRxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UART_TX_TRIG` reader - UART_TX trigger enable"]
        pub type UartTxTrigR = crate::BitReader;
        #[doc = "Field `UART_TX_TRIG` writer - UART_TX trigger enable"]
        pub type UartTxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SPI_RX_TRIG` reader - SPI_RX trigger enable"]
        pub type SpiRxTrigR = crate::BitReader;
        #[doc = "Field `SPI_RX_TRIG` writer - SPI_RX trigger enable"]
        pub type SpiRxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SPI_TX_TRIG` reader - SPI_TX trigger enable"]
        pub type SpiTxTrigR = crate::BitReader;
        #[doc = "Field `SPI_TX_TRIG` writer - SPI_TX trigger enable"]
        pub type SpiTxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP_TRIG` reader - CMP trigger enable"]
        pub type CmpTrigR = crate::BitReader;
        #[doc = "Field `CMP_TRIG` writer - CMP trigger enable"]
        pub type CmpTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GPIO_TRIG` reader - GPIO trigger enable"]
        pub type GpioTrigR = crate::BitReader;
        #[doc = "Field `GPIO_TRIG` writer - GPIO trigger enable"]
        pub type GpioTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `I2C_TRIG` reader - I2C trigger enable"]
        pub type I2cTrigR = crate::BitReader;
        #[doc = "Field `I2C_TRIG` writer - I2C trigger enable"]
        pub type I2cTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SW_TRIG` reader - Software trigger enable"]
        pub type SwTrigR = crate::BitReader;
        #[doc = "Field `SW_TRIG` writer - Software trigger enable"]
        pub type SwTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - ADC trigger enable"]
            #[inline(always)]
            pub fn adc_trig(&self) -> AdcTrigR {
                AdcTrigR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - MCPWM trigger enable"]
            #[inline(always)]
            pub fn mcpwm_trig(&self) -> McpwmTrigR {
                McpwmTrigR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - HALL trigger enable"]
            #[inline(always)]
            pub fn hall_trig(&self) -> HallTrigR {
                HallTrigR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - TIMER0 trigger enable"]
            #[inline(always)]
            pub fn timer0_trig(&self) -> Timer0TrigR {
                Timer0TrigR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TIMER1 trigger enable"]
            #[inline(always)]
            pub fn timer1_trig(&self) -> Timer1TrigR {
                Timer1TrigR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - UART_RX trigger enable"]
            #[inline(always)]
            pub fn uart_rx_trig(&self) -> UartRxTrigR {
                UartRxTrigR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - UART_TX trigger enable"]
            #[inline(always)]
            pub fn uart_tx_trig(&self) -> UartTxTrigR {
                UartTxTrigR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 10 - SPI_RX trigger enable"]
            #[inline(always)]
            pub fn spi_rx_trig(&self) -> SpiRxTrigR {
                SpiRxTrigR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - SPI_TX trigger enable"]
            #[inline(always)]
            pub fn spi_tx_trig(&self) -> SpiTxTrigR {
                SpiTxTrigR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - CMP trigger enable"]
            #[inline(always)]
            pub fn cmp_trig(&self) -> CmpTrigR {
                CmpTrigR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - GPIO trigger enable"]
            #[inline(always)]
            pub fn gpio_trig(&self) -> GpioTrigR {
                GpioTrigR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - I2C trigger enable"]
            #[inline(always)]
            pub fn i2c_trig(&self) -> I2cTrigR {
                I2cTrigR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Software trigger enable"]
            #[inline(always)]
            pub fn sw_trig(&self) -> SwTrigR {
                SwTrigR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ADC trigger enable"]
            #[inline(always)]
            pub fn adc_trig(&mut self) -> AdcTrigW<Ren1Spec> {
                AdcTrigW::new(self, 0)
            }
            #[doc = "Bit 1 - MCPWM trigger enable"]
            #[inline(always)]
            pub fn mcpwm_trig(&mut self) -> McpwmTrigW<Ren1Spec> {
                McpwmTrigW::new(self, 1)
            }
            #[doc = "Bit 2 - HALL trigger enable"]
            #[inline(always)]
            pub fn hall_trig(&mut self) -> HallTrigW<Ren1Spec> {
                HallTrigW::new(self, 2)
            }
            #[doc = "Bit 4 - TIMER0 trigger enable"]
            #[inline(always)]
            pub fn timer0_trig(&mut self) -> Timer0TrigW<Ren1Spec> {
                Timer0TrigW::new(self, 4)
            }
            #[doc = "Bit 5 - TIMER1 trigger enable"]
            #[inline(always)]
            pub fn timer1_trig(&mut self) -> Timer1TrigW<Ren1Spec> {
                Timer1TrigW::new(self, 5)
            }
            #[doc = "Bit 6 - UART_RX trigger enable"]
            #[inline(always)]
            pub fn uart_rx_trig(&mut self) -> UartRxTrigW<Ren1Spec> {
                UartRxTrigW::new(self, 6)
            }
            #[doc = "Bit 7 - UART_TX trigger enable"]
            #[inline(always)]
            pub fn uart_tx_trig(&mut self) -> UartTxTrigW<Ren1Spec> {
                UartTxTrigW::new(self, 7)
            }
            #[doc = "Bit 10 - SPI_RX trigger enable"]
            #[inline(always)]
            pub fn spi_rx_trig(&mut self) -> SpiRxTrigW<Ren1Spec> {
                SpiRxTrigW::new(self, 10)
            }
            #[doc = "Bit 11 - SPI_TX trigger enable"]
            #[inline(always)]
            pub fn spi_tx_trig(&mut self) -> SpiTxTrigW<Ren1Spec> {
                SpiTxTrigW::new(self, 11)
            }
            #[doc = "Bit 12 - CMP trigger enable"]
            #[inline(always)]
            pub fn cmp_trig(&mut self) -> CmpTrigW<Ren1Spec> {
                CmpTrigW::new(self, 12)
            }
            #[doc = "Bit 13 - GPIO trigger enable"]
            #[inline(always)]
            pub fn gpio_trig(&mut self) -> GpioTrigW<Ren1Spec> {
                GpioTrigW::new(self, 13)
            }
            #[doc = "Bit 14 - I2C trigger enable"]
            #[inline(always)]
            pub fn i2c_trig(&mut self) -> I2cTrigW<Ren1Spec> {
                I2cTrigW::new(self, 14)
            }
            #[doc = "Bit 15 - Software trigger enable"]
            #[inline(always)]
            pub fn sw_trig(&mut self) -> SwTrigW<Ren1Spec> {
                SwTrigW::new(self, 15)
            }
        }
        #[doc = "DMA channel 1 request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ren1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ren1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ren1Spec;
        impl crate::RegisterSpec for Ren1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ren1::R`](R) reader structure"]
        impl crate::Readable for Ren1Spec {}
        #[doc = "`write(|w| ..)` method takes [`ren1::W`](W) writer structure"]
        impl crate::Writable for Ren1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets REN1 to value 0"]
        impl crate::Resettable for Ren1Spec {}
    }
    #[doc = "CTMS1 (rw) register accessor: DMA channel 1 transmission times\n\nYou can [`read`](crate::Reg::read) this register and get [`ctms1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctms1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctms1`] module"]
    #[doc(alias = "CTMS1")]
    pub type Ctms1 = crate::Reg<ctms1::Ctms1Spec>;
    #[doc = "DMA channel 1 transmission times"]
    pub mod ctms1 {
        #[doc = "Register `CTMS1` reader"]
        pub type R = crate::R<Ctms1Spec>;
        #[doc = "Register `CTMS1` writer"]
        pub type W = crate::W<Ctms1Spec>;
        #[doc = "Field `TMS` reader - times or rounds"]
        pub type TmsR = crate::FieldReader;
        #[doc = "Field `TMS` writer - times or rounds"]
        pub type TmsW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - times or rounds"]
            #[inline(always)]
            pub fn tms(&self) -> TmsR {
                TmsR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - times or rounds"]
            #[inline(always)]
            pub fn tms(&mut self) -> TmsW<Ctms1Spec> {
                TmsW::new(self, 0)
            }
        }
        #[doc = "DMA channel 1 transmission times\n\nYou can [`read`](crate::Reg::read) this register and get [`ctms1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctms1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ctms1Spec;
        impl crate::RegisterSpec for Ctms1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctms1::R`](R) reader structure"]
        impl crate::Readable for Ctms1Spec {}
        #[doc = "`write(|w| ..)` method takes [`ctms1::W`](W) writer structure"]
        impl crate::Writable for Ctms1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTMS1 to value 0"]
        impl crate::Resettable for Ctms1Spec {}
    }
    #[doc = "SADR1 (rw) register accessor: DMA channel 1 source address\n\nYou can [`read`](crate::Reg::read) this register and get [`sadr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sadr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sadr1`] module"]
    #[doc(alias = "SADR1")]
    pub type Sadr1 = crate::Reg<sadr1::Sadr1Spec>;
    #[doc = "DMA channel 1 source address"]
    pub mod sadr1 {
        #[doc = "Register `SADR1` reader"]
        pub type R = crate::R<Sadr1Spec>;
        #[doc = "Register `SADR1` writer"]
        pub type W = crate::W<Sadr1Spec>;
        #[doc = "Field `ADDR` reader - Source Address"]
        pub type AddrR = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Source Address"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Source Address"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Source Address"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<Sadr1Spec> {
                AddrW::new(self, 0)
            }
        }
        #[doc = "DMA channel 1 source address\n\nYou can [`read`](crate::Reg::read) this register and get [`sadr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sadr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Sadr1Spec;
        impl crate::RegisterSpec for Sadr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sadr1::R`](R) reader structure"]
        impl crate::Readable for Sadr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`sadr1::W`](W) writer structure"]
        impl crate::Writable for Sadr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SADR1 to value 0"]
        impl crate::Resettable for Sadr1Spec {}
    }
    #[doc = "DADR1 (rw) register accessor: DMA channel 1 destination address\n\nYou can [`read`](crate::Reg::read) this register and get [`dadr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dadr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dadr1`] module"]
    #[doc(alias = "DADR1")]
    pub type Dadr1 = crate::Reg<dadr1::Dadr1Spec>;
    #[doc = "DMA channel 1 destination address"]
    pub mod dadr1 {
        #[doc = "Register `DADR1` reader"]
        pub type R = crate::R<Dadr1Spec>;
        #[doc = "Register `DADR1` writer"]
        pub type W = crate::W<Dadr1Spec>;
        #[doc = "Field `ADDR` reader - Destination Address"]
        pub type AddrR = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Destination Address"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Destination Address"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Destination Address"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<Dadr1Spec> {
                AddrW::new(self, 0)
            }
        }
        #[doc = "DMA channel 1 destination address\n\nYou can [`read`](crate::Reg::read) this register and get [`dadr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dadr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dadr1Spec;
        impl crate::RegisterSpec for Dadr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dadr1::R`](R) reader structure"]
        impl crate::Readable for Dadr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`dadr1::W`](W) writer structure"]
        impl crate::Writable for Dadr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DADR1 to value 0"]
        impl crate::Resettable for Dadr1Spec {}
    }
    #[doc = "CCR2 (rw) register accessor: DMA channel 2 configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
    #[doc(alias = "CCR2")]
    pub type Ccr2 = crate::Reg<ccr2::Ccr2Spec>;
    #[doc = "DMA channel 2 configuration"]
    pub mod ccr2 {
        #[doc = "Register `CCR2` reader"]
        pub type R = crate::R<Ccr2Spec>;
        #[doc = "Register `CCR2` writer"]
        pub type W = crate::W<Ccr2Spec>;
        #[doc = "channel enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum En {
            #[doc = "0: Channel is disabled"]
            Disabled = 0,
            #[doc = "1: Channel is enabled"]
            Enabled = 1,
        }
        impl From<En> for bool {
            #[inline(always)]
            fn from(variant: En) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EN` reader - channel enable"]
        pub type EnR = crate::BitReader<En>;
        impl EnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> En {
                match self.bits {
                    false => En::Disabled,
                    true => En::Enabled,
                }
            }
            #[doc = "Channel is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == En::Disabled
            }
            #[doc = "Channel is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == En::Enabled
            }
        }
        #[doc = "Field `EN` writer - channel enable"]
        pub type EnW<'a, REG> = crate::BitWriter<'a, REG, En>;
        impl<'a, REG> EnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Channel is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Disabled)
            }
            #[doc = "Channel is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Enabled)
            }
        }
        #[doc = "Round mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Rmode {
            #[doc = "0: Single round, multi-times"]
            Single = 0,
            #[doc = "1: Multi-round, single time per round"]
            Multi = 1,
        }
        impl From<Rmode> for bool {
            #[inline(always)]
            fn from(variant: Rmode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RMODE` reader - Round mode"]
        pub type RmodeR = crate::BitReader<Rmode>;
        impl RmodeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Rmode {
                match self.bits {
                    false => Rmode::Single,
                    true => Rmode::Multi,
                }
            }
            #[doc = "Single round, multi-times"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == Rmode::Single
            }
            #[doc = "Multi-round, single time per round"]
            #[inline(always)]
            pub fn is_multi(&self) -> bool {
                *self == Rmode::Multi
            }
        }
        #[doc = "Field `RMODE` writer - Round mode"]
        pub type RmodeW<'a, REG> = crate::BitWriter<'a, REG, Rmode>;
        impl<'a, REG> RmodeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Single round, multi-times"]
            #[inline(always)]
            pub fn single(self) -> &'a mut crate::W<REG> {
                self.variant(Rmode::Single)
            }
            #[doc = "Multi-round, single time per round"]
            #[inline(always)]
            pub fn multi(self) -> &'a mut crate::W<REG> {
                self.variant(Rmode::Multi)
            }
        }
        #[doc = "circular mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Circ {
            #[doc = "0: Normal mode"]
            Normal = 0,
            #[doc = "1: Circular mode"]
            Circ = 1,
        }
        impl From<Circ> for bool {
            #[inline(always)]
            fn from(variant: Circ) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIRC` reader - circular mode"]
        pub type CircR = crate::BitReader<Circ>;
        impl CircR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Circ {
                match self.bits {
                    false => Circ::Normal,
                    true => Circ::Circ,
                }
            }
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == Circ::Normal
            }
            #[doc = "Circular mode"]
            #[inline(always)]
            pub fn is_circ(&self) -> bool {
                *self == Circ::Circ
            }
        }
        #[doc = "Field `CIRC` writer - circular mode"]
        pub type CircW<'a, REG> = crate::BitWriter<'a, REG, Circ>;
        impl<'a, REG> CircW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut crate::W<REG> {
                self.variant(Circ::Normal)
            }
            #[doc = "Circular mode"]
            #[inline(always)]
            pub fn circ(self) -> &'a mut crate::W<REG> {
                self.variant(Circ::Circ)
            }
        }
        #[doc = "Destination Address Incremental\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Dinc {
            #[doc = "0: Source addr will be increased by SBTW each transfer"]
            Ninc = 0,
            #[doc = "1: Description addr will be increased by DBTW each transfer"]
            Inc = 1,
        }
        impl From<Dinc> for bool {
            #[inline(always)]
            fn from(variant: Dinc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DINC` reader - Destination Address Incremental"]
        pub type DincR = crate::BitReader<Dinc>;
        impl DincR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Dinc {
                match self.bits {
                    false => Dinc::Ninc,
                    true => Dinc::Inc,
                }
            }
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn is_ninc(&self) -> bool {
                *self == Dinc::Ninc
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn is_inc(&self) -> bool {
                *self == Dinc::Inc
            }
        }
        #[doc = "Field `DINC` writer - Destination Address Incremental"]
        pub type DincW<'a, REG> = crate::BitWriter<'a, REG, Dinc>;
        impl<'a, REG> DincW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn ninc(self) -> &'a mut crate::W<REG> {
                self.variant(Dinc::Ninc)
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn inc(self) -> &'a mut crate::W<REG> {
                self.variant(Dinc::Inc)
            }
        }
        #[doc = "Source Address Incremental\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sinc {
            #[doc = "0: Source addr will be increased by SBTW each transfer"]
            Ninc = 0,
            #[doc = "1: Description addr will be increased by DBTW each transfer"]
            Inc = 1,
        }
        impl From<Sinc> for bool {
            #[inline(always)]
            fn from(variant: Sinc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SINC` reader - Source Address Incremental"]
        pub type SincR = crate::BitReader<Sinc>;
        impl SincR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sinc {
                match self.bits {
                    false => Sinc::Ninc,
                    true => Sinc::Inc,
                }
            }
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn is_ninc(&self) -> bool {
                *self == Sinc::Ninc
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn is_inc(&self) -> bool {
                *self == Sinc::Inc
            }
        }
        #[doc = "Field `SINC` writer - Source Address Incremental"]
        pub type SincW<'a, REG> = crate::BitWriter<'a, REG, Sinc>;
        impl<'a, REG> SincW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn ninc(self) -> &'a mut crate::W<REG> {
                self.variant(Sinc::Ninc)
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn inc(self) -> &'a mut crate::W<REG> {
                self.variant(Sinc::Inc)
            }
        }
        #[doc = "Destination data width\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Dbtw {
            #[doc = "0: 8bit byte"]
            Byte = 0,
            #[doc = "1: 16bit halfword"]
            Halfword = 1,
            #[doc = "2: 32bit word"]
            Word = 2,
        }
        impl From<Dbtw> for u8 {
            #[inline(always)]
            fn from(variant: Dbtw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Dbtw {
            type Ux = u8;
        }
        impl crate::IsEnum for Dbtw {}
        #[doc = "Field `DBTW` reader - Destination data width"]
        pub type DbtwR = crate::FieldReader<Dbtw>;
        impl DbtwR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Dbtw> {
                match self.bits {
                    0 => Some(Dbtw::Byte),
                    1 => Some(Dbtw::Halfword),
                    2 => Some(Dbtw::Word),
                    _ => None,
                }
            }
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == Dbtw::Byte
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn is_halfword(&self) -> bool {
                *self == Dbtw::Halfword
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn is_word(&self) -> bool {
                *self == Dbtw::Word
            }
        }
        #[doc = "Field `DBTW` writer - Destination data width"]
        pub type DbtwW<'a, REG> = crate::FieldWriter<'a, REG, 2, Dbtw>;
        impl<'a, REG> DbtwW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Byte)
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn halfword(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Halfword)
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn word(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Word)
            }
        }
        #[doc = "Source data width\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Sbtw {
            #[doc = "0: 8bit byte"]
            Byte = 0,
            #[doc = "1: 16bit halfword"]
            Halfword = 1,
            #[doc = "2: 32bit word"]
            Word = 2,
        }
        impl From<Sbtw> for u8 {
            #[inline(always)]
            fn from(variant: Sbtw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Sbtw {
            type Ux = u8;
        }
        impl crate::IsEnum for Sbtw {}
        #[doc = "Field `SBTW` reader - Source data width"]
        pub type SbtwR = crate::FieldReader<Sbtw>;
        impl SbtwR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Sbtw> {
                match self.bits {
                    0 => Some(Sbtw::Byte),
                    1 => Some(Sbtw::Halfword),
                    2 => Some(Sbtw::Word),
                    _ => None,
                }
            }
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == Sbtw::Byte
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn is_halfword(&self) -> bool {
                *self == Sbtw::Halfword
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn is_word(&self) -> bool {
                *self == Sbtw::Word
            }
        }
        #[doc = "Field `SBTW` writer - Source data width"]
        pub type SbtwW<'a, REG> = crate::FieldWriter<'a, REG, 2, Sbtw>;
        impl<'a, REG> SbtwW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Byte)
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn halfword(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Halfword)
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn word(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Word)
            }
        }
        impl R {
            #[doc = "Bit 0 - channel enable"]
            #[inline(always)]
            pub fn en(&self) -> EnR {
                EnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Round mode"]
            #[inline(always)]
            pub fn rmode(&self) -> RmodeR {
                RmodeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - circular mode"]
            #[inline(always)]
            pub fn circ(&self) -> CircR {
                CircR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Destination Address Incremental"]
            #[inline(always)]
            pub fn dinc(&self) -> DincR {
                DincR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - Source Address Incremental"]
            #[inline(always)]
            pub fn sinc(&self) -> SincR {
                SincR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bits 8:9 - Destination data width"]
            #[inline(always)]
            pub fn dbtw(&self) -> DbtwR {
                DbtwR::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Source data width"]
            #[inline(always)]
            pub fn sbtw(&self) -> SbtwR {
                SbtwR::new(((self.bits >> 10) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - channel enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EnW<Ccr2Spec> {
                EnW::new(self, 0)
            }
            #[doc = "Bit 1 - Round mode"]
            #[inline(always)]
            pub fn rmode(&mut self) -> RmodeW<Ccr2Spec> {
                RmodeW::new(self, 1)
            }
            #[doc = "Bit 3 - circular mode"]
            #[inline(always)]
            pub fn circ(&mut self) -> CircW<Ccr2Spec> {
                CircW::new(self, 3)
            }
            #[doc = "Bit 4 - Destination Address Incremental"]
            #[inline(always)]
            pub fn dinc(&mut self) -> DincW<Ccr2Spec> {
                DincW::new(self, 4)
            }
            #[doc = "Bit 6 - Source Address Incremental"]
            #[inline(always)]
            pub fn sinc(&mut self) -> SincW<Ccr2Spec> {
                SincW::new(self, 6)
            }
            #[doc = "Bits 8:9 - Destination data width"]
            #[inline(always)]
            pub fn dbtw(&mut self) -> DbtwW<Ccr2Spec> {
                DbtwW::new(self, 8)
            }
            #[doc = "Bits 10:11 - Source data width"]
            #[inline(always)]
            pub fn sbtw(&mut self) -> SbtwW<Ccr2Spec> {
                SbtwW::new(self, 10)
            }
        }
        #[doc = "DMA channel 2 configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ccr2Spec;
        impl crate::RegisterSpec for Ccr2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ccr2::R`](R) reader structure"]
        impl crate::Readable for Ccr2Spec {}
        #[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"]
        impl crate::Writable for Ccr2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CCR2 to value 0"]
        impl crate::Resettable for Ccr2Spec {}
    }
    #[doc = "REN2 (rw) register accessor: DMA channel 2 request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ren2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ren2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ren2`] module"]
    #[doc(alias = "REN2")]
    pub type Ren2 = crate::Reg<ren2::Ren2Spec>;
    #[doc = "DMA channel 2 request enable"]
    pub mod ren2 {
        #[doc = "Register `REN2` reader"]
        pub type R = crate::R<Ren2Spec>;
        #[doc = "Register `REN2` writer"]
        pub type W = crate::W<Ren2Spec>;
        #[doc = "Field `ADC_TRIG` reader - ADC trigger enable"]
        pub type AdcTrigR = crate::BitReader;
        #[doc = "Field `ADC_TRIG` writer - ADC trigger enable"]
        pub type AdcTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCPWM_TRIG` reader - MCPWM trigger enable"]
        pub type McpwmTrigR = crate::BitReader;
        #[doc = "Field `MCPWM_TRIG` writer - MCPWM trigger enable"]
        pub type McpwmTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HALL_TRIG` reader - HALL trigger enable"]
        pub type HallTrigR = crate::BitReader;
        #[doc = "Field `HALL_TRIG` writer - HALL trigger enable"]
        pub type HallTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER0_TRIG` reader - TIMER0 trigger enable"]
        pub type Timer0TrigR = crate::BitReader;
        #[doc = "Field `TIMER0_TRIG` writer - TIMER0 trigger enable"]
        pub type Timer0TrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER1_TRIG` reader - TIMER1 trigger enable"]
        pub type Timer1TrigR = crate::BitReader;
        #[doc = "Field `TIMER1_TRIG` writer - TIMER1 trigger enable"]
        pub type Timer1TrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UART_RX_TRIG` reader - UART_RX trigger enable"]
        pub type UartRxTrigR = crate::BitReader;
        #[doc = "Field `UART_RX_TRIG` writer - UART_RX trigger enable"]
        pub type UartRxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UART_TX_TRIG` reader - UART_TX trigger enable"]
        pub type UartTxTrigR = crate::BitReader;
        #[doc = "Field `UART_TX_TRIG` writer - UART_TX trigger enable"]
        pub type UartTxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SPI_RX_TRIG` reader - SPI_RX trigger enable"]
        pub type SpiRxTrigR = crate::BitReader;
        #[doc = "Field `SPI_RX_TRIG` writer - SPI_RX trigger enable"]
        pub type SpiRxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SPI_TX_TRIG` reader - SPI_TX trigger enable"]
        pub type SpiTxTrigR = crate::BitReader;
        #[doc = "Field `SPI_TX_TRIG` writer - SPI_TX trigger enable"]
        pub type SpiTxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP_TRIG` reader - CMP trigger enable"]
        pub type CmpTrigR = crate::BitReader;
        #[doc = "Field `CMP_TRIG` writer - CMP trigger enable"]
        pub type CmpTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GPIO_TRIG` reader - GPIO trigger enable"]
        pub type GpioTrigR = crate::BitReader;
        #[doc = "Field `GPIO_TRIG` writer - GPIO trigger enable"]
        pub type GpioTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `I2C_TRIG` reader - I2C trigger enable"]
        pub type I2cTrigR = crate::BitReader;
        #[doc = "Field `I2C_TRIG` writer - I2C trigger enable"]
        pub type I2cTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SW_TRIG` reader - Software trigger enable"]
        pub type SwTrigR = crate::BitReader;
        #[doc = "Field `SW_TRIG` writer - Software trigger enable"]
        pub type SwTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - ADC trigger enable"]
            #[inline(always)]
            pub fn adc_trig(&self) -> AdcTrigR {
                AdcTrigR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - MCPWM trigger enable"]
            #[inline(always)]
            pub fn mcpwm_trig(&self) -> McpwmTrigR {
                McpwmTrigR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - HALL trigger enable"]
            #[inline(always)]
            pub fn hall_trig(&self) -> HallTrigR {
                HallTrigR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - TIMER0 trigger enable"]
            #[inline(always)]
            pub fn timer0_trig(&self) -> Timer0TrigR {
                Timer0TrigR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TIMER1 trigger enable"]
            #[inline(always)]
            pub fn timer1_trig(&self) -> Timer1TrigR {
                Timer1TrigR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - UART_RX trigger enable"]
            #[inline(always)]
            pub fn uart_rx_trig(&self) -> UartRxTrigR {
                UartRxTrigR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - UART_TX trigger enable"]
            #[inline(always)]
            pub fn uart_tx_trig(&self) -> UartTxTrigR {
                UartTxTrigR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 10 - SPI_RX trigger enable"]
            #[inline(always)]
            pub fn spi_rx_trig(&self) -> SpiRxTrigR {
                SpiRxTrigR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - SPI_TX trigger enable"]
            #[inline(always)]
            pub fn spi_tx_trig(&self) -> SpiTxTrigR {
                SpiTxTrigR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - CMP trigger enable"]
            #[inline(always)]
            pub fn cmp_trig(&self) -> CmpTrigR {
                CmpTrigR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - GPIO trigger enable"]
            #[inline(always)]
            pub fn gpio_trig(&self) -> GpioTrigR {
                GpioTrigR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - I2C trigger enable"]
            #[inline(always)]
            pub fn i2c_trig(&self) -> I2cTrigR {
                I2cTrigR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Software trigger enable"]
            #[inline(always)]
            pub fn sw_trig(&self) -> SwTrigR {
                SwTrigR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ADC trigger enable"]
            #[inline(always)]
            pub fn adc_trig(&mut self) -> AdcTrigW<Ren2Spec> {
                AdcTrigW::new(self, 0)
            }
            #[doc = "Bit 1 - MCPWM trigger enable"]
            #[inline(always)]
            pub fn mcpwm_trig(&mut self) -> McpwmTrigW<Ren2Spec> {
                McpwmTrigW::new(self, 1)
            }
            #[doc = "Bit 2 - HALL trigger enable"]
            #[inline(always)]
            pub fn hall_trig(&mut self) -> HallTrigW<Ren2Spec> {
                HallTrigW::new(self, 2)
            }
            #[doc = "Bit 4 - TIMER0 trigger enable"]
            #[inline(always)]
            pub fn timer0_trig(&mut self) -> Timer0TrigW<Ren2Spec> {
                Timer0TrigW::new(self, 4)
            }
            #[doc = "Bit 5 - TIMER1 trigger enable"]
            #[inline(always)]
            pub fn timer1_trig(&mut self) -> Timer1TrigW<Ren2Spec> {
                Timer1TrigW::new(self, 5)
            }
            #[doc = "Bit 6 - UART_RX trigger enable"]
            #[inline(always)]
            pub fn uart_rx_trig(&mut self) -> UartRxTrigW<Ren2Spec> {
                UartRxTrigW::new(self, 6)
            }
            #[doc = "Bit 7 - UART_TX trigger enable"]
            #[inline(always)]
            pub fn uart_tx_trig(&mut self) -> UartTxTrigW<Ren2Spec> {
                UartTxTrigW::new(self, 7)
            }
            #[doc = "Bit 10 - SPI_RX trigger enable"]
            #[inline(always)]
            pub fn spi_rx_trig(&mut self) -> SpiRxTrigW<Ren2Spec> {
                SpiRxTrigW::new(self, 10)
            }
            #[doc = "Bit 11 - SPI_TX trigger enable"]
            #[inline(always)]
            pub fn spi_tx_trig(&mut self) -> SpiTxTrigW<Ren2Spec> {
                SpiTxTrigW::new(self, 11)
            }
            #[doc = "Bit 12 - CMP trigger enable"]
            #[inline(always)]
            pub fn cmp_trig(&mut self) -> CmpTrigW<Ren2Spec> {
                CmpTrigW::new(self, 12)
            }
            #[doc = "Bit 13 - GPIO trigger enable"]
            #[inline(always)]
            pub fn gpio_trig(&mut self) -> GpioTrigW<Ren2Spec> {
                GpioTrigW::new(self, 13)
            }
            #[doc = "Bit 14 - I2C trigger enable"]
            #[inline(always)]
            pub fn i2c_trig(&mut self) -> I2cTrigW<Ren2Spec> {
                I2cTrigW::new(self, 14)
            }
            #[doc = "Bit 15 - Software trigger enable"]
            #[inline(always)]
            pub fn sw_trig(&mut self) -> SwTrigW<Ren2Spec> {
                SwTrigW::new(self, 15)
            }
        }
        #[doc = "DMA channel 2 request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ren2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ren2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ren2Spec;
        impl crate::RegisterSpec for Ren2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ren2::R`](R) reader structure"]
        impl crate::Readable for Ren2Spec {}
        #[doc = "`write(|w| ..)` method takes [`ren2::W`](W) writer structure"]
        impl crate::Writable for Ren2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets REN2 to value 0"]
        impl crate::Resettable for Ren2Spec {}
    }
    #[doc = "CTMS2 (rw) register accessor: DMA channel 2 transmission times\n\nYou can [`read`](crate::Reg::read) this register and get [`ctms2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctms2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctms2`] module"]
    #[doc(alias = "CTMS2")]
    pub type Ctms2 = crate::Reg<ctms2::Ctms2Spec>;
    #[doc = "DMA channel 2 transmission times"]
    pub mod ctms2 {
        #[doc = "Register `CTMS2` reader"]
        pub type R = crate::R<Ctms2Spec>;
        #[doc = "Register `CTMS2` writer"]
        pub type W = crate::W<Ctms2Spec>;
        #[doc = "Field `TMS` reader - times or rounds"]
        pub type TmsR = crate::FieldReader;
        #[doc = "Field `TMS` writer - times or rounds"]
        pub type TmsW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - times or rounds"]
            #[inline(always)]
            pub fn tms(&self) -> TmsR {
                TmsR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - times or rounds"]
            #[inline(always)]
            pub fn tms(&mut self) -> TmsW<Ctms2Spec> {
                TmsW::new(self, 0)
            }
        }
        #[doc = "DMA channel 2 transmission times\n\nYou can [`read`](crate::Reg::read) this register and get [`ctms2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctms2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ctms2Spec;
        impl crate::RegisterSpec for Ctms2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctms2::R`](R) reader structure"]
        impl crate::Readable for Ctms2Spec {}
        #[doc = "`write(|w| ..)` method takes [`ctms2::W`](W) writer structure"]
        impl crate::Writable for Ctms2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTMS2 to value 0"]
        impl crate::Resettable for Ctms2Spec {}
    }
    #[doc = "SADR2 (rw) register accessor: DMA channel 2 source address\n\nYou can [`read`](crate::Reg::read) this register and get [`sadr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sadr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sadr2`] module"]
    #[doc(alias = "SADR2")]
    pub type Sadr2 = crate::Reg<sadr2::Sadr2Spec>;
    #[doc = "DMA channel 2 source address"]
    pub mod sadr2 {
        #[doc = "Register `SADR2` reader"]
        pub type R = crate::R<Sadr2Spec>;
        #[doc = "Register `SADR2` writer"]
        pub type W = crate::W<Sadr2Spec>;
        #[doc = "Field `ADDR` reader - Source Address"]
        pub type AddrR = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Source Address"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Source Address"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Source Address"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<Sadr2Spec> {
                AddrW::new(self, 0)
            }
        }
        #[doc = "DMA channel 2 source address\n\nYou can [`read`](crate::Reg::read) this register and get [`sadr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sadr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Sadr2Spec;
        impl crate::RegisterSpec for Sadr2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sadr2::R`](R) reader structure"]
        impl crate::Readable for Sadr2Spec {}
        #[doc = "`write(|w| ..)` method takes [`sadr2::W`](W) writer structure"]
        impl crate::Writable for Sadr2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SADR2 to value 0"]
        impl crate::Resettable for Sadr2Spec {}
    }
    #[doc = "DADR2 (rw) register accessor: DMA channel 2 destination address\n\nYou can [`read`](crate::Reg::read) this register and get [`dadr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dadr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dadr2`] module"]
    #[doc(alias = "DADR2")]
    pub type Dadr2 = crate::Reg<dadr2::Dadr2Spec>;
    #[doc = "DMA channel 2 destination address"]
    pub mod dadr2 {
        #[doc = "Register `DADR2` reader"]
        pub type R = crate::R<Dadr2Spec>;
        #[doc = "Register `DADR2` writer"]
        pub type W = crate::W<Dadr2Spec>;
        #[doc = "Field `ADDR` reader - Destination Address"]
        pub type AddrR = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Destination Address"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Destination Address"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Destination Address"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<Dadr2Spec> {
                AddrW::new(self, 0)
            }
        }
        #[doc = "DMA channel 2 destination address\n\nYou can [`read`](crate::Reg::read) this register and get [`dadr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dadr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dadr2Spec;
        impl crate::RegisterSpec for Dadr2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dadr2::R`](R) reader structure"]
        impl crate::Readable for Dadr2Spec {}
        #[doc = "`write(|w| ..)` method takes [`dadr2::W`](W) writer structure"]
        impl crate::Writable for Dadr2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DADR2 to value 0"]
        impl crate::Resettable for Dadr2Spec {}
    }
    #[doc = "CCR3 (rw) register accessor: DMA channel 3 configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
    #[doc(alias = "CCR3")]
    pub type Ccr3 = crate::Reg<ccr3::Ccr3Spec>;
    #[doc = "DMA channel 3 configuration"]
    pub mod ccr3 {
        #[doc = "Register `CCR3` reader"]
        pub type R = crate::R<Ccr3Spec>;
        #[doc = "Register `CCR3` writer"]
        pub type W = crate::W<Ccr3Spec>;
        #[doc = "channel enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum En {
            #[doc = "0: Channel is disabled"]
            Disabled = 0,
            #[doc = "1: Channel is enabled"]
            Enabled = 1,
        }
        impl From<En> for bool {
            #[inline(always)]
            fn from(variant: En) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EN` reader - channel enable"]
        pub type EnR = crate::BitReader<En>;
        impl EnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> En {
                match self.bits {
                    false => En::Disabled,
                    true => En::Enabled,
                }
            }
            #[doc = "Channel is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == En::Disabled
            }
            #[doc = "Channel is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == En::Enabled
            }
        }
        #[doc = "Field `EN` writer - channel enable"]
        pub type EnW<'a, REG> = crate::BitWriter<'a, REG, En>;
        impl<'a, REG> EnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Channel is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Disabled)
            }
            #[doc = "Channel is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Enabled)
            }
        }
        #[doc = "Round mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Rmode {
            #[doc = "0: Single round, multi-times"]
            Single = 0,
            #[doc = "1: Multi-round, single time per round"]
            Multi = 1,
        }
        impl From<Rmode> for bool {
            #[inline(always)]
            fn from(variant: Rmode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RMODE` reader - Round mode"]
        pub type RmodeR = crate::BitReader<Rmode>;
        impl RmodeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Rmode {
                match self.bits {
                    false => Rmode::Single,
                    true => Rmode::Multi,
                }
            }
            #[doc = "Single round, multi-times"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == Rmode::Single
            }
            #[doc = "Multi-round, single time per round"]
            #[inline(always)]
            pub fn is_multi(&self) -> bool {
                *self == Rmode::Multi
            }
        }
        #[doc = "Field `RMODE` writer - Round mode"]
        pub type RmodeW<'a, REG> = crate::BitWriter<'a, REG, Rmode>;
        impl<'a, REG> RmodeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Single round, multi-times"]
            #[inline(always)]
            pub fn single(self) -> &'a mut crate::W<REG> {
                self.variant(Rmode::Single)
            }
            #[doc = "Multi-round, single time per round"]
            #[inline(always)]
            pub fn multi(self) -> &'a mut crate::W<REG> {
                self.variant(Rmode::Multi)
            }
        }
        #[doc = "circular mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Circ {
            #[doc = "0: Normal mode"]
            Normal = 0,
            #[doc = "1: Circular mode"]
            Circ = 1,
        }
        impl From<Circ> for bool {
            #[inline(always)]
            fn from(variant: Circ) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIRC` reader - circular mode"]
        pub type CircR = crate::BitReader<Circ>;
        impl CircR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Circ {
                match self.bits {
                    false => Circ::Normal,
                    true => Circ::Circ,
                }
            }
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == Circ::Normal
            }
            #[doc = "Circular mode"]
            #[inline(always)]
            pub fn is_circ(&self) -> bool {
                *self == Circ::Circ
            }
        }
        #[doc = "Field `CIRC` writer - circular mode"]
        pub type CircW<'a, REG> = crate::BitWriter<'a, REG, Circ>;
        impl<'a, REG> CircW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut crate::W<REG> {
                self.variant(Circ::Normal)
            }
            #[doc = "Circular mode"]
            #[inline(always)]
            pub fn circ(self) -> &'a mut crate::W<REG> {
                self.variant(Circ::Circ)
            }
        }
        #[doc = "Destination Address Incremental\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Dinc {
            #[doc = "0: Source addr will be increased by SBTW each transfer"]
            Ninc = 0,
            #[doc = "1: Description addr will be increased by DBTW each transfer"]
            Inc = 1,
        }
        impl From<Dinc> for bool {
            #[inline(always)]
            fn from(variant: Dinc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DINC` reader - Destination Address Incremental"]
        pub type DincR = crate::BitReader<Dinc>;
        impl DincR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Dinc {
                match self.bits {
                    false => Dinc::Ninc,
                    true => Dinc::Inc,
                }
            }
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn is_ninc(&self) -> bool {
                *self == Dinc::Ninc
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn is_inc(&self) -> bool {
                *self == Dinc::Inc
            }
        }
        #[doc = "Field `DINC` writer - Destination Address Incremental"]
        pub type DincW<'a, REG> = crate::BitWriter<'a, REG, Dinc>;
        impl<'a, REG> DincW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn ninc(self) -> &'a mut crate::W<REG> {
                self.variant(Dinc::Ninc)
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn inc(self) -> &'a mut crate::W<REG> {
                self.variant(Dinc::Inc)
            }
        }
        #[doc = "Source Address Incremental\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sinc {
            #[doc = "0: Source addr will be increased by SBTW each transfer"]
            Ninc = 0,
            #[doc = "1: Description addr will be increased by DBTW each transfer"]
            Inc = 1,
        }
        impl From<Sinc> for bool {
            #[inline(always)]
            fn from(variant: Sinc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SINC` reader - Source Address Incremental"]
        pub type SincR = crate::BitReader<Sinc>;
        impl SincR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sinc {
                match self.bits {
                    false => Sinc::Ninc,
                    true => Sinc::Inc,
                }
            }
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn is_ninc(&self) -> bool {
                *self == Sinc::Ninc
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn is_inc(&self) -> bool {
                *self == Sinc::Inc
            }
        }
        #[doc = "Field `SINC` writer - Source Address Incremental"]
        pub type SincW<'a, REG> = crate::BitWriter<'a, REG, Sinc>;
        impl<'a, REG> SincW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Source addr will be increased by SBTW each transfer"]
            #[inline(always)]
            pub fn ninc(self) -> &'a mut crate::W<REG> {
                self.variant(Sinc::Ninc)
            }
            #[doc = "Description addr will be increased by DBTW each transfer"]
            #[inline(always)]
            pub fn inc(self) -> &'a mut crate::W<REG> {
                self.variant(Sinc::Inc)
            }
        }
        #[doc = "Destination data width\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Dbtw {
            #[doc = "0: 8bit byte"]
            Byte = 0,
            #[doc = "1: 16bit halfword"]
            Halfword = 1,
            #[doc = "2: 32bit word"]
            Word = 2,
        }
        impl From<Dbtw> for u8 {
            #[inline(always)]
            fn from(variant: Dbtw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Dbtw {
            type Ux = u8;
        }
        impl crate::IsEnum for Dbtw {}
        #[doc = "Field `DBTW` reader - Destination data width"]
        pub type DbtwR = crate::FieldReader<Dbtw>;
        impl DbtwR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Dbtw> {
                match self.bits {
                    0 => Some(Dbtw::Byte),
                    1 => Some(Dbtw::Halfword),
                    2 => Some(Dbtw::Word),
                    _ => None,
                }
            }
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == Dbtw::Byte
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn is_halfword(&self) -> bool {
                *self == Dbtw::Halfword
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn is_word(&self) -> bool {
                *self == Dbtw::Word
            }
        }
        #[doc = "Field `DBTW` writer - Destination data width"]
        pub type DbtwW<'a, REG> = crate::FieldWriter<'a, REG, 2, Dbtw>;
        impl<'a, REG> DbtwW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Byte)
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn halfword(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Halfword)
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn word(self) -> &'a mut crate::W<REG> {
                self.variant(Dbtw::Word)
            }
        }
        #[doc = "Source data width\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Sbtw {
            #[doc = "0: 8bit byte"]
            Byte = 0,
            #[doc = "1: 16bit halfword"]
            Halfword = 1,
            #[doc = "2: 32bit word"]
            Word = 2,
        }
        impl From<Sbtw> for u8 {
            #[inline(always)]
            fn from(variant: Sbtw) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Sbtw {
            type Ux = u8;
        }
        impl crate::IsEnum for Sbtw {}
        #[doc = "Field `SBTW` reader - Source data width"]
        pub type SbtwR = crate::FieldReader<Sbtw>;
        impl SbtwR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Sbtw> {
                match self.bits {
                    0 => Some(Sbtw::Byte),
                    1 => Some(Sbtw::Halfword),
                    2 => Some(Sbtw::Word),
                    _ => None,
                }
            }
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == Sbtw::Byte
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn is_halfword(&self) -> bool {
                *self == Sbtw::Halfword
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn is_word(&self) -> bool {
                *self == Sbtw::Word
            }
        }
        #[doc = "Field `SBTW` writer - Source data width"]
        pub type SbtwW<'a, REG> = crate::FieldWriter<'a, REG, 2, Sbtw>;
        impl<'a, REG> SbtwW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "8bit byte"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Byte)
            }
            #[doc = "16bit halfword"]
            #[inline(always)]
            pub fn halfword(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Halfword)
            }
            #[doc = "32bit word"]
            #[inline(always)]
            pub fn word(self) -> &'a mut crate::W<REG> {
                self.variant(Sbtw::Word)
            }
        }
        impl R {
            #[doc = "Bit 0 - channel enable"]
            #[inline(always)]
            pub fn en(&self) -> EnR {
                EnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Round mode"]
            #[inline(always)]
            pub fn rmode(&self) -> RmodeR {
                RmodeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - circular mode"]
            #[inline(always)]
            pub fn circ(&self) -> CircR {
                CircR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Destination Address Incremental"]
            #[inline(always)]
            pub fn dinc(&self) -> DincR {
                DincR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - Source Address Incremental"]
            #[inline(always)]
            pub fn sinc(&self) -> SincR {
                SincR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bits 8:9 - Destination data width"]
            #[inline(always)]
            pub fn dbtw(&self) -> DbtwR {
                DbtwR::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Source data width"]
            #[inline(always)]
            pub fn sbtw(&self) -> SbtwR {
                SbtwR::new(((self.bits >> 10) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - channel enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EnW<Ccr3Spec> {
                EnW::new(self, 0)
            }
            #[doc = "Bit 1 - Round mode"]
            #[inline(always)]
            pub fn rmode(&mut self) -> RmodeW<Ccr3Spec> {
                RmodeW::new(self, 1)
            }
            #[doc = "Bit 3 - circular mode"]
            #[inline(always)]
            pub fn circ(&mut self) -> CircW<Ccr3Spec> {
                CircW::new(self, 3)
            }
            #[doc = "Bit 4 - Destination Address Incremental"]
            #[inline(always)]
            pub fn dinc(&mut self) -> DincW<Ccr3Spec> {
                DincW::new(self, 4)
            }
            #[doc = "Bit 6 - Source Address Incremental"]
            #[inline(always)]
            pub fn sinc(&mut self) -> SincW<Ccr3Spec> {
                SincW::new(self, 6)
            }
            #[doc = "Bits 8:9 - Destination data width"]
            #[inline(always)]
            pub fn dbtw(&mut self) -> DbtwW<Ccr3Spec> {
                DbtwW::new(self, 8)
            }
            #[doc = "Bits 10:11 - Source data width"]
            #[inline(always)]
            pub fn sbtw(&mut self) -> SbtwW<Ccr3Spec> {
                SbtwW::new(self, 10)
            }
        }
        #[doc = "DMA channel 3 configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ccr3Spec;
        impl crate::RegisterSpec for Ccr3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ccr3::R`](R) reader structure"]
        impl crate::Readable for Ccr3Spec {}
        #[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"]
        impl crate::Writable for Ccr3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CCR3 to value 0"]
        impl crate::Resettable for Ccr3Spec {}
    }
    #[doc = "REN3 (rw) register accessor: DMA channel 3 request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ren3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ren3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ren3`] module"]
    #[doc(alias = "REN3")]
    pub type Ren3 = crate::Reg<ren3::Ren3Spec>;
    #[doc = "DMA channel 3 request enable"]
    pub mod ren3 {
        #[doc = "Register `REN3` reader"]
        pub type R = crate::R<Ren3Spec>;
        #[doc = "Register `REN3` writer"]
        pub type W = crate::W<Ren3Spec>;
        #[doc = "Field `ADC_TRIG` reader - ADC trigger enable"]
        pub type AdcTrigR = crate::BitReader;
        #[doc = "Field `ADC_TRIG` writer - ADC trigger enable"]
        pub type AdcTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCPWM_TRIG` reader - MCPWM trigger enable"]
        pub type McpwmTrigR = crate::BitReader;
        #[doc = "Field `MCPWM_TRIG` writer - MCPWM trigger enable"]
        pub type McpwmTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HALL_TRIG` reader - HALL trigger enable"]
        pub type HallTrigR = crate::BitReader;
        #[doc = "Field `HALL_TRIG` writer - HALL trigger enable"]
        pub type HallTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER0_TRIG` reader - TIMER0 trigger enable"]
        pub type Timer0TrigR = crate::BitReader;
        #[doc = "Field `TIMER0_TRIG` writer - TIMER0 trigger enable"]
        pub type Timer0TrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIMER1_TRIG` reader - TIMER1 trigger enable"]
        pub type Timer1TrigR = crate::BitReader;
        #[doc = "Field `TIMER1_TRIG` writer - TIMER1 trigger enable"]
        pub type Timer1TrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UART_RX_TRIG` reader - UART_RX trigger enable"]
        pub type UartRxTrigR = crate::BitReader;
        #[doc = "Field `UART_RX_TRIG` writer - UART_RX trigger enable"]
        pub type UartRxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UART_TX_TRIG` reader - UART_TX trigger enable"]
        pub type UartTxTrigR = crate::BitReader;
        #[doc = "Field `UART_TX_TRIG` writer - UART_TX trigger enable"]
        pub type UartTxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SPI_RX_TRIG` reader - SPI_RX trigger enable"]
        pub type SpiRxTrigR = crate::BitReader;
        #[doc = "Field `SPI_RX_TRIG` writer - SPI_RX trigger enable"]
        pub type SpiRxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SPI_TX_TRIG` reader - SPI_TX trigger enable"]
        pub type SpiTxTrigR = crate::BitReader;
        #[doc = "Field `SPI_TX_TRIG` writer - SPI_TX trigger enable"]
        pub type SpiTxTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMP_TRIG` reader - CMP trigger enable"]
        pub type CmpTrigR = crate::BitReader;
        #[doc = "Field `CMP_TRIG` writer - CMP trigger enable"]
        pub type CmpTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GPIO_TRIG` reader - GPIO trigger enable"]
        pub type GpioTrigR = crate::BitReader;
        #[doc = "Field `GPIO_TRIG` writer - GPIO trigger enable"]
        pub type GpioTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `I2C_TRIG` reader - I2C trigger enable"]
        pub type I2cTrigR = crate::BitReader;
        #[doc = "Field `I2C_TRIG` writer - I2C trigger enable"]
        pub type I2cTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SW_TRIG` reader - Software trigger enable"]
        pub type SwTrigR = crate::BitReader;
        #[doc = "Field `SW_TRIG` writer - Software trigger enable"]
        pub type SwTrigW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - ADC trigger enable"]
            #[inline(always)]
            pub fn adc_trig(&self) -> AdcTrigR {
                AdcTrigR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - MCPWM trigger enable"]
            #[inline(always)]
            pub fn mcpwm_trig(&self) -> McpwmTrigR {
                McpwmTrigR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - HALL trigger enable"]
            #[inline(always)]
            pub fn hall_trig(&self) -> HallTrigR {
                HallTrigR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - TIMER0 trigger enable"]
            #[inline(always)]
            pub fn timer0_trig(&self) -> Timer0TrigR {
                Timer0TrigR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TIMER1 trigger enable"]
            #[inline(always)]
            pub fn timer1_trig(&self) -> Timer1TrigR {
                Timer1TrigR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - UART_RX trigger enable"]
            #[inline(always)]
            pub fn uart_rx_trig(&self) -> UartRxTrigR {
                UartRxTrigR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - UART_TX trigger enable"]
            #[inline(always)]
            pub fn uart_tx_trig(&self) -> UartTxTrigR {
                UartTxTrigR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 10 - SPI_RX trigger enable"]
            #[inline(always)]
            pub fn spi_rx_trig(&self) -> SpiRxTrigR {
                SpiRxTrigR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - SPI_TX trigger enable"]
            #[inline(always)]
            pub fn spi_tx_trig(&self) -> SpiTxTrigR {
                SpiTxTrigR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - CMP trigger enable"]
            #[inline(always)]
            pub fn cmp_trig(&self) -> CmpTrigR {
                CmpTrigR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - GPIO trigger enable"]
            #[inline(always)]
            pub fn gpio_trig(&self) -> GpioTrigR {
                GpioTrigR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - I2C trigger enable"]
            #[inline(always)]
            pub fn i2c_trig(&self) -> I2cTrigR {
                I2cTrigR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Software trigger enable"]
            #[inline(always)]
            pub fn sw_trig(&self) -> SwTrigR {
                SwTrigR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ADC trigger enable"]
            #[inline(always)]
            pub fn adc_trig(&mut self) -> AdcTrigW<Ren3Spec> {
                AdcTrigW::new(self, 0)
            }
            #[doc = "Bit 1 - MCPWM trigger enable"]
            #[inline(always)]
            pub fn mcpwm_trig(&mut self) -> McpwmTrigW<Ren3Spec> {
                McpwmTrigW::new(self, 1)
            }
            #[doc = "Bit 2 - HALL trigger enable"]
            #[inline(always)]
            pub fn hall_trig(&mut self) -> HallTrigW<Ren3Spec> {
                HallTrigW::new(self, 2)
            }
            #[doc = "Bit 4 - TIMER0 trigger enable"]
            #[inline(always)]
            pub fn timer0_trig(&mut self) -> Timer0TrigW<Ren3Spec> {
                Timer0TrigW::new(self, 4)
            }
            #[doc = "Bit 5 - TIMER1 trigger enable"]
            #[inline(always)]
            pub fn timer1_trig(&mut self) -> Timer1TrigW<Ren3Spec> {
                Timer1TrigW::new(self, 5)
            }
            #[doc = "Bit 6 - UART_RX trigger enable"]
            #[inline(always)]
            pub fn uart_rx_trig(&mut self) -> UartRxTrigW<Ren3Spec> {
                UartRxTrigW::new(self, 6)
            }
            #[doc = "Bit 7 - UART_TX trigger enable"]
            #[inline(always)]
            pub fn uart_tx_trig(&mut self) -> UartTxTrigW<Ren3Spec> {
                UartTxTrigW::new(self, 7)
            }
            #[doc = "Bit 10 - SPI_RX trigger enable"]
            #[inline(always)]
            pub fn spi_rx_trig(&mut self) -> SpiRxTrigW<Ren3Spec> {
                SpiRxTrigW::new(self, 10)
            }
            #[doc = "Bit 11 - SPI_TX trigger enable"]
            #[inline(always)]
            pub fn spi_tx_trig(&mut self) -> SpiTxTrigW<Ren3Spec> {
                SpiTxTrigW::new(self, 11)
            }
            #[doc = "Bit 12 - CMP trigger enable"]
            #[inline(always)]
            pub fn cmp_trig(&mut self) -> CmpTrigW<Ren3Spec> {
                CmpTrigW::new(self, 12)
            }
            #[doc = "Bit 13 - GPIO trigger enable"]
            #[inline(always)]
            pub fn gpio_trig(&mut self) -> GpioTrigW<Ren3Spec> {
                GpioTrigW::new(self, 13)
            }
            #[doc = "Bit 14 - I2C trigger enable"]
            #[inline(always)]
            pub fn i2c_trig(&mut self) -> I2cTrigW<Ren3Spec> {
                I2cTrigW::new(self, 14)
            }
            #[doc = "Bit 15 - Software trigger enable"]
            #[inline(always)]
            pub fn sw_trig(&mut self) -> SwTrigW<Ren3Spec> {
                SwTrigW::new(self, 15)
            }
        }
        #[doc = "DMA channel 3 request enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ren3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ren3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ren3Spec;
        impl crate::RegisterSpec for Ren3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ren3::R`](R) reader structure"]
        impl crate::Readable for Ren3Spec {}
        #[doc = "`write(|w| ..)` method takes [`ren3::W`](W) writer structure"]
        impl crate::Writable for Ren3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets REN3 to value 0"]
        impl crate::Resettable for Ren3Spec {}
    }
    #[doc = "CTMS3 (rw) register accessor: DMA channel 3 transmission times\n\nYou can [`read`](crate::Reg::read) this register and get [`ctms3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctms3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctms3`] module"]
    #[doc(alias = "CTMS3")]
    pub type Ctms3 = crate::Reg<ctms3::Ctms3Spec>;
    #[doc = "DMA channel 3 transmission times"]
    pub mod ctms3 {
        #[doc = "Register `CTMS3` reader"]
        pub type R = crate::R<Ctms3Spec>;
        #[doc = "Register `CTMS3` writer"]
        pub type W = crate::W<Ctms3Spec>;
        #[doc = "Field `TMS` reader - times or rounds"]
        pub type TmsR = crate::FieldReader;
        #[doc = "Field `TMS` writer - times or rounds"]
        pub type TmsW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - times or rounds"]
            #[inline(always)]
            pub fn tms(&self) -> TmsR {
                TmsR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - times or rounds"]
            #[inline(always)]
            pub fn tms(&mut self) -> TmsW<Ctms3Spec> {
                TmsW::new(self, 0)
            }
        }
        #[doc = "DMA channel 3 transmission times\n\nYou can [`read`](crate::Reg::read) this register and get [`ctms3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctms3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ctms3Spec;
        impl crate::RegisterSpec for Ctms3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctms3::R`](R) reader structure"]
        impl crate::Readable for Ctms3Spec {}
        #[doc = "`write(|w| ..)` method takes [`ctms3::W`](W) writer structure"]
        impl crate::Writable for Ctms3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTMS3 to value 0"]
        impl crate::Resettable for Ctms3Spec {}
    }
    #[doc = "SADR3 (rw) register accessor: DMA channel 3 source address\n\nYou can [`read`](crate::Reg::read) this register and get [`sadr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sadr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sadr3`] module"]
    #[doc(alias = "SADR3")]
    pub type Sadr3 = crate::Reg<sadr3::Sadr3Spec>;
    #[doc = "DMA channel 3 source address"]
    pub mod sadr3 {
        #[doc = "Register `SADR3` reader"]
        pub type R = crate::R<Sadr3Spec>;
        #[doc = "Register `SADR3` writer"]
        pub type W = crate::W<Sadr3Spec>;
        #[doc = "Field `ADDR` reader - Source Address"]
        pub type AddrR = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Source Address"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Source Address"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Source Address"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<Sadr3Spec> {
                AddrW::new(self, 0)
            }
        }
        #[doc = "DMA channel 3 source address\n\nYou can [`read`](crate::Reg::read) this register and get [`sadr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sadr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Sadr3Spec;
        impl crate::RegisterSpec for Sadr3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sadr3::R`](R) reader structure"]
        impl crate::Readable for Sadr3Spec {}
        #[doc = "`write(|w| ..)` method takes [`sadr3::W`](W) writer structure"]
        impl crate::Writable for Sadr3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SADR3 to value 0"]
        impl crate::Resettable for Sadr3Spec {}
    }
    #[doc = "DADR3 (rw) register accessor: DMA channel 3 destination address\n\nYou can [`read`](crate::Reg::read) this register and get [`dadr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dadr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dadr3`] module"]
    #[doc(alias = "DADR3")]
    pub type Dadr3 = crate::Reg<dadr3::Dadr3Spec>;
    #[doc = "DMA channel 3 destination address"]
    pub mod dadr3 {
        #[doc = "Register `DADR3` reader"]
        pub type R = crate::R<Dadr3Spec>;
        #[doc = "Register `DADR3` writer"]
        pub type W = crate::W<Dadr3Spec>;
        #[doc = "Field `ADDR` reader - Destination Address"]
        pub type AddrR = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Destination Address"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Destination Address"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Destination Address"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<Dadr3Spec> {
                AddrW::new(self, 0)
            }
        }
        #[doc = "DMA channel 3 destination address\n\nYou can [`read`](crate::Reg::read) this register and get [`dadr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dadr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dadr3Spec;
        impl crate::RegisterSpec for Dadr3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dadr3::R`](R) reader structure"]
        impl crate::Readable for Dadr3Spec {}
        #[doc = "`write(|w| ..)` method takes [`dadr3::W`](W) writer structure"]
        impl crate::Writable for Dadr3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DADR3 to value 0"]
        impl crate::Resettable for Dadr3Spec {}
    }
    #[doc = "CTRL (rw) register accessor: DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
    #[doc(alias = "CTRL")]
    pub type Ctrl = crate::Reg<ctrl::CtrlSpec>;
    #[doc = "DMA control"]
    pub mod ctrl {
        #[doc = "Register `CTRL` reader"]
        pub type R = crate::R<CtrlSpec>;
        #[doc = "Register `CTRL` writer"]
        pub type W = crate::W<CtrlSpec>;
        #[doc = "DMA enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum En {
            #[doc = "0: DMA is disabled"]
            Disabled = 0,
            #[doc = "1: DMA is enabled"]
            Enabled = 1,
        }
        impl From<En> for bool {
            #[inline(always)]
            fn from(variant: En) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EN` reader - DMA enable"]
        pub type EnR = crate::BitReader<En>;
        impl EnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> En {
                match self.bits {
                    false => En::Disabled,
                    true => En::Enabled,
                }
            }
            #[doc = "DMA is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == En::Disabled
            }
            #[doc = "DMA is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == En::Enabled
            }
        }
        #[doc = "Field `EN` writer - DMA enable"]
        pub type EnW<'a, REG> = crate::BitWriter<'a, REG, En>;
        impl<'a, REG> EnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DMA is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Disabled)
            }
            #[doc = "DMA is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(En::Enabled)
            }
        }
        impl R {
            #[doc = "Bit 0 - DMA enable"]
            #[inline(always)]
            pub fn en(&self) -> EnR {
                EnR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - DMA enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EnW<CtrlSpec> {
                EnW::new(self, 0)
            }
        }
        #[doc = "DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlSpec;
        impl crate::RegisterSpec for CtrlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctrl::R`](R) reader structure"]
        impl crate::Readable for CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"]
        impl crate::Writable for CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL to value 0"]
        impl crate::Resettable for CtrlSpec {}
    }
    #[doc = "IE (rw) register accessor: DMA interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie`] module"]
    #[doc(alias = "IE")]
    pub type Ie = crate::Reg<ie::IeSpec>;
    #[doc = "DMA interrupt enable"]
    pub mod ie {
        #[doc = "Register `IE` reader"]
        pub type R = crate::R<IeSpec>;
        #[doc = "Register `IE` writer"]
        pub type W = crate::W<IeSpec>;
        #[doc = "Field `CH0_FIE` reader - channel 0 transmission finish interrupt enable"]
        pub type Ch0FieR = crate::BitReader;
        #[doc = "Field `CH0_FIE` writer - channel 0 transmission finish interrupt enable"]
        pub type Ch0FieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_FIE` reader - channel 1 transmission finish interrupt enable"]
        pub type Ch1FieR = crate::BitReader;
        #[doc = "Field `CH1_FIE` writer - channel 1 transmission finish interrupt enable"]
        pub type Ch1FieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2_FIE` reader - channel 2 transmission finish interrupt enable"]
        pub type Ch2FieR = crate::BitReader;
        #[doc = "Field `CH2_FIE` writer - channel 2 transmission finish interrupt enable"]
        pub type Ch2FieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3_FIE` reader - channel 3 transmission finish interrupt enable"]
        pub type Ch3FieR = crate::BitReader;
        #[doc = "Field `CH3_FIE` writer - channel 3 transmission finish interrupt enable"]
        pub type Ch3FieW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - channel 0 transmission finish interrupt enable"]
            #[inline(always)]
            pub fn ch0_fie(&self) -> Ch0FieR {
                Ch0FieR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - channel 1 transmission finish interrupt enable"]
            #[inline(always)]
            pub fn ch1_fie(&self) -> Ch1FieR {
                Ch1FieR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - channel 2 transmission finish interrupt enable"]
            #[inline(always)]
            pub fn ch2_fie(&self) -> Ch2FieR {
                Ch2FieR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - channel 3 transmission finish interrupt enable"]
            #[inline(always)]
            pub fn ch3_fie(&self) -> Ch3FieR {
                Ch3FieR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - channel 0 transmission finish interrupt enable"]
            #[inline(always)]
            pub fn ch0_fie(&mut self) -> Ch0FieW<IeSpec> {
                Ch0FieW::new(self, 0)
            }
            #[doc = "Bit 1 - channel 1 transmission finish interrupt enable"]
            #[inline(always)]
            pub fn ch1_fie(&mut self) -> Ch1FieW<IeSpec> {
                Ch1FieW::new(self, 1)
            }
            #[doc = "Bit 2 - channel 2 transmission finish interrupt enable"]
            #[inline(always)]
            pub fn ch2_fie(&mut self) -> Ch2FieW<IeSpec> {
                Ch2FieW::new(self, 2)
            }
            #[doc = "Bit 3 - channel 3 transmission finish interrupt enable"]
            #[inline(always)]
            pub fn ch3_fie(&mut self) -> Ch3FieW<IeSpec> {
                Ch3FieW::new(self, 3)
            }
        }
        #[doc = "DMA interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IeSpec;
        impl crate::RegisterSpec for IeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ie::R`](R) reader structure"]
        impl crate::Readable for IeSpec {}
        #[doc = "`write(|w| ..)` method takes [`ie::W`](W) writer structure"]
        impl crate::Writable for IeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE to value 0"]
        impl crate::Resettable for IeSpec {}
    }
    #[doc = "IF (rw) register accessor: DMA interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@if_`] module"]
    #[doc(alias = "IF")]
    pub type If = crate::Reg<if_::IfSpec>;
    #[doc = "DMA interrupt flag"]
    pub mod if_ {
        #[doc = "Register `IF` reader"]
        pub type R = crate::R<IfSpec>;
        #[doc = "Register `IF` writer"]
        pub type W = crate::W<IfSpec>;
        #[doc = "Field `CH0_FIF` reader - channel 0 transmission finish interrupt flag"]
        pub type Ch0FifR = crate::BitReader;
        #[doc = "Field `CH0_FIF` writer - channel 0 transmission finish interrupt flag"]
        pub type Ch0FifW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH1_FIF` reader - channel 1 transmission finish interrupt flag"]
        pub type Ch1FifR = crate::BitReader;
        #[doc = "Field `CH1_FIF` writer - channel 1 transmission finish interrupt flag"]
        pub type Ch1FifW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH2_FIF` reader - channel 2 transmission finish interrupt flag"]
        pub type Ch2FifR = crate::BitReader;
        #[doc = "Field `CH2_FIF` writer - channel 2 transmission finish interrupt flag"]
        pub type Ch2FifW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH3_FIF` reader - channel 3 transmission finish interrupt flag"]
        pub type Ch3FifR = crate::BitReader;
        #[doc = "Field `CH3_FIF` writer - channel 3 transmission finish interrupt flag"]
        pub type Ch3FifW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - channel 0 transmission finish interrupt flag"]
            #[inline(always)]
            pub fn ch0_fif(&self) -> Ch0FifR {
                Ch0FifR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - channel 1 transmission finish interrupt flag"]
            #[inline(always)]
            pub fn ch1_fif(&self) -> Ch1FifR {
                Ch1FifR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - channel 2 transmission finish interrupt flag"]
            #[inline(always)]
            pub fn ch2_fif(&self) -> Ch2FifR {
                Ch2FifR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - channel 3 transmission finish interrupt flag"]
            #[inline(always)]
            pub fn ch3_fif(&self) -> Ch3FifR {
                Ch3FifR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - channel 0 transmission finish interrupt flag"]
            #[inline(always)]
            pub fn ch0_fif(&mut self) -> Ch0FifW<IfSpec> {
                Ch0FifW::new(self, 0)
            }
            #[doc = "Bit 1 - channel 1 transmission finish interrupt flag"]
            #[inline(always)]
            pub fn ch1_fif(&mut self) -> Ch1FifW<IfSpec> {
                Ch1FifW::new(self, 1)
            }
            #[doc = "Bit 2 - channel 2 transmission finish interrupt flag"]
            #[inline(always)]
            pub fn ch2_fif(&mut self) -> Ch2FifW<IfSpec> {
                Ch2FifW::new(self, 2)
            }
            #[doc = "Bit 3 - channel 3 transmission finish interrupt flag"]
            #[inline(always)]
            pub fn ch3_fif(&mut self) -> Ch3FifW<IfSpec> {
                Ch3FifW::new(self, 3)
            }
        }
        #[doc = "DMA interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`if_::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`if_::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IfSpec;
        impl crate::RegisterSpec for IfSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`if_::R`](R) reader structure"]
        impl crate::Readable for IfSpec {}
        #[doc = "`write(|w| ..)` method takes [`if_::W`](W) writer structure"]
        impl crate::Writable for IfSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IF to value 0"]
        impl crate::Resettable for IfSpec {}
    }
}
#[doc = "DSP registers"]
pub type Dsp = crate::Periph<dsp::RegisterBlock, 0x4001_0b00>;
impl core::fmt::Debug for Dsp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dsp").finish()
    }
}
#[doc = "DSP registers"]
pub mod dsp {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x20],
        did: Did,
        dis: Dis,
        quo: Quo,
        rem: Rem,
        rad: Rad,
        sqrt: Sqrt,
    }
    impl RegisterBlock {
        #[doc = "0x20 - DSP dividend"]
        #[inline(always)]
        pub const fn did(&self) -> &Did {
            &self.did
        }
        #[doc = "0x24 - DSP divider"]
        #[inline(always)]
        pub const fn dis(&self) -> &Dis {
            &self.dis
        }
        #[doc = "0x28 - DSP quotient"]
        #[inline(always)]
        pub const fn quo(&self) -> &Quo {
            &self.quo
        }
        #[doc = "0x2c - DSP remainder"]
        #[inline(always)]
        pub const fn rem(&self) -> &Rem {
            &self.rem
        }
        #[doc = "0x30 - DSP radicand"]
        #[inline(always)]
        pub const fn rad(&self) -> &Rad {
            &self.rad
        }
        #[doc = "0x34 - DSP square root"]
        #[inline(always)]
        pub const fn sqrt(&self) -> &Sqrt {
            &self.sqrt
        }
    }
    #[doc = "DID (rw) register accessor: DSP dividend\n\nYou can [`read`](crate::Reg::read) this register and get [`did::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`did::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@did`] module"]
    #[doc(alias = "DID")]
    pub type Did = crate::Reg<did::DidSpec>;
    #[doc = "DSP dividend"]
    pub mod did {
        #[doc = "Register `DID` reader"]
        pub type R = crate::R<DidSpec>;
        #[doc = "Register `DID` writer"]
        pub type W = crate::W<DidSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "DSP dividend\n\nYou can [`read`](crate::Reg::read) this register and get [`did::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`did::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DidSpec;
        impl crate::RegisterSpec for DidSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`did::R`](R) reader structure"]
        impl crate::Readable for DidSpec {}
        #[doc = "`write(|w| ..)` method takes [`did::W`](W) writer structure"]
        impl crate::Writable for DidSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DID to value 0"]
        impl crate::Resettable for DidSpec {}
    }
    #[doc = "DIS (rw) register accessor: DSP divider\n\nYou can [`read`](crate::Reg::read) this register and get [`dis::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dis::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dis`] module"]
    #[doc(alias = "DIS")]
    pub type Dis = crate::Reg<dis::DisSpec>;
    #[doc = "DSP divider"]
    pub mod dis {
        #[doc = "Register `DIS` reader"]
        pub type R = crate::R<DisSpec>;
        #[doc = "Register `DIS` writer"]
        pub type W = crate::W<DisSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "DSP divider\n\nYou can [`read`](crate::Reg::read) this register and get [`dis::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dis::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DisSpec;
        impl crate::RegisterSpec for DisSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dis::R`](R) reader structure"]
        impl crate::Readable for DisSpec {}
        #[doc = "`write(|w| ..)` method takes [`dis::W`](W) writer structure"]
        impl crate::Writable for DisSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DIS to value 0"]
        impl crate::Resettable for DisSpec {}
    }
    #[doc = "QUO (r) register accessor: DSP quotient\n\nYou can [`read`](crate::Reg::read) this register and get [`quo::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@quo`] module"]
    #[doc(alias = "QUO")]
    pub type Quo = crate::Reg<quo::QuoSpec>;
    #[doc = "DSP quotient"]
    pub mod quo {
        #[doc = "Register `QUO` reader"]
        pub type R = crate::R<QuoSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        #[doc = "DSP quotient\n\nYou can [`read`](crate::Reg::read) this register and get [`quo::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct QuoSpec;
        impl crate::RegisterSpec for QuoSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`quo::R`](R) reader structure"]
        impl crate::Readable for QuoSpec {}
        #[doc = "`reset()` method sets QUO to value 0"]
        impl crate::Resettable for QuoSpec {}
    }
    #[doc = "REM (r) register accessor: DSP remainder\n\nYou can [`read`](crate::Reg::read) this register and get [`rem::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rem`] module"]
    #[doc(alias = "REM")]
    pub type Rem = crate::Reg<rem::RemSpec>;
    #[doc = "DSP remainder"]
    pub mod rem {
        #[doc = "Register `REM` reader"]
        pub type R = crate::R<RemSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        #[doc = "DSP remainder\n\nYou can [`read`](crate::Reg::read) this register and get [`rem::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RemSpec;
        impl crate::RegisterSpec for RemSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rem::R`](R) reader structure"]
        impl crate::Readable for RemSpec {}
        #[doc = "`reset()` method sets REM to value 0"]
        impl crate::Resettable for RemSpec {}
    }
    #[doc = "RAD (rw) register accessor: DSP radicand\n\nYou can [`read`](crate::Reg::read) this register and get [`rad::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rad::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rad`] module"]
    #[doc(alias = "RAD")]
    pub type Rad = crate::Reg<rad::RadSpec>;
    #[doc = "DSP radicand"]
    pub mod rad {
        #[doc = "Register `RAD` reader"]
        pub type R = crate::R<RadSpec>;
        #[doc = "Register `RAD` writer"]
        pub type W = crate::W<RadSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "DSP radicand\n\nYou can [`read`](crate::Reg::read) this register and get [`rad::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rad::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RadSpec;
        impl crate::RegisterSpec for RadSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rad::R`](R) reader structure"]
        impl crate::Readable for RadSpec {}
        #[doc = "`write(|w| ..)` method takes [`rad::W`](W) writer structure"]
        impl crate::Writable for RadSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets RAD to value 0"]
        impl crate::Resettable for RadSpec {}
    }
    #[doc = "SQRT (r) register accessor: DSP square root\n\nYou can [`read`](crate::Reg::read) this register and get [`sqrt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqrt`] module"]
    #[doc(alias = "SQRT")]
    pub type Sqrt = crate::Reg<sqrt::SqrtSpec>;
    #[doc = "DSP square root"]
    pub mod sqrt {
        #[doc = "Register `SQRT` reader"]
        pub type R = crate::R<SqrtSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        #[doc = "DSP square root\n\nYou can [`read`](crate::Reg::read) this register and get [`sqrt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SqrtSpec;
        impl crate::RegisterSpec for SqrtSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`sqrt::R`](R) reader structure"]
        impl crate::Readable for SqrtSpec {}
        #[doc = "`reset()` method sets SQRT to value 0"]
        impl crate::Resettable for SqrtSpec {}
    }
}
#[doc = "IWDG registers"]
pub type Iwdg = crate::Periph<iwdg::RegisterBlock, 0x4001_0c00>;
impl core::fmt::Debug for Iwdg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iwdg").finish()
    }
}
#[doc = "IWDG registers"]
pub mod iwdg {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        psw: Psw,
        _reserved1: [u8; 0x02],
        cfg: Cfg,
        _reserved2: [u8; 0x02],
        clr: Clr,
        wth: Wth,
        rth: Rth,
        cnt: Cnt,
    }
    impl RegisterBlock {
        #[doc = "0x00 - IWDG password"]
        #[inline(always)]
        pub const fn psw(&self) -> &Psw {
            &self.psw
        }
        #[doc = "0x04 - IWDG configuration"]
        #[inline(always)]
        pub const fn cfg(&self) -> &Cfg {
            &self.cfg
        }
        #[doc = "0x08 - IWDG counter clear"]
        #[inline(always)]
        pub const fn clr(&self) -> &Clr {
            &self.clr
        }
        #[doc = "0x0c - IWDG wakeup threshold"]
        #[inline(always)]
        pub const fn wth(&self) -> &Wth {
            &self.wth
        }
        #[doc = "0x10 - IWDG reset threshold"]
        #[inline(always)]
        pub const fn rth(&self) -> &Rth {
            &self.rth
        }
        #[doc = "0x14 - IWDG counter"]
        #[inline(always)]
        pub const fn cnt(&self) -> &Cnt {
            &self.cnt
        }
    }
    #[doc = "PSW (w) register accessor: IWDG password\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psw::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psw`] module"]
    #[doc(alias = "PSW")]
    pub type Psw = crate::Reg<psw::PswSpec>;
    #[doc = "IWDG password"]
    pub mod psw {
        #[doc = "Register `PSW` writer"]
        pub type W = crate::W<PswSpec>;
        impl core::fmt::Debug for crate::generic::Reg<PswSpec> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {}
        #[doc = "IWDG password\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psw::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PswSpec;
        impl crate::RegisterSpec for PswSpec {
            type Ux = u16;
        }
        #[doc = "`write(|w| ..)` method takes [`psw::W`](W) writer structure"]
        impl crate::Writable for PswSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PSW to value 0"]
        impl crate::Resettable for PswSpec {}
    }
    #[doc = "CFG (rw) register accessor: IWDG configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"]
    #[doc(alias = "CFG")]
    pub type Cfg = crate::Reg<cfg::CfgSpec>;
    #[doc = "IWDG configuration"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CfgSpec>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CfgSpec>;
        #[doc = "IWDG enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WdgEn {
            #[doc = "0: IWDG is disabled"]
            Disabled = 0,
            #[doc = "1: IWDG is enabled"]
            Enabled = 1,
        }
        impl From<WdgEn> for bool {
            #[inline(always)]
            fn from(variant: WdgEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `WDG_EN` reader - IWDG enable"]
        pub type WdgEnR = crate::BitReader<WdgEn>;
        impl WdgEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> WdgEn {
                match self.bits {
                    false => WdgEn::Disabled,
                    true => WdgEn::Enabled,
                }
            }
            #[doc = "IWDG is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WdgEn::Disabled
            }
            #[doc = "IWDG is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WdgEn::Enabled
            }
        }
        #[doc = "Field `WDG_EN` writer - IWDG enable"]
        pub type WdgEnW<'a, REG> = crate::BitWriter<'a, REG, WdgEn>;
        impl<'a, REG> WdgEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "IWDG is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(WdgEn::Disabled)
            }
            #[doc = "IWDG is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(WdgEn::Enabled)
            }
        }
        #[doc = "Deep wakeup enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DwkEn {
            #[doc = "0: IWDG deep wakeup signal is disabled"]
            Disabled = 0,
            #[doc = "1: IWDG deep wakeup signal is enabled"]
            Enabled = 1,
        }
        impl From<DwkEn> for bool {
            #[inline(always)]
            fn from(variant: DwkEn) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DWK_EN` reader - Deep wakeup enable"]
        pub type DwkEnR = crate::BitReader<DwkEn>;
        impl DwkEnR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DwkEn {
                match self.bits {
                    false => DwkEn::Disabled,
                    true => DwkEn::Enabled,
                }
            }
            #[doc = "IWDG deep wakeup signal is disabled"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DwkEn::Disabled
            }
            #[doc = "IWDG deep wakeup signal is enabled"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DwkEn::Enabled
            }
        }
        #[doc = "Field `DWK_EN` writer - Deep wakeup enable"]
        pub type DwkEnW<'a, REG> = crate::BitWriter<'a, REG, DwkEn>;
        impl<'a, REG> DwkEnW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "IWDG deep wakeup signal is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(DwkEn::Disabled)
            }
            #[doc = "IWDG deep wakeup signal is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(DwkEn::Enabled)
            }
        }
        impl R {
            #[doc = "Bit 0 - IWDG enable"]
            #[inline(always)]
            pub fn wdg_en(&self) -> WdgEnR {
                WdgEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 4 - Deep wakeup enable"]
            #[inline(always)]
            pub fn dwk_en(&self) -> DwkEnR {
                DwkEnR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - IWDG enable"]
            #[inline(always)]
            pub fn wdg_en(&mut self) -> WdgEnW<CfgSpec> {
                WdgEnW::new(self, 0)
            }
            #[doc = "Bit 4 - Deep wakeup enable"]
            #[inline(always)]
            pub fn dwk_en(&mut self) -> DwkEnW<CfgSpec> {
                DwkEnW::new(self, 4)
            }
        }
        #[doc = "IWDG configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgSpec;
        impl crate::RegisterSpec for CfgSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFG to value 0"]
        impl crate::Resettable for CfgSpec {}
    }
    #[doc = "CLR (w) register accessor: IWDG counter clear\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clr`] module"]
    #[doc(alias = "CLR")]
    pub type Clr = crate::Reg<clr::ClrSpec>;
    #[doc = "IWDG counter clear"]
    pub mod clr {
        #[doc = "Register `CLR` writer"]
        pub type W = crate::W<ClrSpec>;
        impl core::fmt::Debug for crate::generic::Reg<ClrSpec> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {}
        #[doc = "IWDG counter clear\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClrSpec;
        impl crate::RegisterSpec for ClrSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`clr::W`](W) writer structure"]
        impl crate::Writable for ClrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLR to value 0"]
        impl crate::Resettable for ClrSpec {}
    }
    #[doc = "WTH (rw) register accessor: IWDG wakeup threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`wth::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wth::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wth`] module"]
    #[doc(alias = "WTH")]
    pub type Wth = crate::Reg<wth::WthSpec>;
    #[doc = "IWDG wakeup threshold"]
    pub mod wth {
        #[doc = "Register `WTH` reader"]
        pub type R = crate::R<WthSpec>;
        #[doc = "Register `WTH` writer"]
        pub type W = crate::W<WthSpec>;
        #[doc = "Field `WTH` reader - IWDG wakeup theshold"]
        pub type WthR = crate::FieldReader<u16>;
        #[doc = "Field `WTH` writer - IWDG wakeup theshold"]
        pub type WthW<'a, REG> = crate::FieldWriter<'a, REG, 9, u16>;
        impl R {
            #[doc = "Bits 12:20 - IWDG wakeup theshold"]
            #[inline(always)]
            pub fn wth(&self) -> WthR {
                WthR::new(((self.bits >> 12) & 0x01ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 12:20 - IWDG wakeup theshold"]
            #[inline(always)]
            pub fn wth(&mut self) -> WthW<WthSpec> {
                WthW::new(self, 12)
            }
        }
        #[doc = "IWDG wakeup threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`wth::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wth::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct WthSpec;
        impl crate::RegisterSpec for WthSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`wth::R`](R) reader structure"]
        impl crate::Readable for WthSpec {}
        #[doc = "`write(|w| ..)` method takes [`wth::W`](W) writer structure"]
        impl crate::Writable for WthSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets WTH to value 0"]
        impl crate::Resettable for WthSpec {}
    }
    #[doc = "RTH (rw) register accessor: IWDG reset threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`rth::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rth::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rth`] module"]
    #[doc(alias = "RTH")]
    pub type Rth = crate::Reg<rth::RthSpec>;
    #[doc = "IWDG reset threshold"]
    pub mod rth {
        #[doc = "Register `RTH` reader"]
        pub type R = crate::R<RthSpec>;
        #[doc = "Register `RTH` writer"]
        pub type W = crate::W<RthSpec>;
        #[doc = "Field `RTH` reader - IWDG bite theshold"]
        pub type RthR = crate::FieldReader<u16>;
        #[doc = "Field `RTH` writer - IWDG bite theshold"]
        pub type RthW<'a, REG> = crate::FieldWriter<'a, REG, 9, u16>;
        impl R {
            #[doc = "Bits 12:20 - IWDG bite theshold"]
            #[inline(always)]
            pub fn rth(&self) -> RthR {
                RthR::new(((self.bits >> 12) & 0x01ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 12:20 - IWDG bite theshold"]
            #[inline(always)]
            pub fn rth(&mut self) -> RthW<RthSpec> {
                RthW::new(self, 12)
            }
        }
        #[doc = "IWDG reset threshold\n\nYou can [`read`](crate::Reg::read) this register and get [`rth::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rth::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RthSpec;
        impl crate::RegisterSpec for RthSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rth::R`](R) reader structure"]
        impl crate::Readable for RthSpec {}
        #[doc = "`write(|w| ..)` method takes [`rth::W`](W) writer structure"]
        impl crate::Writable for RthSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets RTH to value 0"]
        impl crate::Resettable for RthSpec {}
    }
    #[doc = "CNT (r) register accessor: IWDG counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
    #[doc(alias = "CNT")]
    pub type Cnt = crate::Reg<cnt::CntSpec>;
    #[doc = "IWDG counter"]
    pub mod cnt {
        #[doc = "Register `CNT` reader"]
        pub type R = crate::R<CntSpec>;
        #[doc = "Field `CNT` reader - IWDG counter value"]
        pub type CntR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:20 - IWDG counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CntR {
                CntR::new(self.bits & 0x001f_ffff)
            }
        }
        #[doc = "IWDG counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CntSpec;
        impl crate::RegisterSpec for CntSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt::R`](R) reader structure"]
        impl crate::Readable for CntSpec {}
        #[doc = "`reset()` method sets CNT to value 0"]
        impl crate::Resettable for CntSpec {}
    }
}
#[doc = "AON registers"]
pub type Aon = crate::Periph<aon::RegisterBlock, 0x4001_0c20>;
impl core::fmt::Debug for Aon {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Aon").finish()
    }
}
#[doc = "AON registers"]
pub mod aon {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        pwr_cfg: PwrCfg,
        evt_rcd: EvtRcd,
        io_wake_pol: IoWakePol,
        io_wake_en: IoWakeEn,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Power management configure"]
        #[inline(always)]
        pub const fn pwr_cfg(&self) -> &PwrCfg {
            &self.pwr_cfg
        }
        #[doc = "0x04 - Event record"]
        #[inline(always)]
        pub const fn evt_rcd(&self) -> &EvtRcd {
            &self.evt_rcd
        }
        #[doc = "0x08 - IO wakeup signal polarity"]
        #[inline(always)]
        pub const fn io_wake_pol(&self) -> &IoWakePol {
            &self.io_wake_pol
        }
        #[doc = "0x0c - IO wakeup enable"]
        #[inline(always)]
        pub const fn io_wake_en(&self) -> &IoWakeEn {
            &self.io_wake_en
        }
    }
    #[doc = "PWR_CFG (rw) register accessor: Power management configure\n\nYou can [`read`](crate::Reg::read) this register and get [`pwr_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwr_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwr_cfg`] module"]
    #[doc(alias = "PWR_CFG")]
    pub type PwrCfg = crate::Reg<pwr_cfg::PwrCfgSpec>;
    #[doc = "Power management configure"]
    pub mod pwr_cfg {
        #[doc = "Register `PWR_CFG` reader"]
        pub type R = crate::R<PwrCfgSpec>;
        #[doc = "Register `PWR_CFG` writer"]
        pub type W = crate::W<PwrCfgSpec>;
        #[doc = "Field `IOWK_FLT` reader - IO wakeup filter enable"]
        pub type IowkFltR = crate::BitReader;
        #[doc = "Field `IOWK_FLT` writer - IO wakeup filter enable"]
        pub type IowkFltW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 1 - IO wakeup filter enable"]
            #[inline(always)]
            pub fn iowk_flt(&self) -> IowkFltR {
                IowkFltR::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - IO wakeup filter enable"]
            #[inline(always)]
            pub fn iowk_flt(&mut self) -> IowkFltW<PwrCfgSpec> {
                IowkFltW::new(self, 1)
            }
        }
        #[doc = "Power management configure\n\nYou can [`read`](crate::Reg::read) this register and get [`pwr_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwr_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PwrCfgSpec;
        impl crate::RegisterSpec for PwrCfgSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwr_cfg::R`](R) reader structure"]
        impl crate::Readable for PwrCfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwr_cfg::W`](W) writer structure"]
        impl crate::Writable for PwrCfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWR_CFG to value 0"]
        impl crate::Resettable for PwrCfgSpec {}
    }
    #[doc = "EVT_RCD (rw) register accessor: Event record\n\nYou can [`read`](crate::Reg::read) this register and get [`evt_rcd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evt_rcd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@evt_rcd`] module"]
    #[doc(alias = "EVT_RCD")]
    pub type EvtRcd = crate::Reg<evt_rcd::EvtRcdSpec>;
    #[doc = "Event record"]
    pub mod evt_rcd {
        #[doc = "Register `EVT_RCD` reader"]
        pub type R = crate::R<EvtRcdSpec>;
        #[doc = "Register `EVT_RCD` writer"]
        pub type W = crate::W<EvtRcdSpec>;
        #[doc = "Field `POR_RST` reader - POR record"]
        pub type PorRstR = crate::BitReader;
        #[doc = "Field `KEY_RST` reader - Key reset record"]
        pub type KeyRstR = crate::BitReader;
        #[doc = "Field `IWDG_RST` reader - IWDG reset record"]
        pub type IwdgRstR = crate::BitReader;
        #[doc = "Field `IO_WK` reader - IO wakeup record"]
        pub type IoWkR = crate::BitReader;
        #[doc = "Field `IWDG_WK` reader - IWDG wakeup record"]
        pub type IwdgWkR = crate::BitReader;
        #[doc = "Field `SLEEP` reader - Sleep record"]
        pub type SleepR = crate::BitReader;
        #[doc = "Field `DEEPSLEEP` reader - Deep sleep record"]
        pub type DeepsleepR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - POR record"]
            #[inline(always)]
            pub fn por_rst(&self) -> PorRstR {
                PorRstR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - Key reset record"]
            #[inline(always)]
            pub fn key_rst(&self) -> KeyRstR {
                KeyRstR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - IWDG reset record"]
            #[inline(always)]
            pub fn iwdg_rst(&self) -> IwdgRstR {
                IwdgRstR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 8 - IO wakeup record"]
            #[inline(always)]
            pub fn io_wk(&self) -> IoWkR {
                IoWkR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - IWDG wakeup record"]
            #[inline(always)]
            pub fn iwdg_wk(&self) -> IwdgWkR {
                IwdgWkR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 12 - Sleep record"]
            #[inline(always)]
            pub fn sleep(&self) -> SleepR {
                SleepR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Deep sleep record"]
            #[inline(always)]
            pub fn deepsleep(&self) -> DeepsleepR {
                DeepsleepR::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {}
        #[doc = "Event record\n\nYou can [`read`](crate::Reg::read) this register and get [`evt_rcd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evt_rcd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvtRcdSpec;
        impl crate::RegisterSpec for EvtRcdSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`evt_rcd::R`](R) reader structure"]
        impl crate::Readable for EvtRcdSpec {}
        #[doc = "`write(|w| ..)` method takes [`evt_rcd::W`](W) writer structure"]
        impl crate::Writable for EvtRcdSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets EVT_RCD to value 0"]
        impl crate::Resettable for EvtRcdSpec {}
    }
    #[doc = "IO_WAKE_POL (rw) register accessor: IO wakeup signal polarity\n\nYou can [`read`](crate::Reg::read) this register and get [`io_wake_pol::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`io_wake_pol::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@io_wake_pol`] module"]
    #[doc(alias = "IO_WAKE_POL")]
    pub type IoWakePol = crate::Reg<io_wake_pol::IoWakePolSpec>;
    #[doc = "IO wakeup signal polarity"]
    pub mod io_wake_pol {
        #[doc = "Register `IO_WAKE_POL` reader"]
        pub type R = crate::R<IoWakePolSpec>;
        #[doc = "Register `IO_WAKE_POL` writer"]
        pub type W = crate::W<IoWakePolSpec>;
        #[doc = "Field `WK_POL` reader - Wakeup signal polarity"]
        pub type WkPolR = crate::BitReader;
        #[doc = "Field `WK_POL` writer - Wakeup signal polarity"]
        pub type WkPolW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Wakeup signal polarity"]
            #[inline(always)]
            pub fn wk_pol(&self) -> WkPolR {
                WkPolR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Wakeup signal polarity"]
            #[inline(always)]
            pub fn wk_pol(&mut self) -> WkPolW<IoWakePolSpec> {
                WkPolW::new(self, 0)
            }
        }
        #[doc = "IO wakeup signal polarity\n\nYou can [`read`](crate::Reg::read) this register and get [`io_wake_pol::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`io_wake_pol::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IoWakePolSpec;
        impl crate::RegisterSpec for IoWakePolSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`io_wake_pol::R`](R) reader structure"]
        impl crate::Readable for IoWakePolSpec {}
        #[doc = "`write(|w| ..)` method takes [`io_wake_pol::W`](W) writer structure"]
        impl crate::Writable for IoWakePolSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IO_WAKE_POL to value 0"]
        impl crate::Resettable for IoWakePolSpec {}
    }
    #[doc = "IO_WAKE_EN (rw) register accessor: IO wakeup enable\n\nYou can [`read`](crate::Reg::read) this register and get [`io_wake_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`io_wake_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@io_wake_en`] module"]
    #[doc(alias = "IO_WAKE_EN")]
    pub type IoWakeEn = crate::Reg<io_wake_en::IoWakeEnSpec>;
    #[doc = "IO wakeup enable"]
    pub mod io_wake_en {
        #[doc = "Register `IO_WAKE_EN` reader"]
        pub type R = crate::R<IoWakeEnSpec>;
        #[doc = "Register `IO_WAKE_EN` writer"]
        pub type W = crate::W<IoWakeEnSpec>;
        #[doc = "Field `P0_0_EN` reader - P0.0 wakeup enable"]
        pub type P0_0EnR = crate::BitReader;
        #[doc = "Field `P0_0_EN` writer - P0.0 wakeup enable"]
        pub type P0_0EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P0_2_EN` reader - P0.2 wakeup enable"]
        pub type P0_2EnR = crate::BitReader;
        #[doc = "Field `P0_2_EN` writer - P0.2 wakeup enable"]
        pub type P0_2EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P0_8_EN` reader - P0.8 wakeup enable"]
        pub type P0_8EnR = crate::BitReader;
        #[doc = "Field `P0_8_EN` writer - P0.8 wakeup enable"]
        pub type P0_8EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P0_9_EN` reader - P0.9 wakeup enable"]
        pub type P0_9EnR = crate::BitReader;
        #[doc = "Field `P0_9_EN` writer - P0.9 wakeup enable"]
        pub type P0_9EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P0_10_EN` reader - P0.10 wakeup enable"]
        pub type P0_10EnR = crate::BitReader;
        #[doc = "Field `P0_10_EN` writer - P0.10 wakeup enable"]
        pub type P0_10EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1_5_EN` reader - P1.5 wakeup enable"]
        pub type P1_5EnR = crate::BitReader;
        #[doc = "Field `P1_5_EN` writer - P1.5 wakeup enable"]
        pub type P1_5EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1_8_EN` reader - P1.8 wakeup enable"]
        pub type P1_8EnR = crate::BitReader;
        #[doc = "Field `P1_8_EN` writer - P1.8 wakeup enable"]
        pub type P1_8EnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1_9_EN` reader - P1.9 wakeup enable"]
        pub type P1_9EnR = crate::BitReader;
        #[doc = "Field `P1_9_EN` writer - P1.9 wakeup enable"]
        pub type P1_9EnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0.0 wakeup enable"]
            #[inline(always)]
            pub fn p0_0_en(&self) -> P0_0EnR {
                P0_0EnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P0.2 wakeup enable"]
            #[inline(always)]
            pub fn p0_2_en(&self) -> P0_2EnR {
                P0_2EnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P0.8 wakeup enable"]
            #[inline(always)]
            pub fn p0_8_en(&self) -> P0_8EnR {
                P0_8EnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P0.9 wakeup enable"]
            #[inline(always)]
            pub fn p0_9_en(&self) -> P0_9EnR {
                P0_9EnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P0.10 wakeup enable"]
            #[inline(always)]
            pub fn p0_10_en(&self) -> P0_10EnR {
                P0_10EnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P1.5 wakeup enable"]
            #[inline(always)]
            pub fn p1_5_en(&self) -> P1_5EnR {
                P1_5EnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P1.8 wakeup enable"]
            #[inline(always)]
            pub fn p1_8_en(&self) -> P1_8EnR {
                P1_8EnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P1.9 wakeup enable"]
            #[inline(always)]
            pub fn p1_9_en(&self) -> P1_9EnR {
                P1_9EnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0.0 wakeup enable"]
            #[inline(always)]
            pub fn p0_0_en(&mut self) -> P0_0EnW<IoWakeEnSpec> {
                P0_0EnW::new(self, 0)
            }
            #[doc = "Bit 1 - P0.2 wakeup enable"]
            #[inline(always)]
            pub fn p0_2_en(&mut self) -> P0_2EnW<IoWakeEnSpec> {
                P0_2EnW::new(self, 1)
            }
            #[doc = "Bit 2 - P0.8 wakeup enable"]
            #[inline(always)]
            pub fn p0_8_en(&mut self) -> P0_8EnW<IoWakeEnSpec> {
                P0_8EnW::new(self, 2)
            }
            #[doc = "Bit 3 - P0.9 wakeup enable"]
            #[inline(always)]
            pub fn p0_9_en(&mut self) -> P0_9EnW<IoWakeEnSpec> {
                P0_9EnW::new(self, 3)
            }
            #[doc = "Bit 4 - P0.10 wakeup enable"]
            #[inline(always)]
            pub fn p0_10_en(&mut self) -> P0_10EnW<IoWakeEnSpec> {
                P0_10EnW::new(self, 4)
            }
            #[doc = "Bit 5 - P1.5 wakeup enable"]
            #[inline(always)]
            pub fn p1_5_en(&mut self) -> P1_5EnW<IoWakeEnSpec> {
                P1_5EnW::new(self, 5)
            }
            #[doc = "Bit 6 - P1.8 wakeup enable"]
            #[inline(always)]
            pub fn p1_8_en(&mut self) -> P1_8EnW<IoWakeEnSpec> {
                P1_8EnW::new(self, 6)
            }
            #[doc = "Bit 7 - P1.9 wakeup enable"]
            #[inline(always)]
            pub fn p1_9_en(&mut self) -> P1_9EnW<IoWakeEnSpec> {
                P1_9EnW::new(self, 7)
            }
        }
        #[doc = "IO wakeup enable\n\nYou can [`read`](crate::Reg::read) this register and get [`io_wake_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`io_wake_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IoWakeEnSpec;
        impl crate::RegisterSpec for IoWakeEnSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`io_wake_en::R`](R) reader structure"]
        impl crate::Readable for IoWakeEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`io_wake_en::W`](W) writer structure"]
        impl crate::Writable for IoWakeEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IO_WAKE_EN to value 0"]
        impl crate::Resettable for IoWakeEnSpec {}
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "SYS"]
    pub sys: Sys,
    #[doc = "FLASH"]
    pub flash: Flash,
    #[doc = "SPI"]
    pub spi: Spi,
    #[doc = "I2C"]
    pub i2c: I2c,
    #[doc = "CMP"]
    pub cmp: Cmp,
    #[doc = "HALL"]
    pub hall: Hall,
    #[doc = "ADC"]
    pub adc: Adc,
    #[doc = "UTIMER0"]
    pub utimer0: Utimer0,
    #[doc = "UTIMER1"]
    pub utimer1: Utimer1,
    #[doc = "MCPWM"]
    pub mcpwm: Mcpwm,
    #[doc = "GPIO0"]
    pub gpio0: Gpio0,
    #[doc = "GPIO1"]
    pub gpio1: Gpio1,
    #[doc = "EXTI"]
    pub exti: Exti,
    #[doc = "UART"]
    pub uart: Uart,
    #[doc = "DMA"]
    pub dma: Dma,
    #[doc = "DSP"]
    pub dsp: Dsp,
    #[doc = "IWDG"]
    pub iwdg: Iwdg,
    #[doc = "AON"]
    pub aon: Aon,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            sys: Sys::steal(),
            flash: Flash::steal(),
            spi: Spi::steal(),
            i2c: I2c::steal(),
            cmp: Cmp::steal(),
            hall: Hall::steal(),
            adc: Adc::steal(),
            utimer0: Utimer0::steal(),
            utimer1: Utimer1::steal(),
            mcpwm: Mcpwm::steal(),
            gpio0: Gpio0::steal(),
            gpio1: Gpio1::steal(),
            exti: Exti::steal(),
            uart: Uart::steal(),
            dma: Dma::steal(),
            dsp: Dsp::steal(),
            iwdg: Iwdg::steal(),
            aon: Aon::steal(),
        }
    }
}
